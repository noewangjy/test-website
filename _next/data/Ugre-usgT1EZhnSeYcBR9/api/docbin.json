{"pageProps":{"title":"DocBin","tag":"class","version":2.2,"teaser":"Pack Doc objects for binary serialization","source":"spacy/tokens/_serialize.py","slug":"/api/docbin","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" class lets you efficiently serialize the information from a\\ncollection of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects. You can control which information is serialized by\\npassing a list of attribute IDs, and optionally also specify whether the user\\ndata is serialized. The \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" is faster and produces smaller data sizes than\\npickle, and allows you to deserialize without executing arbitrary Python code. A\\nnotable downside to this format is that you can’t easily extract just one\\ndocument from the \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \". The serialization format is gzipped msgpack, where\\nthe msgpack object has the following structure:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"msgpack object structure\",\n          children: \"{\\n    \\\"version\\\": str,           # DocBin version number\\n    \\\"attrs\\\": List[uint64],    # e.g. [TAG, HEAD, ENT_IOB, ENT_TYPE]\\n    \\\"tokens\\\": bytes,          # Serialized numpy uint64 array with the token data\\n    \\\"spaces\\\": bytes,          # Serialized numpy boolean array with spaces data\\n    \\\"lengths\\\": bytes,         # Serialized numpy int32 array with the doc lengths\\n    \\\"strings\\\": List[str]      # List of unique strings in the token data\\n}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Strings for the words, tags, labels etc are represented by 64-bit hashes in the\\ntoken data, and every string that occurs at least once is passed via the strings\\nobject. This means the storage is more efficient if you pack more documents\\ntogether, because you have less duplication in the strings. For usage examples,\\nsee the docs on \", _jsxs(_components.a, {\n          href: \"/usage/saving-loading#docs\",\n          children: [\"serializing \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects\"]\n        }), \".\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"DocBin.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Create a \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" object to hold serialized annotations.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import DocBin\\ndoc_bin = DocBin(attrs=[\\\"ENT_IOB\\\", \\\"ENT_TYPE\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of attributes to serialize. \", _jsx(InlineCode, {\n                children: \"ORTH\"\n              }), \" (hash of token text) and \", _jsx(InlineCode, {\n                children: \"SPACY\"\n              }), \" (whether the token is followed by whitespace) are always serialized, so they’re not required. Defaults to \", _jsx(InlineCode, {\n                children: \"(\\\"ORTH\\\", \\\"TAG\\\", \\\"HEAD\\\", \\\"DEP\\\", \\\"ENT_IOB\\\", \\\"ENT_TYPE\\\", \\\"ENT_KB_ID\\\", \\\"LEMMA\\\", \\\"MORPH\\\", \\\"POS\\\")\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"store_user_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to write the \", _jsx(InlineCode, {\n                children: \"Doc.user_data\"\n              }), \" and the values of custom extension attributes to file/bytes. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" objects to add on initialization. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"DocBin.__len__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the number of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects that were added to the \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc_bin = DocBin(attrs=[\\\"LEMMA\\\"])\\ndoc = nlp(\\\"This is a document to serialize.\\\")\\ndoc_bin.add(doc)\\nassert len(doc_bin) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \"s added to the \", _jsx(InlineCode, {\n                children: \"DocBin\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add\",\n      children: [_jsx(_components.h2, {\n        id: \"add\",\n        tag: \"method\",\n        children: \"DocBin.add \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"’s annotations to the \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" for serialization.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc_bin = DocBin(attrs=[\\\"LEMMA\\\"])\\ndoc = nlp(\\\"This is a document to serialize.\\\")\\ndoc_bin.add(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to add. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_docs\",\n      children: [_jsx(_components.h2, {\n        id: \"get_docs\",\n        tag: \"method\",\n        children: \"DocBin.get_docs \"\n      }), _jsxs(_components.p, {\n        children: [\"Recover \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects from the annotations, using the given vocab.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"docs = list(doc_bin.get_docs(nlp.vocab))\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared vocab. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" objects. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-merge\",\n      children: [_jsx(_components.h2, {\n        id: \"merge\",\n        tag: \"method\",\n        children: \"DocBin.merge \"\n      }), _jsxs(_components.p, {\n        children: [\"Extend the annotations of this \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" with the annotations from another. Will\\nraise an error if the pre-defined \", _jsx(InlineCode, {\n          children: \"attrs\"\n        }), \" of the two \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \"s don’t match.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc_bin1 = DocBin(attrs=[\\\"LEMMA\\\", \\\"POS\\\"])\\ndoc_bin1.add(nlp(\\\"Hello world\\\"))\\ndoc_bin2 = DocBin(attrs=[\\\"LEMMA\\\", \\\"POS\\\"])\\ndoc_bin2.add(nlp(\\\"This is a sentence\\\"))\\ndoc_bin1.merge(doc_bin2)\\nassert len(doc_bin1) == 2\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"other\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"DocBin\"\n              }), \" to merge into the current bin. \", _jsx(_components.del, {\n                children: \"DocBin\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"DocBin.to_bytes \"\n      }), _jsxs(_components.p, {\n        children: [\"Serialize the \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \"’s annotations to a bytestring.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"docs = [nlp(\\\"Hello world!\\\")]\\ndoc_bin = DocBin(docs=docs)\\ndoc_bin_bytes = doc_bin.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized \", _jsx(InlineCode, {\n                children: \"DocBin\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"DocBin.from_bytes \"\n      }), _jsxs(_components.p, {\n        children: [\"Deserialize the \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \"’s annotations from a bytestring.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc_bin_bytes = doc_bin.to_bytes()\\nnew_doc_bin = DocBin().from_bytes(doc_bin_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The data to load from. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The loaded \", _jsx(InlineCode, {\n                children: \"DocBin\"\n              }), \". \", _jsx(_components.del, {\n                children: \"DocBin\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"DocBin.to_disk \"\n      }), _jsxs(_components.p, {\n        children: [\"Save the serialized \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" to a file. Typically uses the \", _jsx(InlineCode, {\n          children: \".spacy\"\n        }), \" extension\\nand the result can be used as the input data for\\n\", _jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"docs = [nlp(\\\"Hello world!\\\")]\\ndoc_bin = DocBin(docs=docs)\\ndoc_bin.to_disk(\\\"./data.spacy\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The file path, typically with the \", _jsx(InlineCode, {\n                children: \".spacy\"\n              }), \" extension. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"DocBin.from_disk \"\n      }), _jsxs(_components.p, {\n        children: [\"Load a serialized \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" from a file. Typically uses the \", _jsx(InlineCode, {\n          children: \".spacy\"\n        }), \" extension.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc_bin = DocBin().from_disk(\\\"./data.spacy\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The file path, typically with the \", _jsx(InlineCode, {\n                children: \".spacy\"\n              }), \" extension. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The loaded \", _jsx(InlineCode, {\n                children: \"DocBin\"\n              }), \". \", _jsx(_components.del, {\n                children: \"DocBin\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"DocBin","tag":"class","version":2.2,"teaser":"Pack Doc objects for binary serialization","source":"spacy/tokens/_serialize.py"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}