{"pageProps":{"title":"Token","teaser":"An individual token — i.e. a word, punctuation symbol, whitespace, etc.","tag":"class","source":"spacy/tokens/token.pyx","slug":"/api/token","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    strong: \"strong\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {InlineCode, Tag} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Token.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Construct a \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" object.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ntoken = doc[0]\\nassert token.text == \\\"Give\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A storage container for lexical types. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The parent document. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"offset\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token within the document. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"Token.__len__ \"\n      }), _jsxs(_components.p, {\n        children: [\"The number of unicode characters in the token, i.e. \", _jsx(InlineCode, {\n          children: \"token.text\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ntoken = doc[0]\\nassert len(token) == 4\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of unicode characters in the token. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"set_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Token.set_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Define a custom attribute on the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" which becomes available via \", _jsx(InlineCode, {\n          children: \"Token._\"\n        }), \".\\nFor details, see the documentation on\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-attributes\",\n          children: \"custom attributes\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Token\\nfruit_getter = lambda token: token.text in (\\\"apple\\\", \\\"pear\\\", \\\"banana\\\")\\nToken.set_extension(\\\"is_fruit\\\", getter=fruit_getter)\\ndoc = nlp(\\\"I have an apple\\\")\\nassert doc[3]._.is_fruit\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the attribute to set by the extension. For example, \", _jsx(InlineCode, {\n                children: \"\\\"my_attr\\\"\"\n              }), \" will be available as \", _jsx(InlineCode, {\n                children: \"token._.my_attr\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"default\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional default value of the attribute if no getter or method is defined. \", _jsx(_components.del, {\n                children: \"Optional[Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"method\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Set a custom method on the object, for example \", _jsx(InlineCode, {\n                children: \"token._.compare(other_token)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Token, …], Any]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Getter function that takes the object and returns an attribute value. Is called when the user accesses the \", _jsx(InlineCode, {\n                children: \"._\"\n              }), \" attribute. \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Token], Any]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"setter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Setter function that takes the \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \" and a value, and modifies the object. Is called when the user writes to the \", _jsx(InlineCode, {\n                children: \"Token._\"\n              }), \" attribute. \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Token, Any], None]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"force\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Force overwriting existing attribute. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"get_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Token.get_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Look up a previously registered extension by name. Returns a 4-tuple\\n\", _jsx(InlineCode, {\n          children: \"(default, method, getter, setter)\"\n        }), \" if the extension is registered. Raises a\\n\", _jsx(InlineCode, {\n          children: \"KeyError\"\n        }), \" otherwise.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Token\\nToken.set_extension(\\\"is_fruit\\\", default=False)\\nextension = Token.get_extension(\\\"is_fruit\\\")\\nassert extension == (False, None, None, None)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"(default, method, getter, setter)\"\n              }), \" tuple of the extension. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Any], Optional[Callable], Optional[Callable], Optional[Callable]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"has_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Token.has_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Check whether an extension has been registered on the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" class.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Token\\nToken.set_extension(\\\"is_fruit\\\", default=False)\\nassert Token.has_extension(\\\"is_fruit\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension to check. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the extension has been registered. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"remove_extension\",\n        tag: \"classmethod\",\n        version: \"2.0.11\",\n        children: \"Token.remove_extension \"\n      }), _jsx(_components.p, {\n        children: \"Remove a previously registered extension.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Token\\nToken.set_extension(\\\"is_fruit\\\", default=False)\\nremoved = Token.remove_extension(\\\"is_fruit\\\")\\nassert not Token.has_extension(\\\"is_fruit\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"(default, method, getter, setter)\"\n              }), \" tuple of the removed extension. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Any], Optional[Callable], Optional[Callable], Optional[Callable]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-check_flag\",\n      children: [_jsx(_components.h2, {\n        id: \"check_flag\",\n        tag: \"method\",\n        children: \"Token.check_flag \"\n      }), _jsx(_components.p, {\n        children: \"Check the value of a boolean flag.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs import IS_TITLE\\ndoc = nlp(\\\"Give it back! He pleaded.\\\")\\ntoken = doc[0]\\nassert token.check_flag(IS_TITLE) == True\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"flag_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute ID of the flag to check. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the flag is set. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-similarity\",\n      children: [_jsx(_components.h2, {\n        id: \"similarity\",\n        tag: \"method\",\n        model: \"vectors\",\n        children: \"Token.similarity \"\n      }), _jsx(_components.p, {\n        children: \"Compute a semantic similarity estimate. Defaults to cosine over vectors.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"apples, _, oranges = nlp(\\\"apples and oranges\\\")\\napples_oranges = apples.similarity(oranges)\\noranges_apples = oranges.similarity(apples)\\nassert apples_oranges == oranges_apples\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"other\"\n            }), _jsxs(_components.td, {\n              children: [\"The object to compare with. By default, accepts \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"Lexeme\"\n              }), \" objects. \", _jsx(_components.del, {\n                children: \"Union[Doc, Span, Token, Lexeme]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A scalar similarity score. Higher is more similar. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-nbor\",\n      children: [_jsx(_components.h2, {\n        id: \"nbor\",\n        tag: \"method\",\n        children: \"Token.nbor \"\n      }), _jsx(_components.p, {\n        children: \"Get a neighboring token.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ngive_nbor = doc[0].nbor()\\nassert give_nbor.text == \\\"it\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"i\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The relative position of the token to get. Defaults to \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token at position \", _jsx(InlineCode, {\n                children: \"self.doc[self.i+i]\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_morph\",\n      children: [_jsx(_components.h2, {\n        id: \"set_morph\",\n        tag: \"method\",\n        children: \"Token.set_morph \"\n      }), _jsxs(_components.p, {\n        children: [\"Set the morphological analysis from a UD FEATS string, hash value of a UD FEATS\\nstring, features dict or \", _jsx(InlineCode, {\n          children: \"MorphAnalysis\"\n        }), \". The value \", _jsx(InlineCode, {\n          children: \"None\"\n        }), \" can be used to reset\\nthe morph to an unset state.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ndoc[0].set_morph(\\\"Mood=Imp|VerbForm=Fin\\\")\\nassert \\\"Mood=Imp\\\" in doc[0].morph\\nassert doc[0].morph.get(\\\"Mood\\\") == [\\\"Imp\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"features\"\n            }), _jsxs(_components.td, {\n              children: [\"The morphological features to set. \", _jsx(_components.del, {\n                children: \"Union[int, dict, str, MorphAnalysis, None]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_morph\",\n      children: [_jsx(_components.h2, {\n        id: \"has_morph\",\n        tag: \"method\",\n        children: \"Token.has_morph \"\n      }), _jsxs(_components.p, {\n        children: [\"Check whether the token has annotated morph information. Return \", _jsx(InlineCode, {\n          children: \"False\"\n        }), \" when the\\nmorph annotation is unset/missing.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the morph annotation is set. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-is_ancestor\",\n      children: [_jsx(_components.h2, {\n        id: \"is_ancestor\",\n        tag: \"method\",\n        model: \"parser\",\n        children: \"Token.is_ancestor \"\n      }), _jsx(_components.p, {\n        children: \"Check whether this token is a parent, grandparent, etc. of another in the\\ndependency tree.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ngive = doc[0]\\nit = doc[1]\\nassert give.is_ancestor(it)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"descendant\"\n            }), _jsxs(_components.td, {\n              children: [\"Another token. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether this token is the ancestor of the descendant. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-ancestors\",\n      children: [_jsx(_components.h2, {\n        id: \"ancestors\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.ancestors \"\n      }), _jsx(_components.p, {\n        children: \"A sequence of the token’s syntactic ancestors (parents, grandparents, etc).\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\nit_ancestors = doc[1].ancestors\\nassert [t.text for t in it_ancestors] == [\\\"Give\\\"]\\nhe_ancestors = doc[4].ancestors\\nassert [t.text for t in he_ancestors] == [\\\"pleaded\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A sequence of ancestor tokens such that \", _jsx(InlineCode, {\n                children: \"ancestor.is_ancestor(self)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-conjuncts\",\n      children: [_jsx(_components.h2, {\n        id: \"conjuncts\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.conjuncts \"\n      }), _jsx(_components.p, {\n        children: \"A tuple of coordinated tokens, not including the token itself.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples and oranges\\\")\\napples_conjuncts = doc[2].conjuncts\\nassert [t.text for t in apples_conjuncts] == [\\\"oranges\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The coordinated tokens. \", _jsx(_components.del, {\n                children: \"Tuple[Token, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-children\",\n      children: [_jsx(_components.h2, {\n        id: \"children\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.children \"\n      }), _jsx(_components.p, {\n        children: \"A sequence of the token’s immediate syntactic children.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ngive_children = doc[0].children\\nassert [t.text for t in give_children] == [\\\"it\\\", \\\"back\\\", \\\"!\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A child token such that \", _jsx(InlineCode, {\n                children: \"child.head == self\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-lefts\",\n      children: [_jsx(_components.h2, {\n        id: \"lefts\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.lefts \"\n      }), _jsx(_components.p, {\n        children: \"The leftward immediate children of the word in the syntactic dependency parse.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like New York in Autumn.\\\")\\nlefts = [t.text for t in doc[3].lefts]\\nassert lefts == [\\\"New\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A left-child of the token. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-rights\",\n      children: [_jsx(_components.h2, {\n        id: \"rights\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.rights \"\n      }), _jsx(_components.p, {\n        children: \"The rightward immediate children of the word in the syntactic dependency parse.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like New York in Autumn.\\\")\\nrights = [t.text for t in doc[3].rights]\\nassert rights == [\\\"in\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A right-child of the token. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-n_lefts\",\n      children: [_jsx(_components.h2, {\n        id: \"n_lefts\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.n_lefts \"\n      }), _jsx(_components.p, {\n        children: \"The number of leftward immediate children of the word in the syntactic\\ndependency parse.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like New York in Autumn.\\\")\\nassert doc[3].n_lefts == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of left-child tokens. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-n_rights\",\n      children: [_jsx(_components.h2, {\n        id: \"n_rights\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.n_rights \"\n      }), _jsx(_components.p, {\n        children: \"The number of rightward immediate children of the word in the syntactic\\ndependency parse.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like New York in Autumn.\\\")\\nassert doc[3].n_rights == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of right-child tokens. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-subtree\",\n      children: [_jsx(_components.h2, {\n        id: \"subtree\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Token.subtree \"\n      }), _jsx(_components.p, {\n        children: \"A sequence containing the token and all the token’s syntactic descendants.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ngive_subtree = doc[0].subtree\\nassert [t.text for t in give_subtree] == [\\\"Give\\\", \\\"it\\\", \\\"back\\\", \\\"!\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A descendant token such that \", _jsx(InlineCode, {\n                children: \"self.is_ancestor(token)\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"token == self\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_vector\",\n      children: [_jsx(_components.h2, {\n        id: \"has_vector\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Token.has_vector \"\n      }), _jsx(_components.p, {\n        children: \"A boolean value indicating whether a word vector is associated with the token.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples\\\")\\napples = doc[2]\\nassert apples.has_vector\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the token has a vector data attached. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-vector\",\n      children: [_jsx(_components.h2, {\n        id: \"vector\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Token.vector \"\n      }), _jsx(_components.p, {\n        children: \"A real-valued meaning representation.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples\\\")\\napples = doc[2]\\nassert apples.vector.dtype == \\\"float32\\\"\\nassert apples.vector.shape == (300,)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A 1-dimensional array representing the token’s vector. \", _jsx(_components.del, {\n                children: \"numpy.ndarray[ndim=1, dtype=float32]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-vector_norm\",\n      children: [_jsx(_components.h2, {\n        id: \"vector_norm\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Token.vector_norm \"\n      }), _jsx(_components.p, {\n        children: \"The L2 norm of the token’s vector representation.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples and pasta\\\")\\napples = doc[2]\\npasta = doc[4]\\napples.vector_norm  # 6.89589786529541\\npasta.vector_norm  # 7.759851932525635\\nassert apples.vector_norm != pasta.vector_norm\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The L2 norm of the vector representation. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"attributes\",\n        children: \"Attributes \"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The parent document. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"lex\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The underlying lexeme. \", _jsx(_components.del, {\n                children: \"Lexeme\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sent\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The sentence span that this token is a part of. \", _jsx(_components.del, {\n                children: \"Span\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"text\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Verbatim text content. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"text_with_ws\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Text content, with trailing space character if present. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"whitespace_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Trailing space character if present. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"orth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the verbatim text content. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"orth_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Verbatim text content (identical to \", _jsx(InlineCode, {\n                children: \"Token.text\"\n              }), \"). Exists mostly for consistency with the other attributes. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The vocab object of the parent \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \". \", _jsx(_components.del, {\n                children: \"vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tensor\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s slice of the parent \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \"’s tensor. \", _jsx(_components.del, {\n                children: \"numpy.ndarray\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"head\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The syntactic parent, or “governor”, of this token. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"left_edge\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The leftmost token of this token’s syntactic descendants. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"right_edge\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The rightmost token of this token’s syntactic descendants. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"i\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token within the parent document. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_type\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Named entity type. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_type_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Named entity type. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_iob\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"IOB code of named entity tag. \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \" means the token begins an entity, \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" means it is outside an entity, \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \" means it is inside an entity, and \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" means no entity tag is set. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_iob_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"IOB code of named entity tag. “B” means the token begins an entity, “I” means it is inside an entity, “O” means it is outside an entity, and \\\"\\\" means no entity tag is set. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_kb_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Knowledge base ID that refers to the named entity this token is a part of, if any. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_kb_id_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Knowledge base ID that refers to the named entity this token is a part of, if any. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the entity the token is an instance of, if any. Currently not used, but potentially for coreference resolution. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_id_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the entity the token is an instance of, if any. Currently not used, but potentially for coreference resolution. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lemma\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Base form of the token, with no inflectional suffixes. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lemma_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Base form of the token, with no inflectional suffixes. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"norm\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s norm, i.e. a normalized form of the token text. Can be set in the language’s \", _jsx(_components.a, {\n                href: \"/usage/linguistic-features#language-data\",\n                children: \"tokenizer exceptions\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"norm_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s norm, i.e. a normalized form of the token text. Can be set in the language’s \", _jsx(_components.a, {\n                href: \"/usage/linguistic-features#language-data\",\n                children: \"tokenizer exceptions\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lower\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Lowercase form of the token. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lower_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Lowercase form of the token text. Equivalent to \", _jsx(InlineCode, {\n                children: \"Token.text.lower()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"shape\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Transform of the token’s string to show orthographic features. Alphabetic characters are replaced by \", _jsx(InlineCode, {\n                children: \"x\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"X\"\n              }), \", and numeric characters are replaced by \", _jsx(InlineCode, {\n                children: \"d\"\n              }), \", and sequences of the same character are truncated after length 4. For example,\", _jsx(InlineCode, {\n                children: \"\\\"Xxxx\\\"\"\n              }), \"or\", _jsx(InlineCode, {\n                children: \"\\\"dd\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"shape_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Transform of the token’s string to show orthographic features. Alphabetic characters are replaced by \", _jsx(InlineCode, {\n                children: \"x\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"X\"\n              }), \", and numeric characters are replaced by \", _jsx(InlineCode, {\n                children: \"d\"\n              }), \", and sequences of the same character are truncated after length 4. For example,\", _jsx(InlineCode, {\n                children: \"\\\"Xxxx\\\"\"\n              }), \"or\", _jsx(InlineCode, {\n                children: \"\\\"dd\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Hash value of a length-N substring from the start of the token. Defaults to \", _jsx(InlineCode, {\n                children: \"N=1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prefix_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A length-N substring from the start of the token. Defaults to \", _jsx(InlineCode, {\n                children: \"N=1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"suffix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Hash value of a length-N substring from the end of the token. Defaults to \", _jsx(InlineCode, {\n                children: \"N=3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"suffix_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Length-N substring from the end of the token. Defaults to \", _jsx(InlineCode, {\n                children: \"N=3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_alpha\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token consist of alphabetic characters? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.isalpha()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_ascii\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token consist of ASCII characters? Equivalent to \", _jsx(InlineCode, {\n                children: \"all(ord(c) < 128 for c in token.text)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_digit\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token consist of digits? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.isdigit()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_lower\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token in lowercase? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.islower()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_upper\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token in uppercase? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.isupper()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_title\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token in titlecase? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.istitle()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_punct\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token punctuation? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_left_punct\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token a left punctuation mark, e.g. \", _jsx(InlineCode, {\n                children: \"\\\"(\\\"\"\n              }), \" ? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_right_punct\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token a right punctuation mark, e.g. \", _jsx(InlineCode, {\n                children: \"\\\")\\\"\"\n              }), \" ? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_sent_start\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token start a sentence? \", _jsx(_components.del, {\n                children: \"bool\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \" if unknown. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \" for the first token in the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_sent_end\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token end a sentence? \", _jsx(_components.del, {\n                children: \"bool\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \" if unknown.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_space\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token consist of whitespace characters? Equivalent to \", _jsx(InlineCode, {\n                children: \"token.text.isspace()\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_bracket\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token a bracket? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_quote\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token a quotation mark? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_currency\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token a currency symbol? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"like_url\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token resemble a URL? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"like_num\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token represent a number? e.g. “10.9”, “10”, “ten”, etc. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"like_email\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Does the token resemble an email address? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_oov\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token out-of-vocabulary (i.e. does it not have a word vector)? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"is_stop\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Is the token part of a “stop list”? \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pos\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Coarse-grained part-of-speech from the \", _jsx(_components.a, {\n                href: \"https://universaldependencies.org/u/pos/\",\n                children: \"Universal POS tag set\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pos_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Coarse-grained part-of-speech from the \", _jsx(_components.a, {\n                href: \"https://universaldependencies.org/u/pos/\",\n                children: \"Universal POS tag set\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tag\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Fine-grained part-of-speech. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tag_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Fine-grained part-of-speech. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"morph\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Morphological analysis. \", _jsx(_components.del, {\n                children: \"MorphAnalysis\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dep\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Syntactic dependency relation. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dep_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Syntactic dependency relation. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lang\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Language of the parent document’s vocabulary. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lang_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Language of the parent document’s vocabulary. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prob\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Smoothed log probability estimate of token’s word type (context-independent entry in the vocabulary). \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"idx\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The character offset of the token within the parent document. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sentiment\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A scalar value indicating the positivity or negativity of the token. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lex_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Sequential ID of the token’s lexical type, used to index into tables, e.g. for word vectors. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"rank\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Sequential ID of the token’s lexical type, used to index into tables, e.g. for word vectors. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cluster\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Brown cluster ID. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"User space for adding custom \", _jsx(_components.a, {\n                href: \"/usage/processing-pipelines#custom-components-attributes\",\n                children: \"attribute extensions\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Underscore\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Token","teaser":"An individual token — i.e. a word, punctuation symbol, whitespace, etc.","tag":"class","source":"spacy/tokens/token.pyx"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}