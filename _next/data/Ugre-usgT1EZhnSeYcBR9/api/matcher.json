{"pageProps":{"title":"Matcher","teaser":"Match sequences of tokens, based on pattern rules","tag":"class","source":"spacy/matcher/matcher.pyx","slug":"/api/matcher","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {InlineCode, Tag, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Matcher\"\n        }), \" lets you find words and phrases using rules describing their token\\nattributes. Rules can refer to token annotations (like the text or\\npart-of-speech tags), as well as lexical attributes like \", _jsx(InlineCode, {\n          children: \"Token.is_punct\"\n        }), \".\\nApplying the matcher to a \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" gives you access to the matched\\ntokens in context. For in-depth examples and workflows for combining rules and\\nstatistical models, see the \", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching\",\n          children: \"usage guide\"\n        }), \" on\\nrule-based matching.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"patterns\",\n        children: \"Pattern format \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            title: \"Example\",\n            children: \"[\\n  {\\\"LOWER\\\": \\\"i\\\"},\\n  {\\\"LEMMA\\\": {\\\"IN\\\": [\\\"like\\\", \\\"love\\\"]}},\\n  {\\\"POS\\\": \\\"NOUN\\\", \\\"OP\\\": \\\"+\\\"}\\n]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"A pattern added to the \", _jsx(InlineCode, {\n          children: \"Matcher\"\n        }), \" consists of a list of dictionaries. Each\\ndictionary describes \", _jsx(_components.strong, {\n          children: \"one token\"\n        }), \" and its attributes. The available token\\npattern keys correspond to a number of\\n\", _jsxs(_components.a, {\n          href: \"/api/token#attributes\",\n          children: [_jsx(InlineCode, {\n            children: \"Token\"\n          }), \" attributes\"]\n        }), \". The supported attributes for\\nrule-based matching are:\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Attribute\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ORTH\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The exact verbatim text of a token. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"TEXT\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The exact verbatim text of a token. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"NORM\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The normalized form of the token text. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"LOWER\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The lowercase form of the token text. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"LENGTH\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The length of the token text. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"IS_ALPHA\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_ASCII\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_DIGIT\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Token text consists of alphabetic characters, ASCII characters, digits. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"IS_LOWER\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_UPPER\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_TITLE\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Token text is in lowercase, uppercase, titlecase. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"IS_PUNCT\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_SPACE\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"IS_STOP\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Token is punctuation, whitespace, stop word. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"IS_SENT_START\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Token is start of sentence. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"LIKE_NUM\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"LIKE_URL\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"LIKE_EMAIL\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Token text resembles a number, URL, email. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"SPACY\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Token has a trailing space. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"POS\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"TAG\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"MORPH\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"DEP\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"LEMMA\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"SHAPE\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The token’s simple and extended part-of-speech tag, morphological analysis, dependency label, lemma, shape. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ENT_TYPE\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s entity label. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ENT_IOB\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The IOB part of the token’s entity tag. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ENT_ID\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s entity ID (\", _jsx(InlineCode, {\n                children: \"ent_id\"\n              }), \"). \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ENT_KB_ID\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token’s entity knowledge base ID (\", _jsx(InlineCode, {\n                children: \"ent_kb_id\"\n              }), \"). \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Properties in \", _jsx(_components.a, {\n                href: \"/usage/processing-pipelines#custom-components-attributes\",\n                children: \"custom extension attributes\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"OP\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Operator or quantifier to determine how often to match a token pattern. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"Operators and quantifiers define \", _jsx(_components.strong, {\n          children: \"how often\"\n        }), \" a token pattern should be\\nmatched:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            title: \"Example\",\n            children: \"[\\n  {\\\"POS\\\": \\\"ADJ\\\", \\\"OP\\\": \\\"*\\\"},\\n  {\\\"POS\\\": \\\"NOUN\\\", \\\"OP\\\": \\\"+\\\"}\\n  {\\\"POS\\\": \\\"PROPN\\\", \\\"OP\\\": \\\"{2}\\\"}\\n]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"OP\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"!\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Negate the pattern, by requiring it to match exactly 0 times.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"?\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Make the pattern optional, by allowing it to match 0 or 1 times.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"+\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Require the pattern to match 1 or more times.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"*\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Allow the pattern to match 0 or more times.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"{n}\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Require the pattern to match exactly \", _jsx(_components.em, {\n                children: \"n\"\n              }), \" times.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"{n,m}\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Require the pattern to match at least \", _jsx(_components.em, {\n                children: \"n\"\n              }), \" but not more than \", _jsx(_components.em, {\n                children: \"m\"\n              }), \" times.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"{n,}\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Require the pattern to match at least \", _jsx(_components.em, {\n                children: \"n\"\n              }), \" times.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"{,m}\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Require the pattern to match at most \", _jsx(_components.em, {\n                children: \"m\"\n              }), \" times.\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"Token patterns can also map to a \", _jsx(_components.strong, {\n          children: \"dictionary of properties\"\n        }), \" instead of a\\nsingle value to indicate whether the expected value is a member of a list or how\\nit compares to another value.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            title: \"Example\",\n            children: \"[\\n  {\\\"LEMMA\\\": {\\\"IN\\\": [\\\"like\\\", \\\"love\\\", \\\"enjoy\\\"]}},\\n  {\\\"POS\\\": \\\"PROPN\\\", \\\"LENGTH\\\": {\\\">=\\\": 10}},\\n]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Attribute\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"REGEX\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value matches the regular expression at any position in the string. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"FUZZY\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value matches if the \", _jsx(InlineCode, {\n                children: \"fuzzy_compare\"\n              }), \" method matches for \", _jsx(InlineCode, {\n                children: \"(value, pattern, -1)\"\n              }), \". The default method allows a Levenshtein edit distance of at least 2 and up to 30% of the pattern string length. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"FUZZY1\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"FUZZY2\"\n              }), \", … \", _jsx(InlineCode, {\n                children: \"FUZZY9\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value matches if the \", _jsx(InlineCode, {\n                children: \"fuzzy_compare\"\n              }), \" method matches for \", _jsx(InlineCode, {\n                children: \"(value, pattern, N)\"\n              }), \". The default method allows a Levenshtein edit distance of at most N (1-9). \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"IN\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value is member of a list. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"NOT_IN\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value is \", _jsx(_components.em, {\n                children: \"not\"\n              }), \" member of a list. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"IS_SUBSET\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value (for \", _jsx(InlineCode, {\n                children: \"MORPH\"\n              }), \" or custom list attributes) is a subset of a list. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"IS_SUPERSET\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value (for \", _jsx(InlineCode, {\n                children: \"MORPH\"\n              }), \" or custom list attributes) is a superset of a list. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"INTERSECTS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value (for \", _jsx(InlineCode, {\n                children: \"MORPH\"\n              }), \" or custom list attribute) has a non-empty intersection with a list. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"==\"\n              }), \", \", _jsx(InlineCode, {\n                children: \">=\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"<=\"\n              }), \", \", _jsx(InlineCode, {\n                children: \">\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"<\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Attribute value is equal, greater or equal, smaller or equal, greater or smaller. \", _jsx(_components.del, {\n                children: \"Union[int, float]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"As of spaCy v3.5, \", _jsx(InlineCode, {\n          children: \"REGEX\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"FUZZY\"\n        }), \" can be used in combination with \", _jsx(InlineCode, {\n          children: \"IN\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"NOT_IN\"\n        }), \".\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Matcher.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Create the rule-based \", _jsx(InlineCode, {\n          children: \"Matcher\"\n        }), \". If \", _jsx(InlineCode, {\n          children: \"validate=True\"\n        }), \" is set, all patterns added\\nto the matcher will be validated against a JSON schema and a \", _jsx(InlineCode, {\n          children: \"MatchPatternError\"\n        }), \"\\nis raised if problems are found. Those can include incorrect types (e.g. a\\nstring where an integer is expected) or unexpected property names.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import Matcher\\nmatcher = Matcher(nlp.vocab)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The vocabulary object, which must be shared with the documents the matcher will operate on. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Validate all patterns added to this matcher. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"fuzzy_compare\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The comparison method used for the \", _jsx(InlineCode, {\n                children: \"FUZZY\"\n              }), \" operators. \", _jsx(_components.del, {\n                children: \"Callable[[str, str, int], bool]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"Matcher.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Find all token sequences matching the supplied patterns on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \".\"]\n      }), _jsx(_components.p, {\n        children: \"Note that if a single label has multiple patterns associated with it, the\\nreturned matches don’t provide a way to tell which pattern was responsible for\\nthe match.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import Matcher\\n\\nmatcher = Matcher(nlp.vocab)\\npattern = [{\\\"LOWER\\\": \\\"hello\\\"}, {\\\"LOWER\\\": \\\"world\\\"}]\\nmatcher.add(\\\"HelloWorld\\\", [pattern])\\ndoc = nlp(\\\"hello world!\\\")\\nmatches = matcher(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doclike\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" to match over. \", _jsx(_components.del, {\n                children: \"Union[Doc, Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"as_spans\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Instead of tuples, return a list of \", _jsx(_components.a, {\n                href: \"/api/span\",\n                children: _jsx(InlineCode, {\n                  children: \"Span\"\n                })\n              }), \" objects of the matches, with the \", _jsx(InlineCode, {\n                children: \"match_id\"\n              }), \" assigned as the span label. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"allow_missing\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Whether to skip checks for missing annotation for attributes included in patterns. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"with_alignments\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.0.6\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Return match alignment information as part of the match tuple as \", _jsx(InlineCode, {\n                children: \"List[int]\"\n              }), \" with the same length as the matched span. Each entry denotes the corresponding index of the token in the pattern. If \", _jsx(InlineCode, {\n                children: \"as_spans\"\n              }), \" is set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", this setting is ignored. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of \", _jsx(InlineCode, {\n                children: \"(match_id, start, end)\"\n              }), \" tuples, describing the matches. A match tuple describes a span \", _jsx(InlineCode, {\n                children: \"doc[start:end\"\n              }), \"]. The \", _jsx(InlineCode, {\n                children: \"match_id\"\n              }), \" is the ID of the added match pattern. If \", _jsx(InlineCode, {\n                children: \"as_spans\"\n              }), \" is set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", a list of \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects is returned instead. \", _jsx(_components.del, {\n                children: \"Union[List[Tuple[int, int, int]], List[Span]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Matcher.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"Get the number of rules added to the matcher. Note that this only returns the\\nnumber of rules (identical with the number of IDs), not the number of individual\\npatterns.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher = Matcher(nlp.vocab)\\nassert len(matcher) == 0\\nmatcher.add(\\\"Rule\\\", [[{\\\"ORTH\\\": \\\"test\\\"}]])\\nassert len(matcher) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rules. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-contains\",\n      children: [_jsx(_components.h2, {\n        id: \"contains\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Matcher.__contains__ \"\n      }), _jsx(_components.p, {\n        children: \"Check whether the matcher contains rules for a match ID.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher = Matcher(nlp.vocab)\\nassert \\\"Rule\\\" not in matcher\\nmatcher.add(\\\"Rule\\\", [[{'ORTH': 'test'}]])\\nassert \\\"Rule\\\" in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The match ID. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the matcher contains rules for this match ID. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add\",\n      children: [_jsx(_components.h2, {\n        id: \"add\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Matcher.add \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a rule to the matcher, consisting of an ID key, one or more patterns, and an\\noptional callback function to act on the matches. The callback function will\\nreceive the arguments \", _jsx(InlineCode, {\n          children: \"matcher\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"i\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"matches\"\n        }), \". If a pattern already\\nexists for the given ID, the patterns will be extended. An \", _jsx(InlineCode, {\n          children: \"on_match\"\n        }), \" callback\\nwill be overwritten.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"def on_match(matcher, doc, id, matches):\\n    print('Matched!', matches)\\n\\nmatcher = Matcher(nlp.vocab)\\npatterns = [\\n   [{\\\"LOWER\\\": \\\"hello\\\"}, {\\\"LOWER\\\": \\\"world\\\"}],\\n   [{\\\"ORTH\\\": \\\"Google\\\"}, {\\\"ORTH\\\": \\\"Maps\\\"}]\\n]\\nmatcher.add(\\\"TEST_PATTERNS\\\", patterns, on_match=on_match)\\ndoc = nlp(\\\"HELLO WORLD on Google Maps.\\\")\\nmatches = matcher(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"As of spaCy v3.0, \", _jsx(InlineCode, {\n            children: \"Matcher.add\"\n          }), \" takes a list of patterns as the second argument\\n(instead of a variable number of arguments). The \", _jsx(InlineCode, {\n            children: \"on_match\"\n          }), \" callback becomes an\\noptional keyword argument.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"patterns = [[{\\\"TEXT\\\": \\\"Google\\\"}, {\\\"TEXT\\\": \\\"Now\\\"}], [{\\\"TEXT\\\": \\\"GoogleNow\\\"}]]\\n- matcher.add(\\\"GoogleNow\\\", on_match, *patterns)\\n+ matcher.add(\\\"GoogleNow\\\", patterns, on_match=on_match)\\n\"\n          })\n        })]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"match_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An ID for the thing you’re matching. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Match pattern. A pattern consists of a list of dicts, where each dict describes a token. \", _jsx(_components.del, {\n                children: \"List[List[Dict[str, Any]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"on_match\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Callback function to act on matches. Takes the arguments \", _jsx(InlineCode, {\n                children: \"matcher\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"doc\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"i\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"matches\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Matcher, Doc, int, List[tuple], Any]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"greedy\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Optional filter for greedy matches. Can either be \", _jsx(InlineCode, {\n                children: \"\\\"FIRST\\\"\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"\\\"LONGEST\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[str]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove\",\n      children: [_jsx(_components.h2, {\n        id: \"remove\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Matcher.remove \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove a rule from the matcher. A \", _jsx(InlineCode, {\n          children: \"KeyError\"\n        }), \" is raised if the match ID does not\\nexist.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher.add(\\\"Rule\\\", [[{\\\"ORTH\\\": \\\"test\\\"}]])\\nassert \\\"Rule\\\" in matcher\\nmatcher.remove(\\\"Rule\\\")\\nassert \\\"Rule\\\" not in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the match rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get\",\n      children: [_jsx(_components.h2, {\n        id: \"get\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Matcher.get \"\n      }), _jsxs(_components.p, {\n        children: [\"Retrieve the pattern stored for a key. Returns the rule as an\\n\", _jsx(InlineCode, {\n          children: \"(on_match, patterns)\"\n        }), \" tuple containing the callback and available patterns.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher.add(\\\"Rule\\\", [[{\\\"ORTH\\\": \\\"test\\\"}]])\\non_match, patterns = matcher.get(\\\"Rule\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the match rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The rule, as an \", _jsx(InlineCode, {\n                children: \"(on_match, patterns)\"\n              }), \" tuple. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Callable], List[List[dict]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Matcher","teaser":"Match sequences of tokens, based on pattern rules","tag":"class","source":"spacy/matcher/matcher.pyx"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}