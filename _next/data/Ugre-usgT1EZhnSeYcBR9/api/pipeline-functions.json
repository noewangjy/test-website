{"pageProps":{"title":"Pipeline Functions","teaser":"Other built-in pipeline components and helpers","source":"spacy/pipeline/functions.py","menu":[["merge_noun_chunks","merge_noun_chunks"],["merge_entities","merge_entities"],["merge_subtokens","merge_subtokens"],["token_splitter","token_splitter"],["doc_cleaner","doc_cleaner"]],"slug":"/api/pipeline-functions","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    strong: \"strong\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-merge_noun_chunks\",\n      children: [_jsx(_components.h2, {\n        id: \"merge_noun_chunks\",\n        tag: \"function\",\n        children: \"merge_noun_chunks \"\n      }), _jsxs(_components.p, {\n        children: [\"Merge noun chunks into a single token. Also available via the string name\\n\", _jsx(InlineCode, {\n          children: \"\\\"merge_noun_chunks\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"texts = [t.text for t in nlp(\\\"I have a blue car\\\")]\\nassert texts == [\\\"I\\\", \\\"have\\\", \\\"a\\\", \\\"blue\\\", \\\"car\\\"]\\n\\nnlp.add_pipe(\\\"merge_noun_chunks\\\")\\ntexts = [t.text for t in nlp(\\\"I have a blue car\\\")]\\nassert texts == [\\\"I\\\", \\\"have\\\", \\\"a blue car\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Since noun chunks require part-of-speech tags and the dependency parse, make\\nsure to add this component \", _jsx(_components.em, {\n            children: \"after\"\n          }), \" the \", _jsx(InlineCode, {\n            children: \"\\\"tagger\\\"\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"\\\"parser\\\"\"\n          }), \" components. By\\ndefault, \", _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          }), \" will add components to the end of the pipeline and after\\nall other components.\"]\n        })\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to process, e.g. the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with merged noun chunks. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-merge_entities\",\n      children: [_jsx(_components.h2, {\n        id: \"merge_entities\",\n        tag: \"function\",\n        children: \"merge_entities \"\n      }), _jsxs(_components.p, {\n        children: [\"Merge named entities into a single token. Also available via the string name\\n\", _jsx(InlineCode, {\n          children: \"\\\"merge_entities\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"texts = [t.text for t in nlp(\\\"I like David Bowie\\\")]\\nassert texts == [\\\"I\\\", \\\"like\\\", \\\"David\\\", \\\"Bowie\\\"]\\n\\nnlp.add_pipe(\\\"merge_entities\\\")\\n\\ntexts = [t.text for t in nlp(\\\"I like David Bowie\\\")]\\nassert texts == [\\\"I\\\", \\\"like\\\", \\\"David Bowie\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Since named entities are set by the entity recognizer, make sure to add this\\ncomponent \", _jsx(_components.em, {\n            children: \"after\"\n          }), \" the \", _jsx(InlineCode, {\n            children: \"\\\"ner\\\"\"\n          }), \" component. By default, \", _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          }), \" will add\\ncomponents to the end of the pipeline and after all other components.\"]\n        })\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to process, e.g. the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with merged entities. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-merge_subtokens\",\n      children: [_jsx(_components.h2, {\n        id: \"merge_subtokens\",\n        tag: \"function\",\n        version: \"2.1\",\n        children: \"merge_subtokens \"\n      }), _jsxs(_components.p, {\n        children: [\"Merge subtokens into a single token. Also available via the string name\\n\", _jsx(InlineCode, {\n          children: \"\\\"merge_subtokens\\\"\"\n        }), \". As of v2.1, the parser is able to predict “subtokens” that\\nshould be merged into one single token later on. This is especially relevant for\\nlanguages like Chinese, Japanese or Korean, where a “word” isn’t defined as a\\nwhitespace-delimited sequence of characters. Under the hood, this component uses\\nthe \", _jsx(_components.a, {\n          href: \"/api/matcher\",\n          children: _jsx(InlineCode, {\n            children: \"Matcher\"\n          })\n        }), \" to find sequences of tokens with the dependency\\nlabel \", _jsx(InlineCode, {\n          children: \"\\\"subtok\\\"\"\n        }), \" and then merges them into a single token.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"Note that this example assumes a custom Chinese model that oversegments and\\nwas trained to predict subtokens.\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"拜托\\\")\\nprint([(token.text, token.dep_) for token in doc])\\n# [('拜', 'subtok'), ('托', 'subtok')]\\n\\nnlp.add_pipe(\\\"merge_subtokens\\\")\\ndoc = nlp(\\\"拜托\\\")\\nprint([token.text for token in doc])\\n# ['拜托']\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Since subtokens are set by the parser, make sure to add this component \", _jsx(_components.em, {\n            children: \"after\"\n          }), \"\\nthe \", _jsx(InlineCode, {\n            children: \"\\\"parser\\\"\"\n          }), \" component. By default, \", _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          }), \" will add components to the\\nend of the pipeline and after all other components.\"]\n        })\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to process, e.g. the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The subtoken dependency label. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"subtok\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with merged subtokens. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-token_splitter\",\n      children: [_jsx(_components.h2, {\n        id: \"token_splitter\",\n        tag: \"function\",\n        version: \"3.0\",\n        children: \"token_splitter \"\n      }), _jsx(_components.p, {\n        children: \"Split tokens longer than a minimum length into shorter tokens. Intended for use\\nwith transformer pipelines where long spaCy tokens lead to input text that\\nexceed the transformer model max length.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\\"min_length\\\": 20, \\\"split_length\\\": 5}\\nnlp.add_pipe(\\\"token_splitter\\\", config=config, first=True)\\ndoc = nlp(\\\"aaaaabbbbbcccccdddddee\\\")\\nprint([token.text for token in doc])\\n# ['aaaaa', 'bbbbb', 'ccccc', 'ddddd', 'ee']\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"min_length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The minimum length for a token to be split. Defaults to \", _jsx(InlineCode, {\n                children: \"25\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"split_length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The length of the split tokens. Defaults to \", _jsx(InlineCode, {\n                children: \"5\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with the split tokens. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-doc_cleaner\",\n      children: [_jsx(_components.h2, {\n        id: \"doc_cleaner\",\n        tag: \"function\",\n        version: \"3.2.1\",\n        children: \"doc_cleaner \"\n      }), _jsxs(_components.p, {\n        children: [\"Clean up \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" attributes. Intended for use at the end of pipelines with\\n\", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"transformer\"\n        }), \" pipeline components that store tensors and other\\nvalues that can require a lot of memory and frequently aren’t needed after the\\nwhole pipeline has run.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\\"attrs\\\": {\\\"tensor\\\": None}}\\nnlp.add_pipe(\\\"doc_cleaner\\\", config=config)\\ndoc = nlp(\\\"text\\\")\\nassert doc.tensor is None\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dict of the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" attributes and the values to set them to. Defaults to \", _jsx(InlineCode, {\n                children: \"{\\\"tensor\\\": None, \\\"_.trf_data\\\": None}\"\n              }), \" to clean up after \", _jsx(InlineCode, {\n                children: \"tok2vec\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"transformer\"\n              }), \" components. \", _jsx(_components.del, {\n                children: \"dict\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"silent\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \", show warnings if attributes aren’t found or can’t be set. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with the modified attributes. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-span_cleaner\",\n      children: [_jsx(_components.h2, {\n        id: \"span_cleaner\",\n        tag: \"function,experimental\",\n        children: \"span_cleaner \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove \", _jsx(InlineCode, {\n          children: \"SpanGroup\"\n        }), \"s from \", _jsx(InlineCode, {\n          children: \"doc.spans\"\n        }), \" based on a key prefix. This is used to\\nclean up after the \", _jsx(_components.a, {\n          href: \"/api/coref\",\n          children: _jsx(InlineCode, {\n            children: \"CoreferenceResolver\"\n          })\n        }), \" when it’s paired with a\\n\", _jsx(_components.a, {\n          href: \"/api/span-resolver\",\n          children: _jsx(InlineCode, {\n            children: \"SpanResolver\"\n          })\n        }), \".\"]\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"This pipeline function is not yet integrated into spaCy core, and is available\\nvia the extension package\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-experimental\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-experimental\"\n            })\n          }), \" starting\\nin version 0.6.0. It exposes the component via\\n\", _jsx(_components.a, {\n            href: \"/usage/saving-loading/#entry-points\",\n            children: \"entry points\"\n          }), \", so if you have the package\\ninstalled, using \", _jsx(InlineCode, {\n            children: \"factory = \\\"span_cleaner\\\"\"\n          }), \" in your\\n\", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"training config\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"nlp.add_pipe(\\\"span_cleaner\\\")\"\n          }), \" will\\nwork out-of-the-box.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\\"prefix\\\": \\\"coref_head_clusters\\\"}\\nnlp.add_pipe(\\\"span_cleaner\\\", config=config)\\ndoc = nlp(\\\"text\\\")\\nassert \\\"coref_head_clusters_1\\\" not in doc.spans\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A prefix to check \", _jsx(InlineCode, {\n                children: \"SpanGroup\"\n              }), \" keys for. Any matching groups will be removed. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"coref_head_clusters\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with any matching spans removed. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Pipeline Functions","teaser":"Other built-in pipeline components and helpers","source":"spacy/pipeline/functions.py","menu":[["merge_noun_chunks","merge_noun_chunks"],["merge_entities","merge_entities"],["merge_subtokens","merge_subtokens"],["token_splitter","token_splitter"],["doc_cleaner","doc_cleaner"]]},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}