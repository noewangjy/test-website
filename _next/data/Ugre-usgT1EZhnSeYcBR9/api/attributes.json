{"pageProps":{"title":"Attributes","teaser":"Token attributes","source":"spacy/attrs.pyx","slug":"/api/attributes","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\"\n  }, _provideComponents(), props.components), {InlineCode} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/api/token\",\n        children: \"Token\"\n      }), \" attributes are specified using internal IDs in many places\\nincluding:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsxs(_components.a, {\n          href: \"/api/matcher#patterns\",\n          children: [_jsx(InlineCode, {\n            children: \"Matcher\"\n          }), \" patterns\"]\n        }), \",\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/api/doc#to_array\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.to_array\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/doc#from_array\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.from_array\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/api/doc#has_annotation\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.has_annotation\"\n          })\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/api/architectures#MultiHashEmbed\",\n          children: _jsx(InlineCode, {\n            children: \"MultiHashEmbed\"\n          })\n        }), \" Tok2Vec architecture\\n\", _jsx(InlineCode, {\n          children: \"attrs\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"import spacy\\nfrom spacy.attrs import DEP\\n\\nnlp = spacy.blank(\\\"en\\\")\\ndoc = nlp(\\\"There are many attributes.\\\")\\n\\n# DEP always has the same internal value\\nassert DEP == 76\\n\\n# \\\"DEP\\\" is automatically converted to DEP\\nassert DEP == nlp.vocab.strings[\\\"DEP\\\"]\\nassert doc.has_annotation(DEP) == doc.has_annotation(\\\"DEP\\\")\\n\\n# look up IDs in spacy.attrs.IDS\\nfrom spacy.attrs import IDS\\nassert IDS[\\\"DEP\\\"] == DEP\\n\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All methods automatically convert between the string version of an ID (\", _jsx(InlineCode, {\n        children: \"\\\"DEP\\\"\"\n      }), \")\\nand the internal integer symbols (\", _jsx(InlineCode, {\n        children: \"DEP\"\n      }), \"). The internal IDs can be imported from\\n\", _jsx(InlineCode, {\n        children: \"spacy.attrs\"\n      }), \" or retrieved from the \", _jsx(_components.a, {\n        href: \"/api/stringstore\",\n        children: _jsx(InlineCode, {\n          children: \"StringStore\"\n        })\n      }), \". A map\\nfrom string attribute names to internal attribute IDs is stored in\\n\", _jsx(InlineCode, {\n        children: \"spacy.attrs.IDS\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The corresponding \", _jsxs(_components.a, {\n        href: \"/api/token#attributes\",\n        children: [_jsx(InlineCode, {\n          children: \"Token\"\n        }), \" object attributes\"]\n      }), \" can be\\naccessed using the same names in lowercase, e.g. \", _jsx(InlineCode, {\n        children: \"token.orth\"\n      }), \" or \", _jsx(InlineCode, {\n        children: \"token.length\"\n      }), \".\\nFor attributes that represent string values, the internal integer ID is accessed\\nas \", _jsx(InlineCode, {\n        children: \"Token.attr\"\n      }), \", e.g. \", _jsx(InlineCode, {\n        children: \"token.dep\"\n      }), \", while the string value can be retrieved by\\nappending \", _jsx(InlineCode, {\n        children: \"_\"\n      }), \" as in \", _jsx(InlineCode, {\n        children: \"token.dep_\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Attribute\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"DEP\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s dependency label. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"ENT_ID\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s entity ID (\", _jsx(InlineCode, {\n              children: \"ent_id\"\n            }), \"). \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"ENT_IOB\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The IOB part of the token’s entity tag. Uses custom integer vaues rather than the string store: unset is \", _jsx(InlineCode, {\n              children: \"0\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"I\"\n            }), \" is \", _jsx(InlineCode, {\n              children: \"1\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"O\"\n            }), \" is \", _jsx(InlineCode, {\n              children: \"2\"\n            }), \", and \", _jsx(InlineCode, {\n              children: \"B\"\n            }), \" is \", _jsx(InlineCode, {\n              children: \"3\"\n            }), \". \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"ENT_KB_ID\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s entity knowledge base ID. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"ENT_TYPE\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s entity label. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_ALPHA\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text consists of alphabetic characters. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_ASCII\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text consists of ASCII characters. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_DIGIT\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text consists of digits. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_LOWER\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text is in lowercase. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_PUNCT\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token is punctuation. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_SPACE\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token is whitespace. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_STOP\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token is a stop word. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_TITLE\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text is in titlecase. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"IS_UPPER\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text is in uppercase. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LEMMA\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s lemma. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LENGTH\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The length of the token text. \", _jsx(_components.del, {\n              children: \"int\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LIKE_EMAIL\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text resembles an email address. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LIKE_NUM\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text resembles a number. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LIKE_URL\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token text resembles a URL. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"LOWER\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The lowercase form of the token text. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"MORPH\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s morphological analysis. \", _jsx(_components.del, {\n              children: \"MorphAnalysis\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"NORM\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The normalized form of the token text. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"ORTH\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The exact verbatim text of a token. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"POS\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s universal part of speech (UPOS). \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"SENT_START\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token is start of sentence. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"SHAPE\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s shape. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"SPACY\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Token has a trailing space. \", _jsx(_components.del, {\n              children: \"bool\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(InlineCode, {\n              children: \"TAG\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"The token’s fine-grained part of speech. \", _jsx(_components.del, {\n              children: \"str\"\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Attributes","teaser":"Token attributes","source":"spacy/attrs.pyx"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}