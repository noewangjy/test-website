{"pageProps":{"title":"Scorer","teaser":"Compute evaluation scores","tag":"class","source":"spacy/scorer.py","slug":"/api/scorer","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Scorer\"\n        }), \" computes evaluation scores. It’s typically created by\\n\", _jsx(_components.a, {\n          href: \"/api/language#evaluate\",\n          children: _jsx(InlineCode, {\n            children: \"Language.evaluate\"\n          })\n        }), \". In addition, the \", _jsx(InlineCode, {\n          children: \"Scorer\"\n        }), \"\\nprovides a number of evaluation methods for evaluating \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" attributes.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Scorer.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Create a new \", _jsx(InlineCode, {\n          children: \"Scorer\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.scorer import Scorer\\n\\n# Default scoring pipeline\\nscorer = Scorer()\\n\\n# Provided scoring pipeline\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nscorer = Scorer(nlp)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The pipeline to use for scoring, where each pipeline component may provide a scoring method. If none is provided, then a default pipeline is constructed using the \", _jsx(InlineCode, {\n                children: \"default_lang\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"default_pipeline\"\n              }), \" settings. \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"default_lang\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The language to use for a default pipeline if \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" is not provided. Defaults to \", _jsx(InlineCode, {\n                children: \"xx\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"default_pipeline\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The pipeline components to use for a default pipeline if \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" is not provided. Defaults to \", _jsx(InlineCode, {\n                children: \"(\\\"senter\\\", \\\"tagger\\\", \\\"morphologizer\\\", \\\"parser\\\", \\\"ner\\\", \\\"textcat\\\")\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[string]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"\\\\*\\\\*kwargs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Any additional settings to pass on to the individual scoring methods. \", _jsx(_components.del, {\n                children: \"Any\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score\",\n      children: [_jsx(_components.h2, {\n        id: \"score\",\n        tag: \"method\",\n        children: \"Scorer.score \"\n      }), _jsxs(_components.p, {\n        children: [\"Calculate the scores for a list of \", _jsx(_components.a, {\n          href: \"/api/example\",\n          children: _jsx(InlineCode, {\n            children: \"Example\"\n          })\n        }), \" objects using the\\nscoring methods provided by the components in the pipeline.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The returned \", _jsx(InlineCode, {\n          children: \"Dict\"\n        }), \" contains the scores provided by the individual pipeline\\ncomponents. For the scoring methods provided by the \", _jsx(InlineCode, {\n          children: \"Scorer\"\n        }), \" and used by the\\ncore pipeline components, the individual score names start with the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" or\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" attribute being scored:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"token_acc\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"token_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"token_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"token_f\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"sents_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"sents_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"sents_f\"\n          })]\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(InlineCode, {\n            children: \"tag_acc\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(InlineCode, {\n            children: \"pos_acc\"\n          })\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"morph_acc\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"morph_micro_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"morph_micro_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"morph_micro_f\"\n          }), \",\\n\", _jsx(InlineCode, {\n            children: \"morph_per_feat\"\n          })]\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(InlineCode, {\n            children: \"lemma_acc\"\n          })\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"dep_uas\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"dep_las\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"dep_las_per_type\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"ents_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"ents_r\"\n          }), \" \", _jsx(InlineCode, {\n            children: \"ents_f\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"ents_per_type\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"spans_sc_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"spans_sc_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"spans_sc_f\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"cats_score\"\n          }), \" (depends on config, description provided in \", _jsx(InlineCode, {\n            children: \"cats_score_desc\"\n          }), \"),\\n\", _jsx(InlineCode, {\n            children: \"cats_micro_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_micro_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_micro_f\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_macro_p\"\n          }), \",\\n\", _jsx(InlineCode, {\n            children: \"cats_macro_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_macro_f\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_macro_auc\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"cats_f_per_type\"\n          }), \",\\n\", _jsx(InlineCode, {\n            children: \"cats_auc_per_type\"\n          })]\n        }), \"\\n\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scorer = Scorer()\\nscores = scorer.score(examples)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary of scores. \", _jsx(_components.del, {\n                children: \"Dict[str, Union[float, Dict[str, float]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_tokenization\",\n      children: [_jsx(_components.h2, {\n        id: \"score_tokenization\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_tokenization \"\n      }), _jsx(_components.p, {\n        children: \"Scores the tokenization:\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"token_acc\"\n          }), \": number of correct tokens / number of predicted tokens\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"token_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"token_r\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"token_f\"\n          }), \": precision, recall and F-score for token\\ncharacter spans\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Docs with \", _jsx(InlineCode, {\n          children: \"has_unknown_spaces\"\n        }), \" are skipped during scoring.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = Scorer.score_tokenization(examples)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"| Name        | Description                                                                                                         |\\n| ----------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\\n| \", _jsx(InlineCode, {\n          children: \"examples\"\n        }), \"  | The \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n          children: \"Iterable[Example]\"\n        }), \" |\\n| \", _jsx(_components.strong, {\n          children: \"RETURNS\"\n        }), \" | \", _jsx(InlineCode, {\n          children: \"Dict\"\n        }), \"                                                                                                              | A dictionary containing the scores \", _jsx(InlineCode, {\n          children: \"token_acc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"token_p\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"token_r\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"token_f\"\n        }), \". \", _jsx(_components.del, {\n          children: \"Dict[str, float]]\"\n        }), \" |\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_token_attr\",\n      children: [_jsx(_components.h2, {\n        id: \"score_token_attr\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_token_attr \"\n      }), _jsx(_components.p, {\n        children: \"Scores a single token attribute. Tokens with missing values in the reference doc\\nare skipped during scoring.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = Scorer.score_token_attr(examples, \\\"pos\\\")\\nprint(scores[\\\"pos_acc\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute to score. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"getter(token, attr)\"\n              }), \" should return the value of the attribute for an individual \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Token, str], Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"missing_values\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute values to treat as missing annotation in the reference annotation. Defaults to \", _jsx(InlineCode, {\n                children: \"{0, None, \\\"\\\"}\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Set[Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the score \", _jsx(InlineCode, {\n                children: \"{attr}_acc\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_token_attr_per_feat\",\n      children: [_jsx(_components.h2, {\n        id: \"score_token_attr_per_feat\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_token_attr_per_feat \"\n      }), _jsxs(_components.p, {\n        children: [\"Scores a single token attribute per feature for a token attribute in the\\nUniversal Dependencies\\n\", _jsx(_components.a, {\n          href: \"https://universaldependencies.org/format.html#morphological-annotation\",\n          children: \"FEATS\"\n        }), \"\\nformat. Tokens with missing values in the reference doc are skipped during\\nscoring.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = Scorer.score_token_attr_per_feat(examples, \\\"morph\\\")\\nprint(scores[\\\"morph_per_feat\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute to score. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"getter(token, attr)\"\n              }), \" should return the value of the attribute for an individual \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Token, str], Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"missing_values\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute values to treat as missing annotation in the reference annotation. Defaults to \", _jsx(InlineCode, {\n                children: \"{0, None, \\\"\\\"}\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Set[Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the micro PRF scores under the key \", _jsx(InlineCode, {\n                children: \"{attr}_micro_p/r/f\"\n              }), \" and the per-feature PRF scores under \", _jsx(InlineCode, {\n                children: \"{attr}_per_feat\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Dict[str, float]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_spans\",\n      children: [_jsx(_components.h2, {\n        id: \"score_spans\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_spans \"\n      }), _jsx(_components.p, {\n        children: \"Returns PRF scores for labeled or unlabeled spans.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = Scorer.score_spans(examples, \\\"ents\\\")\\nprint(scores[\\\"ents_f\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute to score. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"getter(doc, attr)\"\n              }), \" should return the \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects for an individual \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Doc, str], Iterable[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"has_annotation\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"has_annotation(doc)\"\n              }), \" should return whether a \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" has annotation for this \", _jsx(InlineCode, {\n                children: \"attr\"\n              }), \". Docs without annotation are skipped for scoring purposes. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"labeled\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". If set to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \", two spans will be considered equal if their start and end match, irrespective of their label. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"allow_overlap\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". Whether or not to allow overlapping spans. If set to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \", the alignment will automatically resolve conflicts. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the PRF scores under the keys \", _jsx(InlineCode, {\n                children: \"{attr}_p\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"{attr}_r\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"{attr}_f\"\n              }), \" and the per-type PRF scores under \", _jsx(InlineCode, {\n                children: \"{attr}_per_type\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Union[float, Dict[str, float]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_deps\",\n      children: [_jsx(_components.h2, {\n        id: \"score_deps\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_deps \"\n      }), _jsxs(_components.p, {\n        children: [\"Calculate the UAS, LAS, and LAS per type scores for dependency parses. Tokens\\nwith missing values for the \", _jsx(InlineCode, {\n          children: \"attr\"\n        }), \" (typically \", _jsx(InlineCode, {\n          children: \"dep\"\n        }), \") are skipped during scoring.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"def dep_getter(token, attr):\\n    dep = getattr(token, attr)\\n    dep = token.vocab.strings.as_string(dep).lower()\\n    return dep\\n\\nscores = Scorer.score_deps(\\n    examples,\\n    \\\"dep\\\",\\n    getter=dep_getter,\\n    ignore_labels=(\\\"p\\\", \\\"punct\\\")\\n)\\nprint(scores[\\\"dep_uas\\\"], scores[\\\"dep_las\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute to score. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"getter(token, attr)\"\n              }), \" should return the value of the attribute for an individual \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Token, str], Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"head_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute containing the head token. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"head_getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"head_getter(token, attr)\"\n              }), \" should return the head for an individual \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Doc, str], Token]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ignore_labels\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Labels to ignore while scoring (e.g. \", _jsx(InlineCode, {\n                children: \"\\\"punct\\\"\"\n              }), \"). \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"missing_values\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute values to treat as missing annotation in the reference annotation. Defaults to \", _jsx(InlineCode, {\n                children: \"{0, None, \\\"\\\"}\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Set[Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the scores: \", _jsx(InlineCode, {\n                children: \"{attr}_uas\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"{attr}_las\"\n              }), \", and \", _jsx(InlineCode, {\n                children: \"{attr}_las_per_type\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Union[float, Dict[str, float]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_cats\",\n      children: [_jsx(_components.h2, {\n        id: \"score_cats\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_cats \"\n      }), _jsxs(_components.p, {\n        children: [\"Calculate PRF and ROC AUC scores for a doc-level attribute that is a dict\\ncontaining scores for each label like \", _jsx(InlineCode, {\n          children: \"Doc.cats\"\n        }), \". The returned dictionary\\ncontains the following scores:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"{attr}_micro_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"{attr}_micro_r\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"{attr}_micro_f\"\n          }), \": each instance across\\neach label is weighted equally\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"{attr}_macro_p\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"{attr}_macro_r\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"{attr}_macro_f\"\n          }), \": the average values\\nacross evaluations per label\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"{attr}_f_per_type\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"{attr}_auc_per_type\"\n          }), \": each contains a dictionary of\\nscores, keyed by label\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"A final \", _jsx(InlineCode, {\n            children: \"{attr}_score\"\n          }), \" and corresponding \", _jsx(InlineCode, {\n            children: \"{attr}_score_desc\"\n          }), \" (text\\ndescription)\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The reported \", _jsx(InlineCode, {\n          children: \"{attr}_score\"\n        }), \" depends on the classification properties:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"binary exclusive with positive label:\"\n          }), \" \", _jsx(InlineCode, {\n            children: \"{attr}_score\"\n          }), \" is set to the F-score\\nof the positive label\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"3+ exclusive classes\"\n          }), \", macro-averaged F-score:\\n\", _jsx(InlineCode, {\n            children: \"{attr}_score = {attr}_macro_f\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"multilabel\"\n          }), \", macro-averaged AUC: \", _jsx(InlineCode, {\n            children: \"{attr}_score = {attr}_macro_auc\"\n          })]\n        }), \"\\n\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"labels = [\\\"LABEL_A\\\", \\\"LABEL_B\\\", \\\"LABEL_C\\\"]\\nscores = Scorer.score_cats(\\n    examples,\\n    \\\"cats\\\",\\n    labels=labels\\n)\\nprint(scores[\\\"cats_macro_auc\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute to score. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"getattr\"\n              }), \". If provided, \", _jsx(InlineCode, {\n                children: \"getter(doc, attr)\"\n              }), \" should return the cats for an individual \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Doc, str], Dict[str, float]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"labels\"\n            }), _jsxs(_components.td, {\n              children: [\"The set of possible labels. Defaults to \", _jsx(InlineCode, {\n                children: \"[]\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"multi_label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the attribute allows multiple labels. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". When set to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" (exclusive labels), missing gold labels are interpreted as \", _jsx(InlineCode, {\n                children: \"0.0\"\n              }), \" and the threshold is set to \", _jsx(InlineCode, {\n                children: \"0.0\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"positive_label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The positive label for a binary task with exclusive classes. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"threshold\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Cutoff to consider a prediction “positive”. Defaults to \", _jsx(InlineCode, {\n                children: \"0.5\"\n              }), \" for multi-label, and \", _jsx(InlineCode, {\n                children: \"0.0\"\n              }), \" (i.e. whatever’s highest scoring) otherwise. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the scores, with inapplicable scores as \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Optional[float]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_links\",\n      children: [_jsx(_components.h2, {\n        id: \"score_links\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Scorer.score_links \"\n      }), _jsx(_components.p, {\n        children: \"Returns PRF for predicted links on the entity level. To disentangle the\\nperformance of the NEL from the NER, this method only evaluates NEL links for\\nentities that overlap between the gold reference and the predictions.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = Scorer.score_links(\\n    examples,\\n    negative_labels=[\\\"NIL\\\", \\\"\\\"]\\n)\\nprint(scores[\\\"nel_micro_f\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"negative_labels\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string values that refer to no annotation (e.g. “NIL”). \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the scores. \", _jsx(_components.del, {\n                children: \"Dict[str, Optional[float]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_ner_prf\",\n      children: [_jsx(_components.h2, {\n        id: \"get_ner_prf\",\n        version: \"3\",\n        children: \"get_ner_prf \"\n      }), _jsx(_components.p, {\n        children: \"Compute micro-PRF and per-entity PRF scores.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_coref_clusters\",\n      children: [_jsx(_components.h2, {\n        id: \"score_coref_clusters\",\n        tag: \"experimental\",\n        children: \"score_coref_clusters \"\n      }), _jsxs(_components.p, {\n        children: [\"Returns LEA (\", _jsx(_components.a, {\n          href: \"https://aclanthology.org/P16-1060/\",\n          children: \"Moosavi and Strube, 2016\"\n        }), \") PRF\\nscores for coreference clusters.\"]\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Note this scoring function is not yet included in spaCy core - for details, see\\nthe \", _jsx(_components.a, {\n            href: \"/api/coref\",\n            children: \"CoreferenceResolver\"\n          }), \" docs.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = score_coref_clusters(\\n    examples,\\n    span_cluster_prefix=\\\"coref_clusters\\\",\\n)\\nprint(scores[\\\"coref_f\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"span_cluster_prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The prefix used for spans representing coreference clusters. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the scores. \", _jsx(_components.del, {\n                children: \"Dict[str, Optional[float]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-score_span_predictions\",\n      children: [_jsx(_components.h2, {\n        id: \"score_span_predictions\",\n        tag: \"experimental\",\n        children: \"score_span_predictions \"\n      }), _jsxs(_components.p, {\n        children: [\"Return accuracy for reconstructions of spans from single tokens. Only exactly\\ncorrect predictions are counted as correct, there is no partial credit for near\\nanswers. Used by the \", _jsx(_components.a, {\n          href: \"/api/span-resolver\",\n          children: \"SpanResolver\"\n        }), \".\"]\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Note this scoring function is not yet included in spaCy core - for details, see\\nthe \", _jsx(_components.a, {\n            href: \"/api/span-resolver\",\n            children: \"SpanResolver\"\n          }), \" docs.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"scores = score_span_predictions(\\n    examples,\\n    output_prefix=\\\"coref_clusters\\\",\\n)\\nprint(scores[\\\"span_coref_clusters_accuracy\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects holding both the predictions and the correct gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"output_prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The prefix used for spans representing the final predicted spans. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary containing the scores. \", _jsx(_components.del, {\n                children: \"Dict[str, Optional[float]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Scorer","teaser":"Compute evaluation scores","tag":"class","source":"spacy/scorer.py"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}