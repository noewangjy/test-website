{"pageProps":{"title":"Tagger","tag":"class","source":"spacy/pipeline/tagger.pyx","teaser":"Pipeline component for part-of-speech tagging","api_base_class":"/api/pipe","api_string_name":"tagger","api_trainable":true,"slug":"/api/tagger","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Tag, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsx(_components.p, {\n        children: \"A trainable pipeline component to predict part-of-speech tags for any\\npart-of-speech tag set.\"\n      }), _jsxs(_components.p, {\n        children: [\"In the pre-trained pipelines, the tag schemas vary by language; see the\\n\", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"individual model pages\"\n        }), \" for details.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-assigned-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"assigned-attributes\",\n        children: \"Assigned Attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"Predictions are assigned to \", _jsx(InlineCode, {\n          children: \"Token.tag\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Location\"\n            }), _jsx(_components.th, {\n              children: \"Value\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.tag\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The part of speech (hash). \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.tag_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The part of speech. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-config\",\n      children: [_jsx(_components.h2, {\n        id: \"config\",\n        children: \"Config and implementation \"\n      }), _jsxs(_components.p, {\n        children: [\"The default config is defined by the pipeline component factory and describes\\nhow the component should be configured. You can override its settings via the\\n\", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" or in your\\n\", _jsxs(_components.a, {\n          href: \"/usage/training#config\",\n          children: [_jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" for training\"]\n        }), \". See the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures\",\n          children: \"model architectures\"\n        }), \" documentation for details on the\\narchitectures and their arguments and hyperparameters.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.pipeline.tagger import DEFAULT_TAGGER_MODEL\\nconfig = {\\\"model\\\": DEFAULT_TAGGER_MODEL}\\nnlp.add_pipe(\\\"tagger\\\", config=config)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A model instance that predicts the tag probabilities. The output vectors should match the number of tags in size, and be normalized as probabilities (all scores between 0 and 1, with the rows summing to \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \"). Defaults to \", _jsx(_components.a, {\n                href: \"/api/architectures#Tagger\",\n                children: \"Tagger\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"overwrite\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.2\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Whether existing annotation is overwritten. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"scorer\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.2\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_token_attr\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_token_attr\"\n                })\n              }), \" for the attribute \", _jsx(InlineCode, {\n                children: \"\\\"tag\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"neg_prefix\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.2.1\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The prefix used to specify incorrect tags while training. The tagger will learn not to predict exactly this tag. Defaults to \", _jsx(InlineCode, {\n                children: \"!\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/tagger.pyx\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/tagger.pyx\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Tagger.__init__ \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction via add_pipe with default model\\ntagger = nlp.add_pipe(\\\"tagger\\\")\\n\\n# Construction via create_pipe with custom model\\nconfig = {\\\"model\\\": {\\\"@architectures\\\": \\\"my_tagger\\\"}}\\ntagger = nlp.add_pipe(\\\"tagger\\\", config=config)\\n\\n# Construction from class\\nfrom spacy.pipeline import Tagger\\ntagger = Tagger(nlp.vocab, model)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Create a new pipeline instance. In your application, you would normally use a\\nshortcut for this and instantiate the component using its string name and\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared vocabulary. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A model instance that predicts the tag probabilities. The output vectors should match the number of tags in size, and be normalized as probabilities (all scores between 0 and 1, with the rows summing to \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \"). \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name of the component instance. Used to add entries to the \", _jsx(InlineCode, {\n                children: \"losses\"\n              }), \" during training. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"overwrite\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.2\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Whether existing annotation is overwritten. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"scorer\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.2\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_token_attr\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_token_attr\"\n                })\n              }), \" for the attribute \", _jsx(InlineCode, {\n                children: \"\\\"tag\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"Tagger.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the pipe to one document. The document is modified in place, and returned.\\nThis usually happens under the hood when the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is called on a text\\nand all pipeline components are applied to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in order. Both\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#call\",\n          children: _jsx(InlineCode, {\n            children: \"__call__\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/tagger#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"pipe\"\n          })\n        }), \" delegate to the\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#set_annotations\",\n          children: _jsx(InlineCode, {\n            children: \"set_annotations\"\n          })\n        }), \" methods.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a sentence.\\\")\\ntagger = nlp.add_pipe(\\\"tagger\\\")\\n# This usually happens under the hood\\nprocessed = tagger(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document to process. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The processed document. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pipe\",\n      children: [_jsx(_components.h2, {\n        id: \"pipe\",\n        tag: \"method\",\n        children: \"Tagger.pipe \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the pipe to a stream of documents. This usually happens under the hood\\nwhen the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is called on a text and all pipeline components are\\napplied to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in order. Both \", _jsx(_components.a, {\n          href: \"/api/tagger#call\",\n          children: _jsx(InlineCode, {\n            children: \"__call__\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"pipe\"\n          })\n        }), \" delegate to the \", _jsx(_components.a, {\n          href: \"/api/tagger#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#set_annotations\",\n          children: _jsx(InlineCode, {\n            children: \"set_annotations\"\n          })\n        }), \" methods.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\nfor doc in tagger.pipe(docs, batch_size=50):\\n    pass\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"stream\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A stream of documents. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"batch_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of documents to buffer. Defaults to \", _jsx(InlineCode, {\n                children: \"128\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The processed documents in order. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-initialize\",\n      children: [_jsx(_components.h2, {\n        id: \"initialize\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"Tagger.initialize \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the component for training. \", _jsx(InlineCode, {\n          children: \"get_examples\"\n        }), \" should be a function that\\nreturns an iterable of \", _jsx(_components.a, {\n          href: \"/api/example\",\n          children: _jsx(InlineCode, {\n            children: \"Example\"\n          })\n        }), \" objects. \", _jsx(_components.strong, {\n          children: \"At least one example\\nshould be supplied.\"\n        }), \" The data examples are used to \", _jsx(_components.strong, {\n          children: \"initialize the model\"\n        }), \" of\\nthe component and can either be the full training data or a representative\\nsample. Initialization includes validating the network,\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#validation\",\n          children: \"inferring missing shapes\"\n        }), \" and\\nsetting up the label scheme based on the data. This method is typically called\\nby \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Language.initialize\"\n          })\n        }), \" and lets you customize\\narguments it receives via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize.components]\"\n          })\n        }), \" block in the\\nconfig.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Changed in v3.0\",\n        id: \"begin_training\",\n        children: _jsxs(_components.p, {\n          children: [\"This method was previously called \", _jsx(InlineCode, {\n            children: \"begin_training\"\n          }), \".\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger.initialize(lambda: examples, nlp=nlp)\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[initialize.components.tagger]\\n\\n[initialize.components.tagger.labels]\\n@readers = \\\"spacy.read_labels.v1\\\"\\npath = \\\"corpus/labels/tagger.json\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that returns gold-standard annotations in the form of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects. Must contain at least one \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[], Iterable[Example]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"labels\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label information to add to the component, as provided by the \", _jsx(_components.a, {\n                href: \"#label_data\",\n                children: _jsx(InlineCode, {\n                  children: \"label_data\"\n                })\n              }), \" property after initialization. To generate a reusable JSON file from your data, you should run the \", _jsx(_components.a, {\n                href: \"/api/cli#init-labels\",\n                children: _jsx(InlineCode, {\n                  children: \"init labels\"\n                })\n              }), \" command. If no labels are provided, the \", _jsx(InlineCode, {\n                children: \"get_examples\"\n              }), \" callback is used to extract the labels from the data, which may be a lot slower. \", _jsx(_components.del, {\n                children: \"Optional[Iterable[str]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-predict\",\n      children: [_jsx(_components.h2, {\n        id: \"predict\",\n        tag: \"method\",\n        children: \"Tagger.predict \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the component’s model to a batch of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects, without\\nmodifying them.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\nscores = tagger.predict([doc1, doc2])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The documents to predict. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The model’s prediction for each document.\"\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_annotations\",\n      children: [_jsx(_components.h2, {\n        id: \"set_annotations\",\n        tag: \"method\",\n        children: \"Tagger.set_annotations \"\n      }), _jsxs(_components.p, {\n        children: [\"Modify a batch of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects, using pre-computed scores.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\nscores = tagger.predict([doc1, doc2])\\ntagger.set_annotations([doc1, doc2], scores)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The documents to modify. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scores\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scores to set, produced by \", _jsx(InlineCode, {\n                children: \"Tagger.predict\"\n              }), \".\"]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-update\",\n      children: [_jsx(_components.h2, {\n        id: \"update\",\n        tag: \"method\",\n        children: \"Tagger.update \"\n      }), _jsxs(_components.p, {\n        children: [\"Learn from a batch of \", _jsx(_components.a, {\n          href: \"/api/example\",\n          children: _jsx(InlineCode, {\n            children: \"Example\"\n          })\n        }), \" objects containing the\\npredictions and gold-standard annotations, and update the component’s model.\\nDelegates to \", _jsx(_components.a, {\n          href: \"/api/tagger#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#get_loss\",\n          children: _jsx(InlineCode, {\n            children: \"get_loss\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\noptimizer = nlp.initialize()\\nlosses = tagger.update(examples, sgd=optimizer)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects to learn from. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"drop\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The dropout rate. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sgd\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An optimizer. Will be created via \", _jsx(_components.a, {\n                href: \"#create_optimizer\",\n                children: _jsx(InlineCode, {\n                  children: \"create_optimizer\"\n                })\n              }), \" if not set. \", _jsx(_components.del, {\n                children: \"Optional[Optimizer]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"losses\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional record of the loss during training. Updated using the component name as the key. \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, float]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The updated \", _jsx(InlineCode, {\n                children: \"losses\"\n              }), \" dictionary. \", _jsx(_components.del, {\n                children: \"Dict[str, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-rehearse\",\n      children: [_jsx(_components.h2, {\n        id: \"rehearse\",\n        tag: \"method,experimental\",\n        version: \"3\",\n        children: \"Tagger.rehearse \"\n      }), _jsx(_components.p, {\n        children: \"Perform a “rehearsal” update from a batch of data. Rehearsal updates teach the\\ncurrent model to make predictions similar to an initial model, to try to address\\nthe “catastrophic forgetting” problem. This feature is experimental.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\noptimizer = nlp.resume_training()\\nlosses = tagger.rehearse(examples, sgd=optimizer)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects to learn from. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"drop\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The dropout rate. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sgd\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An optimizer. Will be created via \", _jsx(_components.a, {\n                href: \"#create_optimizer\",\n                children: _jsx(InlineCode, {\n                  children: \"create_optimizer\"\n                })\n              }), \" if not set. \", _jsx(_components.del, {\n                children: \"Optional[Optimizer]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"losses\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional record of the loss during training. Updated using the component name as the key. \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, float]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The updated \", _jsx(InlineCode, {\n                children: \"losses\"\n              }), \" dictionary. \", _jsx(_components.del, {\n                children: \"Dict[str, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_loss\",\n      children: [_jsx(_components.h2, {\n        id: \"get_loss\",\n        tag: \"method\",\n        children: \"Tagger.get_loss \"\n      }), _jsx(_components.p, {\n        children: \"Find the loss and gradient of loss for the batch of documents and their\\npredicted scores.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\nscores = tagger.predict([eg.predicted for eg in examples])\\nloss, d_loss = tagger.get_loss(examples, scores)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The batch of examples. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scores\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Scores representing the model’s predictions.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The loss and the gradient, i.e. \", _jsx(InlineCode, {\n                children: \"(loss, gradient)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Tuple[float, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-create_optimizer\",\n      children: [_jsx(_components.h2, {\n        id: \"create_optimizer\",\n        tag: \"method\",\n        children: \"Tagger.create_optimizer \"\n      }), _jsx(_components.p, {\n        children: \"Create an optimizer for the pipeline component.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\noptimizer = tagger.create_optimizer()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The optimizer. \", _jsx(_components.del, {\n                children: \"Optimizer\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-use_params\",\n      children: [_jsx(_components.h2, {\n        id: \"use_params\",\n        tag: \"method, contextmanager\",\n        children: \"Tagger.use_params \"\n      }), _jsx(_components.p, {\n        children: \"Modify the pipe’s model, to use the given parameter values. At the end of the\\ncontext, the original parameters are restored.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\nwith tagger.use_params(optimizer.averages):\\n    tagger.to_disk(\\\"/best_model\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"params\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The parameter values to use in the model. \", _jsx(_components.del, {\n                children: \"dict\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add_label\",\n      children: [_jsx(_components.h2, {\n        id: \"add_label\",\n        tag: \"method\",\n        children: \"Tagger.add_label \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a new label to the pipe. Raises an error if the output dimension is already\\nset, or if the model has already been fully \", _jsx(_components.a, {\n          href: \"#initialize\",\n          children: \"initialized\"\n        }), \". Note\\nthat you don’t have to call this method if you provide a \", _jsx(_components.strong, {\n          children: \"representative data\\nsample\"\n        }), \" to the \", _jsx(_components.a, {\n          href: \"#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"initialize\"\n          })\n        }), \" method. In this case, all labels\\nfound in the sample will be automatically added to the model, and the output\\ndimension will be \", _jsx(_components.a, {\n          href: \"/usage/layers-architectures#thinc-shape-inference\",\n          children: \"inferred\"\n        }), \"\\nautomatically.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger.add_label(\\\"MY_LABEL\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label to add. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"0\"\n              }), \" if the label is already present, otherwise \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        children: \"Tagger.to_disk \"\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to disk.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger.to_disk(\\\"/path/to/tagger\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory, which will be created if it doesn’t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        children: \"Tagger.from_disk \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from disk. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger.from_disk(\\\"/path/to/tagger\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Tagger\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"Tagger\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"Tagger.to_bytes \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger_bytes = tagger.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to a bytestring.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized form of the \", _jsx(InlineCode, {\n                children: \"Tagger\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"Tagger.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from a bytestring. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger_bytes = tagger.to_bytes()\\ntagger = nlp.add_pipe(\\\"tagger\\\")\\ntagger.from_bytes(tagger_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The data to load from. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Tagger\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"Tagger\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-labels\",\n      children: [_jsx(_components.h2, {\n        id: \"labels\",\n        tag: \"property\",\n        children: \"Tagger.labels \"\n      }), _jsx(_components.p, {\n        children: \"The labels currently added to the component.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tagger.add_label(\\\"MY_LABEL\\\")\\nassert \\\"MY_LABEL\\\" in tagger.labels\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The labels added to the component. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-label_data\",\n      children: [_jsx(_components.h2, {\n        id: \"label_data\",\n        tag: \"property\",\n        version: \"3\",\n        children: \"Tagger.label_data \"\n      }), _jsxs(_components.p, {\n        children: [\"The labels currently added to the component and their internal meta information.\\nThis is the data generated by \", _jsx(_components.a, {\n          href: \"/api/cli#init-labels\",\n          children: _jsx(InlineCode, {\n            children: \"init labels\"\n          })\n        }), \" and used by\\n\", _jsx(_components.a, {\n          href: \"/api/tagger#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Tagger.initialize\"\n          })\n        }), \" to initialize the model with a\\npre-defined label set.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"labels = tagger.label_data\\ntagger.initialize(lambda: [], nlp=nlp, labels=labels)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label data added to the component. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-serialization-fields\",\n      children: [_jsx(_components.h2, {\n        id: \"serialization-fields\",\n        children: \"Serialization fields \"\n      }), _jsxs(_components.p, {\n        children: [\"During serialization, spaCy will export several data fields used to restore\\ndifferent aspects of the object. If needed, you can exclude them from\\nserialization by passing in the string names via the \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" argument.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"data = tagger.to_disk(\\\"/path\\\", exclude=[\\\"vocab\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared \", _jsx(_components.a, {\n                href: \"/api/vocab\",\n                children: _jsx(InlineCode, {\n                  children: \"Vocab\"\n                })\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cfg\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The config file. You usually don’t want to exclude this.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The binary model data. You usually don’t want to exclude this.\"\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Tagger","tag":"class","source":"spacy/pipeline/tagger.pyx","teaser":"Pipeline component for part-of-speech tagging","api_base_class":"/api/pipe","api_string_name":"tagger","api_trainable":true},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":"tagger","baseClass":null,"trainable":true},"isIndex":false,"next":null},"__N_SSG":true}