{"pageProps":{"title":"DependencyParser","tag":"class","source":"spacy/pipeline/dep_parser.pyx","teaser":"Pipeline component for syntactic dependency parsing","api_base_class":"/api/pipe","api_string_name":"parser","api_trainable":true,"slug":"/api/dependencyparser","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsxs(_components.p, {\n        children: [\"A transition-based dependency parser component. The dependency parser jointly\\nlearns sentence segmentation and labelled dependency parsing, and can optionally\\nlearn to merge tokens that had been over-segmented by the tokenizer. The parser\\nuses a variant of the \", _jsx(_components.strong, {\n          children: \"non-monotonic arc-eager transition-system\"\n        }), \" described by\\n\", _jsx(_components.a, {\n          href: \"https://www.aclweb.org/anthology/D15-1162/\",\n          children: \"Honnibal and Johnson (2014)\"\n        }), \", with\\nthe addition of a “break” transition to perform the sentence segmentation.\\n\", _jsx(_components.a, {\n          href: \"https://www.aclweb.org/anthology/P05-1013/\",\n          children: \"Nivre (2005)\"\n        }), \"’s \", _jsx(_components.strong, {\n          children: \"pseudo-projective\\ndependency transformation\"\n        }), \" is used to allow the parser to predict\\nnon-projective parses.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The parser is trained using an \", _jsx(_components.strong, {\n          children: \"imitation learning objective\"\n        }), \". It follows the\\nactions predicted by the current weights, and at each state, determines which\\nactions are compatible with the optimal parse that could be reached from the\\ncurrent state. The weights are updated such that the scores assigned to the set\\nof optimal actions is increased, while scores assigned to other actions are\\ndecreased. Note that more than one action may be optimal for a given state.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-assigned-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"assigned-attributes\",\n        children: \"Assigned Attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"Dependency predictions are assigned to the \", _jsx(InlineCode, {\n          children: \"Token.dep\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token.head\"\n        }), \" fields.\\nBeside the dependencies themselves, the parser decides sentence boundaries,\\nwhich are saved in \", _jsx(InlineCode, {\n          children: \"Token.is_sent_start\"\n        }), \" and accessible via \", _jsx(InlineCode, {\n          children: \"Doc.sents\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Location\"\n            }), _jsx(_components.th, {\n              children: \"Value\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.dep\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The type of dependency relation (hash). \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.dep_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The type of dependency relation. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.head\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The syntactic parent, or “governor”, of this token. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.is_sent_start\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A boolean value indicating whether the token starts a sentence. After the parser runs this will be \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" for all tokens. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Doc.sents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An iterator over sentences in the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \", determined by \", _jsx(InlineCode, {\n                children: \"Token.is_sent_start\"\n              }), \" values. \", _jsx(_components.del, {\n                children: \"Iterator[Span]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-config\",\n      children: [_jsx(_components.h2, {\n        id: \"config\",\n        children: \"Config and implementation \"\n      }), _jsxs(_components.p, {\n        children: [\"The default config is defined by the pipeline component factory and describes\\nhow the component should be configured. You can override its settings via the\\n\", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" or in your\\n\", _jsxs(_components.a, {\n          href: \"/usage/training#config\",\n          children: [_jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" for training\"]\n        }), \". See the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures\",\n          children: \"model architectures\"\n        }), \" documentation for details on the\\narchitectures and their arguments and hyperparameters.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.pipeline.dep_parser import DEFAULT_PARSER_MODEL\\nconfig = {\\n   \\\"moves\\\": None,\\n   \\\"update_with_oracle_cut_size\\\": 100,\\n   \\\"learn_tokens\\\": False,\\n   \\\"min_action_freq\\\": 30,\\n   \\\"model\\\": DEFAULT_PARSER_MODEL,\\n}\\nnlp.add_pipe(\\\"parser\\\", config=config)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"moves\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of transition names. Inferred from the data if not provided. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[TransitionSystem]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"update_with_oracle_cut_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"During training, cut long sequences into shorter segments by creating intermediate states based on the gold-standard history. The model is not very sensitive to this parameter, so you usually won’t need to change it. Defaults to \", _jsx(InlineCode, {\n                children: \"100\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"learn_tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to learn to merge subtokens that are split relative to the gold standard. Experimental. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"min_action_freq\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The minimum frequency of labelled actions to retain. Rarer labelled actions have their label backed-off to “dep”. While this primarily affects the label accuracy, it can also affect the attachment structure, as the labels are used to represent the pseudo-projectivity transformation. Defaults to \", _jsx(InlineCode, {\n                children: \"30\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-model\",\n                children: _jsx(InlineCode, {\n                  children: \"Model\"\n                })\n              }), \" powering the pipeline component. Defaults to \", _jsx(_components.a, {\n                href: \"/api/architectures#TransitionBasedParser\",\n                children: \"TransitionBasedParser\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/dep_parser.pyx\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/dep_parser.pyx\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"DependencyParser.__init__ \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction via add_pipe with default model\\nparser = nlp.add_pipe(\\\"parser\\\")\\n\\n# Construction via add_pipe with custom model\\nconfig = {\\\"model\\\": {\\\"@architectures\\\": \\\"my_parser\\\"}}\\nparser = nlp.add_pipe(\\\"parser\\\", config=config)\\n\\n# Construction from class\\nfrom spacy.pipeline import DependencyParser\\nparser = DependencyParser(nlp.vocab, model)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Create a new pipeline instance. In your application, you would normally use a\\nshortcut for this and instantiate the component using its string name and\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared vocabulary. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-model\",\n                children: _jsx(InlineCode, {\n                  children: \"Model\"\n                })\n              }), \" powering the pipeline component. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name of the component instance. Used to add entries to the \", _jsx(InlineCode, {\n                children: \"losses\"\n              }), \" during training. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"moves\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of transition names. Inferred from the data if not provided. \", _jsx(_components.del, {\n                children: \"Optional[TransitionSystem]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"update_with_oracle_cut_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"During training, cut long sequences into shorter segments by creating intermediate states based on the gold-standard history. The model is not very sensitive to this parameter, so you usually won’t need to change it. Defaults to \", _jsx(InlineCode, {\n                children: \"100\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"learn_tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to learn to merge subtokens that are split relative to the gold standard. Experimental. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"min_action_freq\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The minimum frequency of labelled actions to retain. Rarer labelled actions have their label backed-off to “dep”. While this primarily affects the label accuracy, it can also affect the attachment structure, as the labels are used to represent the pseudo-projectivity transformation. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_deps\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_deps\"\n                })\n              }), \" for the attribute \", _jsx(InlineCode, {\n                children: \"\\\"dep\\\"\"\n              }), \" ignoring the labels \", _jsx(InlineCode, {\n                children: \"p\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"punct\"\n              }), \" and \", _jsx(_components.a, {\n                href: \"/api/scorer/#score_spans\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_spans\"\n                })\n              }), \" for the attribute \", _jsx(InlineCode, {\n                children: \"\\\"sents\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"DependencyParser.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the pipe to one document. The document is modified in place, and returned.\\nThis usually happens under the hood when the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is called on a text\\nand all pipeline components are applied to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in order. Both\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#call\",\n          children: _jsx(InlineCode, {\n            children: \"__call__\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"pipe\"\n          })\n        }), \" delegate to the\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#set_annotations\",\n          children: _jsx(InlineCode, {\n            children: \"set_annotations\"\n          })\n        }), \" methods.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a sentence.\\\")\\nparser = nlp.add_pipe(\\\"parser\\\")\\n# This usually happens under the hood\\nprocessed = parser(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document to process. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The processed document. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pipe\",\n      children: [_jsx(_components.h2, {\n        id: \"pipe\",\n        tag: \"method\",\n        children: \"DependencyParser.pipe \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the pipe to a stream of documents. This usually happens under the hood\\nwhen the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is called on a text and all pipeline components are\\napplied to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in order. Both \", _jsx(_components.a, {\n          href: \"/api/dependencyparser#call\",\n          children: _jsx(InlineCode, {\n            children: \"__call__\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"pipe\"\n          })\n        }), \" delegate to the\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#set_annotations\",\n          children: _jsx(InlineCode, {\n            children: \"set_annotations\"\n          })\n        }), \" methods.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nfor doc in parser.pipe(docs, batch_size=50):\\n    pass\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A stream of documents. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"batch_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of documents to buffer. Defaults to \", _jsx(InlineCode, {\n                children: \"128\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The processed documents in order. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-initialize\",\n      children: [_jsx(_components.h2, {\n        id: \"initialize\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"DependencyParser.initialize \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the component for training. \", _jsx(InlineCode, {\n          children: \"get_examples\"\n        }), \" should be a function that\\nreturns an iterable of \", _jsx(_components.a, {\n          href: \"/api/example\",\n          children: _jsx(InlineCode, {\n            children: \"Example\"\n          })\n        }), \" objects. \", _jsx(_components.strong, {\n          children: \"At least one example\\nshould be supplied.\"\n        }), \" The data examples are used to \", _jsx(_components.strong, {\n          children: \"initialize the model\"\n        }), \" of\\nthe component and can either be the full training data or a representative\\nsample. Initialization includes validating the network,\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#validation\",\n          children: \"inferring missing shapes\"\n        }), \" and\\nsetting up the label scheme based on the data. This method is typically called\\nby \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Language.initialize\"\n          })\n        }), \" and lets you customize\\narguments it receives via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize.components]\"\n          })\n        }), \" block in the\\nconfig.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Changed in v3.0\",\n        id: \"begin_training\",\n        children: _jsxs(_components.p, {\n          children: [\"This method was previously called \", _jsx(InlineCode, {\n            children: \"begin_training\"\n          }), \".\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser.initialize(lambda: examples, nlp=nlp)\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[initialize.components.parser]\\n\\n[initialize.components.parser.labels]\\n@readers = \\\"spacy.read_labels.v1\\\"\\npath = \\\"corpus/labels/parser.json\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that returns gold-standard annotations in the form of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects. Must contain at least one \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[], Iterable[Example]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"labels\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label information to add to the component, as provided by the \", _jsx(_components.a, {\n                href: \"#label_data\",\n                children: _jsx(InlineCode, {\n                  children: \"label_data\"\n                })\n              }), \" property after initialization. To generate a reusable JSON file from your data, you should run the \", _jsx(_components.a, {\n                href: \"/api/cli#init-labels\",\n                children: _jsx(InlineCode, {\n                  children: \"init labels\"\n                })\n              }), \" command. If no labels are provided, the \", _jsx(InlineCode, {\n                children: \"get_examples\"\n              }), \" callback is used to extract the labels from the data, which may be a lot slower. \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, Dict[str, int]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-predict\",\n      children: [_jsx(_components.h2, {\n        id: \"predict\",\n        tag: \"method\",\n        children: \"DependencyParser.predict \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the component’s model to a batch of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects, without\\nmodifying them.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nscores = parser.predict([doc1, doc2])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The documents to predict. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A helper class for the parse state (internal). \", _jsx(_components.del, {\n                children: \"StateClass\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_annotations\",\n      children: [_jsx(_components.h2, {\n        id: \"set_annotations\",\n        tag: \"method\",\n        children: \"DependencyParser.set_annotations \"\n      }), _jsxs(_components.p, {\n        children: [\"Modify a batch of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects, using pre-computed scores.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nscores = parser.predict([doc1, doc2])\\nparser.set_annotations([doc1, doc2], scores)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The documents to modify. \", _jsx(_components.del, {\n                children: \"Iterable[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scores\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scores to set, produced by \", _jsx(InlineCode, {\n                children: \"DependencyParser.predict\"\n              }), \". Returns an internal helper class for the parse state. \", _jsx(_components.del, {\n                children: \"List[StateClass]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-update\",\n      children: [_jsx(_components.h2, {\n        id: \"update\",\n        tag: \"method\",\n        children: \"DependencyParser.update \"\n      }), _jsxs(_components.p, {\n        children: [\"Learn from a batch of \", _jsx(_components.a, {\n          href: \"/api/example\",\n          children: _jsx(InlineCode, {\n            children: \"Example\"\n          })\n        }), \" objects, updating the pipe’s\\nmodel. Delegates to \", _jsx(_components.a, {\n          href: \"/api/dependencyparser#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#get_loss\",\n          children: _jsx(InlineCode, {\n            children: \"get_loss\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\noptimizer = nlp.initialize()\\nlosses = parser.update(examples, sgd=optimizer)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects to learn from. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"drop\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The dropout rate. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sgd\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An optimizer. Will be created via \", _jsx(_components.a, {\n                href: \"#create_optimizer\",\n                children: _jsx(InlineCode, {\n                  children: \"create_optimizer\"\n                })\n              }), \" if not set. \", _jsx(_components.del, {\n                children: \"Optional[Optimizer]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"losses\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional record of the loss during training. Updated using the component name as the key. \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, float]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The updated \", _jsx(InlineCode, {\n                children: \"losses\"\n              }), \" dictionary. \", _jsx(_components.del, {\n                children: \"Dict[str, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_loss\",\n      children: [_jsx(_components.h2, {\n        id: \"get_loss\",\n        tag: \"method\",\n        children: \"DependencyParser.get_loss \"\n      }), _jsx(_components.p, {\n        children: \"Find the loss and gradient of loss for the batch of documents and their\\npredicted scores.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nscores = parser.predict([eg.predicted for eg in examples])\\nloss, d_loss = parser.get_loss(examples, scores)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The batch of examples. \", _jsx(_components.del, {\n                children: \"Iterable[Example]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scores\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Scores representing the model’s predictions. \", _jsx(_components.del, {\n                children: \"StateClass\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The loss and the gradient, i.e. \", _jsx(InlineCode, {\n                children: \"(loss, gradient)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Tuple[float, float]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-create_optimizer\",\n      children: [_jsx(_components.h2, {\n        id: \"create_optimizer\",\n        tag: \"method\",\n        children: \"DependencyParser.create_optimizer \"\n      }), _jsxs(_components.p, {\n        children: [\"Create an \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-optimizers\",\n          children: _jsx(InlineCode, {\n            children: \"Optimizer\"\n          })\n        }), \" for the pipeline\\ncomponent.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\noptimizer = parser.create_optimizer()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The optimizer. \", _jsx(_components.del, {\n                children: \"Optimizer\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-use_params\",\n      children: [_jsx(_components.h2, {\n        id: \"use_params\",\n        tag: \"method, contextmanager\",\n        children: \"DependencyParser.use_params \"\n      }), _jsx(_components.p, {\n        children: \"Modify the pipe’s model, to use the given parameter values. At the end of the\\ncontext, the original parameters are restored.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = DependencyParser(nlp.vocab)\\nwith parser.use_params(optimizer.averages):\\n    parser.to_disk(\\\"/best_model\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"params\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The parameter values to use in the model. \", _jsx(_components.del, {\n                children: \"dict\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add_label\",\n      children: [_jsx(_components.h2, {\n        id: \"add_label\",\n        tag: \"method\",\n        children: \"DependencyParser.add_label \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a new label to the pipe. Note that you don’t have to call this method if you\\nprovide a \", _jsx(_components.strong, {\n          children: \"representative data sample\"\n        }), \" to the \", _jsx(_components.a, {\n          href: \"#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"initialize\"\n          })\n        }), \"\\nmethod. In this case, all labels found in the sample will be automatically added\\nto the model, and the output dimension will be\\n\", _jsx(_components.a, {\n          href: \"/usage/layers-architectures#thinc-shape-inference\",\n          children: \"inferred\"\n        }), \" automatically.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser.add_label(\\\"MY_LABEL\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label to add. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"0\"\n              }), \" if the label is already present, otherwise \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_output\",\n      children: [_jsx(_components.h2, {\n        id: \"set_output\",\n        tag: \"method\",\n        children: \"DependencyParser.set_output \"\n      }), _jsxs(_components.p, {\n        children: [\"Change the output dimension of the component’s model by calling the model’s\\nattribute \", _jsx(InlineCode, {\n          children: \"resize_output\"\n        }), \". This is a function that takes the original model and\\nthe new output dimension \", _jsx(InlineCode, {\n          children: \"nO\"\n        }), \", and changes the model in place. When resizing an\\nalready trained model, care should be taken to avoid the “catastrophic\\nforgetting” problem.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser.set_output(512)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The new output dimension. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        children: \"DependencyParser.to_disk \"\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to disk.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser.to_disk(\\\"/path/to/parser\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory, which will be created if it doesn’t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        children: \"DependencyParser.from_disk \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from disk. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser.from_disk(\\\"/path/to/parser\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"DependencyParser\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"DependencyParser\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"DependencyParser.to_bytes \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser = nlp.add_pipe(\\\"parser\\\")\\nparser_bytes = parser.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to a bytestring.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized form of the \", _jsx(InlineCode, {\n                children: \"DependencyParser\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"DependencyParser.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from a bytestring. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser_bytes = parser.to_bytes()\\nparser = nlp.add_pipe(\\\"parser\\\")\\nparser.from_bytes(parser_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The data to load from. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"DependencyParser\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"DependencyParser\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-labels\",\n      children: [_jsx(_components.h2, {\n        id: \"labels\",\n        tag: \"property\",\n        children: \"DependencyParser.labels \"\n      }), _jsx(_components.p, {\n        children: \"The labels currently added to the component.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"parser.add_label(\\\"MY_LABEL\\\")\\nassert \\\"MY_LABEL\\\" in parser.labels\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The labels added to the component. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-label_data\",\n      children: [_jsx(_components.h2, {\n        id: \"label_data\",\n        tag: \"property\",\n        version: \"3\",\n        children: \"DependencyParser.label_data \"\n      }), _jsxs(_components.p, {\n        children: [\"The labels currently added to the component and their internal meta information.\\nThis is the data generated by \", _jsx(_components.a, {\n          href: \"/api/cli#init-labels\",\n          children: _jsx(InlineCode, {\n            children: \"init labels\"\n          })\n        }), \" and used by\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"DependencyParser.initialize\"\n          })\n        }), \" to initialize\\nthe model with a pre-defined label set.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"labels = parser.label_data\\nparser.initialize(lambda: [], nlp=nlp, labels=labels)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label data added to the component. \", _jsx(_components.del, {\n                children: \"Dict[str, Dict[str, Dict[str, int]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-serialization-fields\",\n      children: [_jsx(_components.h2, {\n        id: \"serialization-fields\",\n        children: \"Serialization fields \"\n      }), _jsxs(_components.p, {\n        children: [\"During serialization, spaCy will export several data fields used to restore\\ndifferent aspects of the object. If needed, you can exclude them from\\nserialization by passing in the string names via the \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" argument.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"data = parser.to_disk(\\\"/path\\\", exclude=[\\\"vocab\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared \", _jsx(_components.a, {\n                href: \"/api/vocab\",\n                children: _jsx(InlineCode, {\n                  children: \"Vocab\"\n                })\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cfg\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The config file. You usually don’t want to exclude this.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"model\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The binary model data. You usually don’t want to exclude this.\"\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"DependencyParser","tag":"class","source":"spacy/pipeline/dep_parser.pyx","teaser":"Pipeline component for syntactic dependency parsing","api_base_class":"/api/pipe","api_string_name":"parser","api_trainable":true},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":"parser","baseClass":null,"trainable":true},"isIndex":false,"next":null},"__N_SSG":true}