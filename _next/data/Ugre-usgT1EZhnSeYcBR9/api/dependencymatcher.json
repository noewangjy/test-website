{"pageProps":{"title":"DependencyMatcher","teaser":"Match subtrees within a dependency parse","tag":"class","version":3,"source":"spacy/matcher/dependencymatcher.pyx","slug":"/api/dependencymatcher","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    h3: \"h3\",\n    em: \"em\",\n    h4: \"h4\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"DependencyMatcher\"\n        }), \" follows the same API as the \", _jsx(_components.a, {\n          href: \"/api/matcher\",\n          children: _jsx(InlineCode, {\n            children: \"Matcher\"\n          })\n        }), \"\\nand \", _jsx(_components.a, {\n          href: \"/api/phrasematcher\",\n          children: _jsx(InlineCode, {\n            children: \"PhraseMatcher\"\n          })\n        }), \" and lets you match on dependency trees\\nusing\\n\", _jsx(_components.a, {\n          href: \"https://nlp.stanford.edu/nlp/javadoc/javanlp/edu/stanford/nlp/semgraph/semgrex/SemgrexPattern.html\",\n          children: \"Semgrex operators\"\n        }), \".\\nIt requires a pretrained \", _jsx(_components.a, {\n          href: \"/api/parser\",\n          children: _jsx(InlineCode, {\n            children: \"DependencyParser\"\n          })\n        }), \" or other component\\nthat sets the \", _jsx(InlineCode, {\n          children: \"Token.dep\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token.head\"\n        }), \" attributes. See the\\n\", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching#dependencymatcher\",\n          children: \"usage guide\"\n        }), \" for examples.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"patterns\",\n        children: \"Pattern format \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            title: \"Example\",\n            children: \"# pattern: \\\"[subject] ... initially founded\\\"\\n[\\n  # anchor token: founded\\n  {\\n    \\\"RIGHT_ID\\\": \\\"founded\\\",\\n    \\\"RIGHT_ATTRS\\\": {\\\"ORTH\\\": \\\"founded\\\"}\\n  },\\n  # founded -> subject\\n  {\\n    \\\"LEFT_ID\\\": \\\"founded\\\",\\n    \\\"REL_OP\\\": \\\">\\\",\\n    \\\"RIGHT_ID\\\": \\\"subject\\\",\\n    \\\"RIGHT_ATTRS\\\": {\\\"DEP\\\": \\\"nsubj\\\"}\\n  },\\n  # \\\"founded\\\" follows \\\"initially\\\"\\n  {\\n    \\\"LEFT_ID\\\": \\\"founded\\\",\\n    \\\"REL_OP\\\": \\\";\\\",\\n    \\\"RIGHT_ID\\\": \\\"initially\\\",\\n    \\\"RIGHT_ATTRS\\\": {\\\"ORTH\\\": \\\"initially\\\"}\\n  }\\n]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"A pattern added to the \", _jsx(InlineCode, {\n          children: \"DependencyMatcher\"\n        }), \" consists of a list of dictionaries,\\nwith each dictionary describing a token to match. Except for the first\\ndictionary, which defines an anchor token using only \", _jsx(InlineCode, {\n          children: \"RIGHT_ID\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"RIGHT_ATTRS\"\n        }), \", each pattern should have the following keys:\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"LEFT_ID\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The name of the left-hand node in the relation, which has been defined in an earlier node. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"REL_OP\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An operator that describes how the two nodes are related. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"RIGHT_ID\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A unique name for the right-hand node in the relation. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"RIGHT_ATTRS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token attributes to match for the right-hand node in the same format as patterns provided to the regular token-based \", _jsx(_components.a, {\n                href: \"/api/matcher\",\n                children: _jsx(InlineCode, {\n                  children: \"Matcher\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Designing dependency matcher patterns\",\n        emoji: \"ðŸ“–\",\n        children: _jsxs(_components.p, {\n          children: [\"For examples of how to construct dependency matcher patterns for different types\\nof relations, see the usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/rule-based-matching#dependencymatcher\",\n            children: \"dependency matching\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"operators\",\n        children: \"Operators \"\n      }), _jsxs(_components.p, {\n        children: [\"The following operators are supported by the \", _jsx(InlineCode, {\n          children: \"DependencyMatcher\"\n        }), \", most of which\\ncome directly from\\n\", _jsx(_components.a, {\n          href: \"https://nlp.stanford.edu/nlp/javadoc/javanlp/edu/stanford/nlp/semgraph/semgrex/SemgrexPattern.html\",\n          children: \"Semgrex\"\n        }), \":\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Symbol\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A < B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" is the immediate dependent of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A > B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" is the immediate head of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A << B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" is the dependent in a chain to \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" following dep â†’ head paths.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A >> B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" is the head in a chain to \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" following head â†’ dep paths.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A . B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" immediately precedes \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A.i == B.i - 1\"\n              }), \", and both are within the same dependency tree.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A .* B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" precedes \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A.i < B.i\"\n              }), \", and both are within the same dependency tree \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A ; B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" immediately follows \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A.i == B.i + 1\"\n              }), \", and both are within the same dependency tree \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A ;* B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"A\"\n              }), \" follows \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A.i > B.i\"\n              }), \", and both are within the same dependency tree \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A $+ B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a right immediate sibling of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" have the same parent and \", _jsx(InlineCode, {\n                children: \"A.i == B.i - 1\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A $- B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a left immediate sibling of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" have the same parent and \", _jsx(InlineCode, {\n                children: \"A.i == B.i + 1\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A $++ B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a right sibling of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" have the same parent and \", _jsx(InlineCode, {\n                children: \"A.i < B.i\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A $-- B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a left sibling of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" have the same parent and \", _jsx(InlineCode, {\n                children: \"A.i > B.i\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A >++ B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a right child of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" is a parent of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"A.i < B.i\"\n              }), \" \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A >-- B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a left child of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" is a parent of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"A.i > B.i\"\n              }), \" \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A <++ B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a right parent of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" is a child of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"A.i < B.i\"\n              }), \" \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A <-- B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"B\"\n              }), \" is a left parent of \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \", i.e. \", _jsx(InlineCode, {\n                children: \"A\"\n              }), \" is a child of \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"A.i > B.i\"\n              }), \" \", _jsx(_components.em, {\n                children: \"(not in Semgrex)\"\n              }), \".\"]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"DependencyMatcher.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Create a \", _jsx(InlineCode, {\n          children: \"DependencyMatcher\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import DependencyMatcher\\nmatcher = DependencyMatcher(nlp.vocab)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The vocabulary object, which must be shared with the documents the matcher will operate on. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Validate all patterns added to this matcher. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"DependencyMatcher.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Find all tokens matching the supplied patterns on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import DependencyMatcher\\n\\nmatcher = DependencyMatcher(nlp.vocab)\\npattern = [{\\\"RIGHT_ID\\\": \\\"founded_id\\\",\\n  \\\"RIGHT_ATTRS\\\": {\\\"ORTH\\\": \\\"founded\\\"}}]\\nmatcher.add(\\\"FOUNDED\\\", [pattern])\\ndoc = nlp(\\\"Bill Gates founded Microsoft.\\\")\\nmatches = matcher(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doclike\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" to match over. \", _jsx(_components.del, {\n                children: \"Union[Doc, Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of \", _jsx(InlineCode, {\n                children: \"(match_id, token_ids)\"\n              }), \" tuples, describing the matches. The \", _jsx(InlineCode, {\n                children: \"match_id\"\n              }), \" is the ID of the match pattern and \", _jsx(InlineCode, {\n                children: \"token_ids\"\n              }), \" is a list of token indices matched by the pattern, where the position of each token in the list corresponds to the position of the node specification in the pattern. \", _jsx(_components.del, {\n                children: \"List[Tuple[int, List[int]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"DependencyMatcher.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"Get the number of rules added to the dependency matcher. Note that this only\\nreturns the number of rules (identical with the number of IDs), not the number\\nof individual patterns.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher = DependencyMatcher(nlp.vocab)\\nassert len(matcher) == 0\\npattern = [{\\\"RIGHT_ID\\\": \\\"founded_id\\\",\\n  \\\"RIGHT_ATTRS\\\": {\\\"ORTH\\\": \\\"founded\\\"}}]\\nmatcher.add(\\\"FOUNDED\\\", [pattern])\\nassert len(matcher) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rules. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-contains\",\n      children: [_jsx(_components.h2, {\n        id: \"contains\",\n        tag: \"method\",\n        children: \"DependencyMatcher.__contains__ \"\n      }), _jsx(_components.p, {\n        children: \"Check whether the matcher contains rules for a match ID.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher = DependencyMatcher(nlp.vocab)\\nassert \\\"FOUNDED\\\" not in matcher\\nmatcher.add(\\\"FOUNDED\\\", [pattern])\\nassert \\\"FOUNDED\\\" in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The match ID. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the matcher contains rules for this match ID. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add\",\n      children: [_jsx(_components.h2, {\n        id: \"add\",\n        tag: \"method\",\n        children: \"DependencyMatcher.add \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a rule to the matcher, consisting of an ID key, one or more patterns, and an\\noptional callback function to act on the matches. The callback function will\\nreceive the arguments \", _jsx(InlineCode, {\n          children: \"matcher\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"i\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"matches\"\n        }), \". If a pattern already\\nexists for the given ID, the patterns will be extended. An \", _jsx(InlineCode, {\n          children: \"on_match\"\n        }), \" callback\\nwill be overwritten.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"def on_match(matcher, doc, id, matches):\\n    print('Matched!', matches)\\n\\nmatcher = DependencyMatcher(nlp.vocab)\\nmatcher.add(\\\"FOUNDED\\\", patterns, on_match=on_match)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"match_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An ID for the patterns. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of match patterns. A pattern consists of a list of dicts, where each dict describes a token in the tree. \", _jsx(_components.del, {\n                children: \"List[List[Dict[str, Union[str, Dict]]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"on_match\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Callback function to act on matches. Takes the arguments \", _jsx(InlineCode, {\n                children: \"matcher\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"doc\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"i\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"matches\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[DependencyMatcher, Doc, int, List[Tuple], Any]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get\",\n      children: [_jsx(_components.h2, {\n        id: \"get\",\n        tag: \"method\",\n        children: \"DependencyMatcher.get \"\n      }), _jsxs(_components.p, {\n        children: [\"Retrieve the pattern stored for a key. Returns the rule as an\\n\", _jsx(InlineCode, {\n          children: \"(on_match, patterns)\"\n        }), \" tuple containing the callback and available patterns.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher.add(\\\"FOUNDED\\\", patterns, on_match=on_match)\\non_match, patterns = matcher.get(\\\"FOUNDED\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the match rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The rule, as an \", _jsx(InlineCode, {\n                children: \"(on_match, patterns)\"\n              }), \" tuple. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Callable], List[List[Union[Dict, Tuple]]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove\",\n      children: [_jsx(_components.h2, {\n        id: \"remove\",\n        tag: \"method\",\n        children: \"DependencyMatcher.remove \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove a rule from the dependency matcher. A \", _jsx(InlineCode, {\n          children: \"KeyError\"\n        }), \" is raised if the match\\nID does not exist.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher.add(\\\"FOUNDED\\\", patterns)\\nassert \\\"FOUNDED\\\" in matcher\\nmatcher.remove(\\\"FOUNDED\\\")\\nassert \\\"FOUNDED\\\" not in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the match rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"DependencyMatcher","teaser":"Match subtrees within a dependency parse","tag":"class","version":3,"source":"spacy/matcher/dependencymatcher.pyx"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}