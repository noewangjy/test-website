{"pageProps":{"title":"Cython Architecture","next":null,"menu":[["Overview","overview"],["Conventions","conventions"]],"slug":"/api/cython","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    p: \"p\",\n    a: \"a\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-overview\",\n      children: [_jsx(_components.h2, {\n        id: \"overview\",\n        hidden: \"true\",\n        children: \"Overview \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"What’s Cython?\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"http://cython.org/\",\n            children: \"Cython\"\n          }), \" is a language for writing C extensions for\\nPython. Most Python code is also valid Cython, but you can add type\\ndeclarations to get efficient memory-managed code just like C or C++.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"This section documents spaCy’s C-level data structures and interfaces, intended\\nfor use from Cython. Some of the attributes are primarily for internal use, and\\nall C-level functions and methods are designed for speed over safety – if you\\nmake a mistake and access an array out-of-bounds, the program may crash\\nabruptly.\"\n      }), _jsx(_components.p, {\n        children: \"With Cython there are four ways of declaring complex data types. Unfortunately\\nwe use all four in different places, as they all have different utility:\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Declaration\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            }), _jsx(_components.th, {\n              children: \"Example\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"class\"\n              })\n            }), _jsx(_components.td, {\n              children: \"A normal Python class.\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/language\",\n                children: _jsx(InlineCode, {\n                  children: \"Language\"\n                })\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cdef class\"\n              })\n            }), _jsx(_components.td, {\n              children: \"A Python extension type. Differs from a normal Python class in that its attributes can be defined on the underlying struct. Can have C-level objects as attributes (notably structs and pointers), and can have methods which have C-level objects as arguments or return types.\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/cython-classes#lexeme\",\n                children: _jsx(InlineCode, {\n                  children: \"Lexeme\"\n                })\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cdef struct\"\n              })\n            }), _jsx(_components.td, {\n              children: \"A struct is just a collection of variables, sort of like a named tuple, except the memory is contiguous. Structs can’t have methods, only attributes.\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/cython-structs#lexemec\",\n                children: _jsx(InlineCode, {\n                  children: \"LexemeC\"\n                })\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"cdef cppclass\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A C++ class. Like a struct, this can be allocated on the stack, but can have methods, a constructor and a destructor. Differs from \", _jsx(InlineCode, {\n                children: \"cdef class\"\n              }), \" in that it can be created and destroyed without acquiring the Python global interpreter lock. This style is the most obscure.\"]\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/_parser_internals/_state.pxd\",\n                children: _jsx(InlineCode, {\n                  children: \"StateC\"\n                })\n              })\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"The most important classes in spaCy are defined as \", _jsx(InlineCode, {\n          children: \"cdef class\"\n        }), \" objects. The\\nunderlying data for these objects is usually gathered into a struct, which is\\nusually named \", _jsx(InlineCode, {\n          children: \"c\"\n        }), \". For instance, the \", _jsx(_components.a, {\n          href: \"/api/cython-classses#lexeme\",\n          children: _jsx(InlineCode, {\n            children: \"Lexeme\"\n          })\n        }), \"\\nclass holds a \", _jsx(_components.a, {\n          href: \"/api/cython-structs#lexemec\",\n          children: _jsx(InlineCode, {\n            children: \"LexemeC\"\n          })\n        }), \" struct, at \", _jsx(InlineCode, {\n          children: \"Lexeme.c\"\n        }), \".\\nThis lets you shed the Python container, and pass a pointer to the underlying\\ndata into C-level functions.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-conventions\",\n      children: [_jsx(_components.h2, {\n        id: \"conventions\",\n        children: \"Conventions \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy’s core data structures are implemented as \", _jsx(_components.a, {\n          href: \"http://cython.org/\",\n          children: \"Cython\"\n        }), \"\\n\", _jsx(InlineCode, {\n          children: \"cdef\"\n        }), \" classes. Memory is managed through the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/cymem\",\n          children: _jsx(InlineCode, {\n            children: \"cymem\"\n          })\n        }), \" \", _jsx(InlineCode, {\n          children: \"cymem.Pool\"\n        }), \" class, which allows\\nyou to allocate memory which will be freed when the \", _jsx(InlineCode, {\n          children: \"Pool\"\n        }), \" object is garbage\\ncollected. This means you usually don’t have to worry about freeing memory. You\\njust have to decide which Python object owns the memory, and make it own the\\n\", _jsx(InlineCode, {\n          children: \"Pool\"\n        }), \". When that object goes out of scope, the memory will be freed. You do\\nhave to take care that no pointers outlive the object that owns them — but this\\nis generally quite easy.\"]\n      }), _jsxs(_components.p, {\n        children: [\"All Cython modules should have the \", _jsx(InlineCode, {\n          children: \"# cython: infer_types=True\"\n        }), \" compiler\\ndirective at the top of the file. This makes the code much cleaner, as it avoids\\nthe need for many type declarations. If possible, you should prefer to declare\\nyour functions \", _jsx(InlineCode, {\n          children: \"nogil\"\n        }), \", even if you don’t especially care about multi-threading.\\nThe reason is that \", _jsx(InlineCode, {\n          children: \"nogil\"\n        }), \" functions help the Cython compiler reason about your\\ncode quite a lot — you’re telling the compiler that no Python dynamics are\\npossible. This lets many errors be raised, and ensures your function will run at\\nC speed.\"]\n      }), _jsx(_components.p, {\n        children: \"Cython gives you many choices of sequences: you could have a Python list, a\\nnumpy array, a memory view, a C++ vector, or a pointer. Pointers are preferred,\\nbecause they are fastest, have the most explicit semantics, and let the compiler\\ncheck your code more strictly. C++ vectors are also great — but you should only\\nuse them internally in functions. It’s less friendly to accept a vector as an\\nargument, because that asks the user to do much more work. Here’s how to get a\\npointer from a numpy array, memory view or vector:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"cdef void get_pointers(np.ndarray[int, mode='c'] numpy_array, vector[int] cpp_vector, int[::1] memory_view) nogil:\\npointer1 = <int*>numpy_array.data\\npointer2 = cpp_vector.data()\\npointer3 = &memory_view[0]\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"Both C arrays and C++ vectors reassure the compiler that no Python operations\\nare possible on your variable. This is a big advantage: it lets the Cython\\ncompiler raise many more errors for you.\"\n      }), _jsx(_components.p, {\n        children: \"When getting a pointer from a numpy array or memoryview, take care that the data\\nis actually stored in C-contiguous order — otherwise you’ll get a pointer to\\nnonsense. The type-declarations in the code above should generate runtime errors\\nif buffers with incorrect memory layouts are passed in. To iterate over the\\narray, the following style is preferred:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"cdef int c_total(const int* int_array, int length) nogil:\\n    total = 0\\n    for item in int_array[:length]:\\n        total += item\\n    return total\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If this is confusing, consider that the compiler couldn’t deal with\\n\", _jsx(InlineCode, {\n          children: \"for item in int_array:\"\n        }), \" — there’s no length attached to a raw pointer, so how\\ncould we figure out where to stop? The length is provided in the slice notation\\nas a solution to this. Note that we don’t have to declare the type of \", _jsx(InlineCode, {\n          children: \"item\"\n        }), \" in\\nthe code above — the compiler can easily infer it. This gives us tidy code that\\nlooks quite like Python, but is exactly as fast as C — because we’ve made sure\\nthe compilation to C is trivial.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Your functions cannot be declared \", _jsx(InlineCode, {\n          children: \"nogil\"\n        }), \" if they need to create Python objects\\nor call Python functions. This is perfectly okay — you shouldn’t torture your\\ncode just to get \", _jsx(InlineCode, {\n          children: \"nogil\"\n        }), \" functions. However, if your function isn’t \", _jsx(InlineCode, {\n          children: \"nogil\"\n        }), \", you\\nshould compile your module with \", _jsx(InlineCode, {\n          children: \"cython -a --cplus my_module.pyx\"\n        }), \" and open the\\nresulting \", _jsx(InlineCode, {\n          children: \"my_module.html\"\n        }), \" file in a browser. This will let you see how Cython\\nis compiling your code. Calls into the Python run-time will be in bright yellow.\\nThis lets you easily see whether Cython is able to correctly type your code, or\\nwhether there are unexpected problems.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Working in Cython is very rewarding once you’re over the initial learning curve.\\nAs with C and C++, the first way you write something in Cython will often be the\\nperformance-optimal approach. In contrast, Python optimization generally\\nrequires a lot of experimentation. Is it faster to have an \", _jsx(InlineCode, {\n          children: \"if item in my_dict\"\n        }), \"\\ncheck, or to use \", _jsx(InlineCode, {\n          children: \".get()\"\n        }), \"? What about \", _jsx(InlineCode, {\n          children: \"try\"\n        }), \"/\", _jsx(InlineCode, {\n          children: \"except\"\n        }), \"? Does this numpy operation\\ncreate a copy? There’s no way to guess the answers to these questions, and\\nyou’ll usually be dissatisfied with your results — so there’s no way to know\\nwhen to stop this process. In the worst case, you’ll make a mess that invites\\nthe next reader to try their luck too. This is like one of those\\n\", _jsx(_components.a, {\n          href: \"http://www.wemjournal.org/article/S1080-6032%2809%2970088-2/abstract\",\n          children: \"volcanic gas-traps\"\n        }), \",\\nwhere the rescuers keep passing out from low oxygen, causing another rescuer to\\nfollow — only to succumb themselves. In short, just say no to optimizing your\\nPython. If it’s not fast enough the first time, just switch to Cython.\"]\n      }), _jsx(Infobox, {\n        title: \"Resources\",\n        emoji: \"📖\",\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.a, {\n              href: \"http://docs.cython.org/en/latest/\",\n              children: \"Official Cython documentation\"\n            }), \"\\n(cython.org)\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.a, {\n              href: \"https://explosion.ai/blog/writing-c-in-cython\",\n              children: \"Writing C in Cython\"\n            }), \"\\n(explosion.ai)\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.a, {\n              href: \"https://explosion.ai/blog/multithreading-with-cython\",\n              children: \"Multi-threading spaCy’s parser and named entity recognizer\"\n            }), \"\\n(explosion.ai)\"]\n          }), \"\\n\"]\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Cython Architecture","next":"/api/cython-structs","menu":[["Overview","overview"],["Conventions","conventions"]]},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true}