{"pageProps":{"title":"Language Processing Pipelines","next":{"slug":"/usage/embeddings-transformers","title":"Embeddings & Transformers"},"menu":[["Processing Text","processing"],["Pipelines & Components","pipelines"],["Custom Components","custom-components"],["Component Data","component-data"],["Type Hints & Validation","type-hints"],["Trainable Components","trainable-components"],["Extension Attributes","custom-components-attributes"],["Plugins & Wrappers","plugins"]],"slug":"/usage/processing-pipelines","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    ol: \"ol\",\n    h3: \"h3\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    em: \"em\",\n    del: \"del\",\n    img: \"img\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components), {Pipelines101, InlineCode, Infobox, Accordion} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Pipelines101) _missingMdxReference(\"Pipelines101\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsx(Pipelines101, {})\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-processing\",\n      children: [_jsx(_components.h2, {\n        id: \"processing\",\n        children: \"Processing text \"\n      }), _jsxs(_components.p, {\n        children: [\"When you call \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" on a text, spaCy will \", _jsx(_components.strong, {\n          children: \"tokenize\"\n        }), \" it and then \", _jsx(_components.strong, {\n          children: \"call each\\ncomponent\"\n        }), \" on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", in order. It then returns the processed \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" that you\\ncan work with.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"doc = nlp(\\\"This is a text\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When processing large volumes of text, the statistical models are usually more\\nefficient if you let them work on batches of texts. spaCy‚Äôs\\n\", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" method takes an iterable of texts and yields\\nprocessed \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects. The batching is done internally.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"texts = [\\\"This is a text\\\", \\\"These are lots of texts\\\", \\\"...\\\"]\\n- docs = [nlp(text) for text in texts]\\n+ docs = list(nlp.pipe(texts))\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Tips for efficient processing\",\n        emoji: \"üí°\",\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Process the texts \", _jsx(_components.strong, {\n              children: \"as a stream\"\n            }), \" using \", _jsx(_components.a, {\n              href: \"/api/language#pipe\",\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipe\"\n              })\n            }), \" and\\nbuffer them in batches, instead of one-by-one. This is usually much more\\nefficient.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Only apply the \", _jsx(_components.strong, {\n              children: \"pipeline components you need\"\n            }), \". Getting predictions from the\\nmodel that you don‚Äôt actually need adds up and becomes very inefficient at\\nscale. To prevent this, use the \", _jsx(InlineCode, {\n              children: \"disable\"\n            }), \" keyword argument to disable\\ncomponents you don‚Äôt need ‚Äì either when loading a pipeline, or during\\nprocessing with \", _jsx(InlineCode, {\n              children: \"nlp.pipe\"\n            }), \". See the section on\\n\", _jsx(_components.a, {\n              href: \"#disabling\",\n              children: \"disabling pipeline components\"\n            }), \" for more details and examples.\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In this example, we‚Äôre using \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" to process a\\n(potentially very large) iterable of texts as a stream. Because we‚Äôre only\\naccessing the named entities in \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \" (set by the \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" component), we‚Äôll\\ndisable all other components during processing. \", _jsx(InlineCode, {\n          children: \"nlp.pipe\"\n        }), \" yields \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects,\\nso we can iterate over them and access the named entity predictions:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Also disable the \", _jsx(InlineCode, {\n              children: \"\\\"ner\\\"\"\n            }), \" component. You‚Äôll see that the \", _jsx(InlineCode, {\n              children: \"doc.ents\"\n            }), \" are now\\nempty, because the entity recognizer didn‚Äôt run.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\ntexts = [\\n    \\\"Net income was $9.4 million compared to the prior year of $2.7 million.\\\",\\n    \\\"Revenue exceeded twelve billion dollars, with a loss of $1b.\\\",\\n]\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nfor doc in nlp.pipe(texts, disable=[\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]):\\n    # Do something with the doc here\\n    print([(ent.text, ent.label_) for ent in doc.ents])\\n\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"When using \", _jsx(_components.a, {\n            href: \"/api/language#pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.pipe\"\n            })\n          }), \", keep in mind that it returns a\\n\", _jsx(_components.a, {\n            href: \"https://realpython.com/introduction-to-python-generators/\",\n            children: \"generator\"\n          }), \" that\\nyields \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects ‚Äì not a list. So if you want to use it like a list, you‚Äôll\\nhave to call \", _jsx(InlineCode, {\n            children: \"list()\"\n          }), \" on it first:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"- docs = nlp.pipe(texts)[0]         # will raise an error\\n+ docs = list(nlp.pipe(texts))[0]   # works as expected\\n\"\n          })\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"You can use the \", _jsx(InlineCode, {\n          children: \"as_tuples\"\n        }), \" option to pass additional context along with each\\ndoc when using \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \". If \", _jsx(InlineCode, {\n          children: \"as_tuples\"\n        }), \" is \", _jsx(InlineCode, {\n          children: \"True\"\n        }), \", then\\nthe input should be a sequence of \", _jsx(InlineCode, {\n          children: \"(text, context)\"\n        }), \" tuples and the output will\\nbe a sequence of \", _jsx(InlineCode, {\n          children: \"(doc, context)\"\n        }), \" tuples. For example, you can pass metadata in\\nthe context and save it in a \", _jsx(_components.a, {\n          href: \"#custom-components-attributes\",\n          children: \"custom attribute\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.tokens import Doc\\n\\nif not Doc.has_extension(\\\"text_id\\\"):\\n    Doc.set_extension(\\\"text_id\\\", default=None)\\n\\ntext_tuples = [\\n    (\\\"This is the first text.\\\", {\\\"text_id\\\": \\\"text1\\\"}),\\n    (\\\"This is the second text.\\\", {\\\"text_id\\\": \\\"text2\\\"})\\n]\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\ndoc_tuples = nlp.pipe(text_tuples, as_tuples=True)\\n\\ndocs = []\\nfor doc, context in doc_tuples:\\n    doc._.text_id = context[\\\"text_id\\\"]\\n    docs.append(doc)\\n\\nfor doc in docs:\\n    print(f\\\"{doc._.text_id}: {doc.text}\\\")\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"multiprocessing\",\n        children: \"Multiprocessing \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy includes built-in support for multiprocessing with\\n\", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" using the \", _jsx(InlineCode, {\n          children: \"n_process\"\n        }), \" option:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Multiprocessing with 4 processes\\ndocs = nlp.pipe(texts, n_process=4)\\n\\n# With as many processes as CPUs (use with caution!)\\ndocs = nlp.pipe(texts, n_process=-1)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Depending on your platform, starting many processes with multiprocessing can add\\na lot of overhead. In particular, the default start method \", _jsx(InlineCode, {\n          children: \"spawn\"\n        }), \" used in\\nmacOS/OS X (as of Python 3.8) and in Windows can be slow for larger models\\nbecause the model data is copied in memory for each new process. See the\\n\", _jsx(_components.a, {\n          href: \"https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\",\n          children: \"Python docs on multiprocessing\"\n        }), \"\\nfor further details.\"]\n      }), _jsxs(_components.p, {\n        children: [\"For shorter tasks and in particular with \", _jsx(InlineCode, {\n          children: \"spawn\"\n        }), \", it can be faster to use a\\nsmaller number of processes with a larger batch size. The optimal \", _jsx(InlineCode, {\n          children: \"batch_size\"\n        }), \"\\nsetting will depend on the pipeline components, the length of your documents,\\nthe number of processes and how much memory is available.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Default batch size is `nlp.batch_size` (typically 1000)\\ndocs = nlp.pipe(texts, n_process=2, batch_size=2000)\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Multiprocessing on GPU\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Multiprocessing is not generally recommended on GPU because RAM is too limited.\\nIf you want to try it out, be aware that it is only possible using \", _jsx(InlineCode, {\n            children: \"spawn\"\n          }), \" due\\nto limitations in CUDA.\"]\n        })\n      }), _jsx(Infobox, {\n        title: \"Multiprocessing with transformer models\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"In Linux, transformer models may hang or deadlock with multiprocessing due to an\\n\", _jsx(_components.a, {\n            href: \"https://github.com/pytorch/pytorch/issues/17199\",\n            children: \"issue in PyTorch\"\n          }), \". One\\nsuggested workaround is to use \", _jsx(InlineCode, {\n            children: \"spawn\"\n          }), \" instead of \", _jsx(InlineCode, {\n            children: \"fork\"\n          }), \" and another is to limit\\nthe number of threads before loading any models using\\n\", _jsx(InlineCode, {\n            children: \"torch.set_num_threads(1)\"\n          }), \".\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pipelines\",\n      children: [_jsx(_components.h2, {\n        id: \"pipelines\",\n        children: \"Pipelines and built-in components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy makes it very easy to create your own pipelines consisting of reusable\\ncomponents ‚Äì this includes spaCy‚Äôs default tagger, parser and entity recognizer,\\nbut also your own custom processing functions. A pipeline component can be added\\nto an already existing \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object, specified when initializing a\\n\", _jsx(_components.a, {\n          href: \"/api/language\",\n          children: _jsx(InlineCode, {\n            children: \"Language\"\n          })\n        }), \" class, or defined within a\\n\", _jsx(_components.a, {\n          href: \"/usage/saving-loading#models\",\n          children: \"pipeline package\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \" [nlp]\\n lang = \\\"en\\\"\\n pipeline = [\\\"tok2vec\\\", \\\"parser\\\"]\\n\\n[components]\\n\\n[components.tok2vec]\\nfactory = \\\"tok2vec\\\"\\n# Settings for the tok2vec component\\n\\n[components.parser]\\nfactory = \\\"parser\\\"\\n# Settings for the parser component\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"When you load a pipeline, spaCy first consults the\\n\", _jsx(_components.a, {\n          href: \"/usage/saving-loading#models\",\n          children: _jsx(InlineCode, {\n            children: \"meta.json\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \". The config tells spaCy what language\\nclass to use, which components are in the pipeline, and how those components\\nshould be created. spaCy will then do the following:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Load the \", _jsx(_components.strong, {\n            children: \"language class and data\"\n          }), \" for the given ID via\\n\", _jsx(_components.a, {\n            href: \"/api/top-level#util.get_lang_class\",\n            children: _jsx(InlineCode, {\n              children: \"get_lang_class\"\n            })\n          }), \" and initialize it. The\\n\", _jsx(InlineCode, {\n            children: \"Language\"\n          }), \" class contains the shared vocabulary, tokenization rules and the\\nlanguage-specific settings.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Iterate over the \", _jsx(_components.strong, {\n            children: \"pipeline names\"\n          }), \" and look up each component name in the\\n\", _jsx(InlineCode, {\n            children: \"[components]\"\n          }), \" block. The \", _jsx(InlineCode, {\n            children: \"factory\"\n          }), \" tells spaCy which\\n\", _jsx(_components.a, {\n            href: \"#custom-components-factories\",\n            children: \"component factory\"\n          }), \" to use for adding the\\ncomponent with \", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"add_pipe\"\n            })\n          }), \". The settings are passed\\ninto the factory.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Make the \", _jsx(_components.strong, {\n            children: \"model data\"\n          }), \" available to the \", _jsx(InlineCode, {\n            children: \"Language\"\n          }), \" class by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#from_disk\",\n            children: _jsx(InlineCode, {\n              children: \"from_disk\"\n            })\n          }), \" with the path to the data directory.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"So when you call this‚Ä¶\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"en_core_web_sm\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"‚Ä¶ the pipeline‚Äôs \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" tells spaCy to use the language \", _jsx(InlineCode, {\n          children: \"\\\"en\\\"\"\n        }), \" and the\\npipeline\\n\", _jsx(InlineCode, {\n          children: \"[\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"ner\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]\"\n        }), \". spaCy\\nwill then initialize \", _jsx(InlineCode, {\n          children: \"spacy.lang.en.English\"\n        }), \", and create each pipeline component\\nand add it to the processing pipeline. It‚Äôll then load in the model data from\\nthe data directory and return the modified \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class for you to use as\\nthe \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object.\"]\n      }), _jsx(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"spaCy v3.0 introduces a \", _jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \", which includes more detailed settings for\\nthe pipeline, its components and the \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"training process\"\n          }), \".\\nYou can export the config of your current \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#config\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.config.to_disk\"\n            })\n          }), \".\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Fundamentally, a \", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"spaCy pipeline package\"\n        }), \" consists of three components:\\n\", _jsx(_components.strong, {\n          children: \"the weights\"\n        }), \", i.e. binary data loaded in from a directory, a \", _jsx(_components.strong, {\n          children: \"pipeline\"\n        }), \" of\\nfunctions called in order, and \", _jsx(_components.strong, {\n          children: \"language data\"\n        }), \" like the tokenization rules and\\nlanguage-specific settings. For example, a Spanish NER pipeline requires\\ndifferent weights, language data and components than an English parsing and\\ntagging pipeline. This is also why the pipeline state is always held by the\\n\", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class. \", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \" puts this all\\ntogether and returns an instance of \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" with a pipeline set and access to\\nthe binary data:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"spacy.load under the hood\",\n          children: \"lang = \\\"en\\\"\\npipeline = [\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"ner\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]\\ndata_path = \\\"path/to/en_core_web_sm/en_core_web_sm-3.0.0\\\"\\n\\ncls = spacy.util.get_lang_class(lang)  # 1. Get Language class, e.g. English\\nnlp = cls()                            # 2. Initialize it\\nfor name in pipeline:\\n    nlp.add_pipe(name)                 # 3. Add the component to the pipeline\\nnlp.from_disk(data_path)               # 4. Load in the binary data\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When you call \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" on a text, spaCy will \", _jsx(_components.strong, {\n          children: \"tokenize\"\n        }), \" it and then \", _jsx(_components.strong, {\n          children: \"call each\\ncomponent\"\n        }), \" on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", in order. Since the model data is loaded, the\\ncomponents can access it to assign annotations to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object, and\\nsubsequently to the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" which are only views of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", and\\ndon‚Äôt own any data themselves. All components return the modified document,\\nwhich is then processed by the next component in the pipeline.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The pipeline under the hood\",\n          children: \"doc = nlp.make_doc(\\\"This is a sentence\\\")  # Create a Doc from raw text\\nfor name, proc in nlp.pipeline:           # Iterate over components in order\\n    doc = proc(doc)                       # Apply each component\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The current processing pipeline is available as \", _jsx(InlineCode, {\n          children: \"nlp.pipeline\"\n        }), \", which returns a\\nlist of \", _jsx(InlineCode, {\n          children: \"(name, component)\"\n        }), \" tuples, or \", _jsx(InlineCode, {\n          children: \"nlp.pipe_names\"\n        }), \", which only returns a\\nlist of human-readable component names.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"print(nlp.pipeline)\\n# [('tok2vec', <spacy.pipeline.Tok2Vec>), ('tagger', <spacy.pipeline.Tagger>), ('parser', <spacy.pipeline.DependencyParser>), ('ner', <spacy.pipeline.EntityRecognizer>), ('attribute_ruler', <spacy.pipeline.AttributeRuler>), ('lemmatizer', <spacy.lang.en.lemmatizer.EnglishLemmatizer>)]\\nprint(nlp.pipe_names)\\n# ['tok2vec', 'tagger', 'parser', 'ner', 'attribute_ruler', 'lemmatizer']\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"built-in\",\n        children: \"Built-in pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy ships with several built-in pipeline components that are registered with\\nstring names. This means that you can initialize them by calling\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" with their names and spaCy will know\\nhow to create them. See the \", _jsx(_components.a, {\n          href: \"/api\",\n          children: \"API documentation\"\n        }), \" for a full list of\\navailable pipeline components and component functions.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Usage\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"sentencizer\\\")\\n# add_pipe returns the added component\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"String name\"\n            }), _jsx(_components.th, {\n              children: \"Component\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tagger\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/tagger\",\n                children: _jsx(InlineCode, {\n                  children: \"Tagger\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign part-of-speech-tags.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"parser\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/dependencyparser\",\n                children: _jsx(InlineCode, {\n                  children: \"DependencyParser\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign dependency labels.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ner\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entityrecognizer\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityRecognizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign named entities.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entity_linker\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entitylinker\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityLinker\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign knowledge base IDs to named entities. Should be added after the entity recognizer.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entity_ruler\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entityruler\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityRuler\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign named entities based on pattern rules and dictionaries.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"textcat\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"TextCategorizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign text categories: exactly one category is predicted per document.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"textcat_multilabel\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"MultiLabel_TextCategorizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign text categories in a multi-label setting: zero, one or more labels per document.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lemmatizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/lemmatizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Lemmatizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign base forms to words using rules and lookups.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"trainable_lemmatizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/edittreelemmatizer\",\n                children: _jsx(InlineCode, {\n                  children: \"EditTreeLemmatizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign base forms to words.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"morphologizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/morphologizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Morphologizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign morphological features and coarse-grained POS tags.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attribute_ruler\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/attributeruler\",\n                children: _jsx(InlineCode, {\n                  children: \"AttributeRuler\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign token attribute mappings and rule-based exceptions.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"senter\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/sentencerecognizer\",\n                children: _jsx(InlineCode, {\n                  children: \"SentenceRecognizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign sentence boundaries.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sentencizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/sentencizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Sentencizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Add rule-based sentence segmentation without the dependency parse.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"Tok2Vec\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign token-to-vector embeddings.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"transformer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/transformer\",\n                children: _jsx(InlineCode, {\n                  children: \"Transformer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign the tokens and outputs of a transformer model.\"\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"disabling\",\n        children: \"Disabling, excluding and modifying components \"\n      }), _jsxs(_components.p, {\n        children: [\"If you don‚Äôt need a particular component of the pipeline ‚Äì for example, the\\ntagger or the parser, you can \", _jsx(_components.strong, {\n          children: \"disable or exclude\"\n        }), \" it. This can sometimes make\\na big difference and improve loading and inference speed. There are two\\ndifferent mechanisms you can use:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Disable:\"\n          }), \" The component and its data will be loaded with the pipeline, but\\nit will be disabled by default and not run as part of the processing\\npipeline. To run it, you can explicitly enable it by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#enable_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.enable_pipe\"\n            })\n          }), \". When you save out the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \"\\nobject, the disabled component will be included but disabled by default.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Exclude:\"\n          }), \" Don‚Äôt load the component and its data with the pipeline. Once\\nthe pipeline is loaded, there will be no reference to the excluded component.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Disabled and excluded component names can be provided to\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \" as a list.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"üí° Optional pipeline components\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"disable\"\n          }), \" mechanism makes it easy to distribute pipeline packages with\\noptional components that you can enable or disable at runtime. For instance,\\nyour pipeline may include a statistical \", _jsx(_components.em, {\n            children: \"and\"\n          }), \" a rule-based component for\\nsentence segmentation, and you can choose which one to run depending on your\\nuse case.\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"For example, spaCy‚Äôs \", _jsx(_components.a, {\n            href: \"/models\",\n            children: \"trained pipelines\"\n          }), \" like\\n\", _jsx(_components.a, {\n            href: \"/models/en#en_core_web_sm\",\n            children: _jsx(InlineCode, {\n              children: \"en_core_web_sm\"\n            })\n          }), \" contain both a \", _jsx(InlineCode, {\n            children: \"parser\"\n          }), \" and\\n\", _jsx(InlineCode, {\n            children: \"senter\"\n          }), \" that perform sentence segmentation, but the \", _jsx(InlineCode, {\n            children: \"senter\"\n          }), \" is disabled by\\ndefault.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Load the pipeline without the entity recognizer\\nnlp = spacy.load(\\\"en_core_web_sm\\\", exclude=[\\\"ner\\\"])\\n\\n# Load the tagger and parser but don't enable them\\nnlp = spacy.load(\\\"en_core_web_sm\\\", disable=[\\\"tagger\\\", \\\"parser\\\"])\\n# Explicitly enable the tagger later on\\nnlp.enable_pipe(\\\"tagger\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In addition to \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"spacy.load()\"\n        }), \" also accepts \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \". If \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" is\\nset, all components except for those in \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" are disabled. If \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" conflict (i.e. the same component is included in both), an error is\\nraised.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Load the complete pipeline, but disable all components except for tok2vec and tagger\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"tok2vec\\\", \\\"tagger\\\"])\\n# Has the same effect, as NER is already not part of enabled set of components\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"tok2vec\\\", \\\"tagger\\\"], disable=[\\\"ner\\\"])\\n# Will raise an error, as the sets of enabled and disabled components are conflicting\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"ner\\\"], disable=[\\\"ner\\\"])\\n\"\n        })\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Changed in v3.0\",\n        children: _jsxs(_components.p, {\n          children: [\"As of v3.0, the \", _jsx(InlineCode, {\n            children: \"disable\"\n          }), \" keyword argument specifies components to load but\\ndisable, instead of components to not load at all. Those components can now be\\nspecified separately using the new \", _jsx(InlineCode, {\n            children: \"exclude\"\n          }), \" keyword argument.\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"As a shortcut, you can use the \", _jsx(_components.a, {\n          href: \"/api/language#select_pipes\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.select_pipes\"\n          })\n        }), \"\\ncontext manager to temporarily disable certain components for a given block. At\\nthe end of the \", _jsx(InlineCode, {\n          children: \"with\"\n        }), \" block, the disabled pipeline components will be restored\\nautomatically. Alternatively, \", _jsx(InlineCode, {\n          children: \"select_pipes\"\n        }), \" returns an object that lets you\\ncall its \", _jsx(InlineCode, {\n          children: \"restore()\"\n        }), \" method to restore the disabled components when needed. This\\ncan be useful if you want to prevent unnecessary code indentation of large\\nblocks.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Disable for block\",\n          children: \"# 1. Use as a context manager\\nwith nlp.select_pipes(disable=[\\\"tagger\\\", \\\"parser\\\", \\\"lemmatizer\\\"]):\\n    doc = nlp(\\\"I won't be tagged and parsed\\\")\\ndoc = nlp(\\\"I will be tagged and parsed\\\")\\n\\n# 2. Restore manually\\ndisabled = nlp.select_pipes(disable=\\\"ner\\\")\\ndoc = nlp(\\\"I won't have named entities\\\")\\ndisabled.restore()\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If you want to disable all pipes except for one or a few, you can use the\\n\", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" keyword. Just like the \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" keyword, it takes a list of pipe\\nnames, or a string defining just one pipe.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Enable only the parser\\nwith nlp.select_pipes(enable=\\\"parser\\\"):\\n    doc = nlp(\\\"I will only be parsed\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" method also supports a \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" keyword\\nargument if you only want to disable components during processing:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"for doc in nlp.pipe(texts, disable=[\\\"tagger\\\", \\\"parser\\\", \\\"lemmatizer\\\"]):\\n    # Do something with the doc here\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Finally, you can also use the \", _jsx(_components.a, {\n          href: \"/api/language#remove_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"remove_pipe\"\n          })\n        }), \" method\\nto remove pipeline components from an existing pipeline, the\\n\", _jsx(_components.a, {\n          href: \"/api/language#rename_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"rename_pipe\"\n          })\n        }), \" method to rename them, or the\\n\", _jsx(_components.a, {\n          href: \"/api/language#replace_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"replace_pipe\"\n          })\n        }), \" method to replace them with a\\ncustom component entirely (more details on this in the section on\\n\", _jsx(_components.a, {\n          href: \"#custom-components\",\n          children: \"custom components\"\n        }), \").\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp.remove_pipe(\\\"parser\\\")\\nnlp.rename_pipe(\\\"ner\\\", \\\"entityrecognizer\\\")\\nnlp.replace_pipe(\\\"tagger\\\", \\\"my_custom_tagger\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" object exposes different \", _jsx(_components.a, {\n          href: \"/api/language#attributes\",\n          children: \"attributes\"\n        }), \"\\nthat let you inspect all available components and the components that currently\\nrun as part of the pipeline.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"ner\\\")\\nnlp.add_pipe(\\\"textcat\\\")\\nassert nlp.pipe_names == [\\\"ner\\\", \\\"textcat\\\"]\\nnlp.disable_pipe(\\\"ner\\\")\\nassert nlp.pipe_names == [\\\"textcat\\\"]\\nassert nlp.component_names == [\\\"ner\\\", \\\"textcat\\\"]\\nassert nlp.disabled == [\\\"ner\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipeline\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"(name, component)\"\n              }), \" tuples of the processing pipeline, in order.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipe_names\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Pipeline component names, in order.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.components\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"All \", _jsx(InlineCode, {\n                children: \"(name, component)\"\n              }), \" tuples, including disabled components.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.component_names\"\n              })\n            }), _jsx(_components.td, {\n              children: \"All component names, including disabled components.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.disabled\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Names of components that are currently disabled.\"\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"sourced-components\",\n        version: \"3\",\n        children: \"Sourcing components from existing pipelines \"\n      }), _jsxs(_components.p, {\n        children: [\"Pipeline components that are independent can also be reused across pipelines.\\nInstead of adding a new blank component, you can also copy an existing component\\nfrom a trained pipeline by setting the \", _jsx(InlineCode, {\n          children: \"source\"\n        }), \" argument on\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". The first argument will then be\\ninterpreted as the name of the component in the source pipeline ‚Äì for instance,\\n\", _jsx(InlineCode, {\n          children: \"\\\"ner\\\"\"\n        }), \". This is especially useful for\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config-components\",\n          children: \"training a pipeline\"\n        }), \" because it lets you mix\\nand match components and create fully custom pipeline packages with updated\\ntrained components and new components trained on your data.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note for trained components\",\n        children: _jsxs(_components.p, {\n          children: [\"When reusing components across pipelines, keep in mind that the \", _jsx(_components.strong, {\n            children: \"vocabulary\"\n          }), \",\\n\", _jsx(_components.strong, {\n            children: \"vectors\"\n          }), \" and model settings \", _jsx(_components.strong, {\n            children: \"must match\"\n          }), \". If a trained pipeline includes\\n\", _jsx(_components.a, {\n            href: \"/usage/linguistic-features#vectors-similarity\",\n            children: \"word vectors\"\n          }), \" and the component\\nuses them as features, the pipeline you copy it to needs to have the \", _jsx(_components.em, {\n            children: \"same\"\n          }), \"\\nvectors available ‚Äì otherwise, it won‚Äôt be able to make the same predictions.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"In training config\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"Instead of providing a \", _jsx(InlineCode, {\n            children: \"factory\"\n          }), \", component blocks in the training\\n\", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"config\"\n          }), \" can also define a \", _jsx(InlineCode, {\n            children: \"source\"\n          }), \". The string needs\\nto be a loadable spaCy pipeline package or path.\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.ner]\\nsource = \\\"en_core_web_sm\\\"\\ncomponent = \\\"ner\\\"\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"By default, sourced components will be updated with your data during training.\\nIf you want to preserve the component as-is, you can ‚Äúfreeze‚Äù it if the\\npipeline is not using a shared \", _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          }), \" layer:\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[training]\\nfrozen_components = [\\\"ner\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\n# The source pipeline with different components\\nsource_nlp = spacy.load(\\\"en_core_web_sm\\\")\\nprint(source_nlp.pipe_names)\\n\\n# Add only the entity recognizer to the new blank pipeline\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"ner\\\", source=source_nlp)\\nprint(nlp.pipe_names)\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"analysis\",\n        version: \"3\",\n        children: \"Analyzing pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#analyze_pipes\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.analyze_pipes\"\n          })\n        }), \" method analyzes the\\ncomponents in the current pipeline and outputs information about them like the\\nattributes they set on the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \", whether\\nthey retokenize the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and which scores they produce during training. It will\\nalso show warnings if components require values that aren‚Äôt set by previous\\ncomponent ‚Äì for instance, if the entity linker is used but no component that\\nruns before it sets named entities. Setting \", _jsx(InlineCode, {\n          children: \"pretty=True\"\n        }), \" will pretty-print a\\ntable instead of only returning the structured data.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Add the components \", _jsx(InlineCode, {\n              children: \"\\\"ner\\\"\"\n            }), \" and \", _jsx(InlineCode, {\n              children: \"\\\"sentencizer\\\"\"\n            }), \" \", _jsx(_components.em, {\n              children: \"before\"\n            }), \" the\\n\", _jsx(InlineCode, {\n              children: \"\\\"entity_linker\\\"\"\n            }), \". The analysis should now show no problems, because\\nrequirements are met.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"tagger\\\")\\n# This is a problem because it needs entities and sentence boundaries\\nnlp.add_pipe(\\\"entity_linker\\\")\\nanalysis = nlp.analyze_pipes(pretty=True)\\n\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"Example output\",\n        children: [_jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            title: \"Structured\",\n            children: \"{\\n  \\\"summary\\\": {\\n    \\\"tagger\\\": {\\n      \\\"assigns\\\": [\\\"token.tag\\\"],\\n      \\\"requires\\\": [],\\n      \\\"scores\\\": [\\\"tag_acc\\\", \\\"pos_acc\\\", \\\"lemma_acc\\\"],\\n      \\\"retokenizes\\\": false\\n    },\\n    \\\"entity_linker\\\": {\\n      \\\"assigns\\\": [\\\"token.ent_kb_id\\\"],\\n      \\\"requires\\\": [\\\"doc.ents\\\", \\\"doc.sents\\\", \\\"token.ent_iob\\\", \\\"token.ent_type\\\"],\\n      \\\"scores\\\": [],\\n      \\\"retokenizes\\\": false\\n    }\\n  },\\n  \\\"problems\\\": {\\n    \\\"tagger\\\": [],\\n    \\\"entity_linker\\\": [\\n      \\\"doc.ents\\\",\\n      \\\"doc.sents\\\",\\n      \\\"token.ent_iob\\\",\\n      \\\"token.ent_type\\\"\\n    ]\\n  },\\n  \\\"attrs\\\": {\\n    \\\"token.ent_iob\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"doc.ents\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"token.ent_kb_id\\\": { \\\"assigns\\\": [\\\"entity_linker\\\"], \\\"requires\\\": [] },\\n    \\\"doc.sents\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"token.tag\\\": { \\\"assigns\\\": [\\\"tagger\\\"], \\\"requires\\\": [] },\\n    \\\"token.ent_type\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] }\\n  }\\n}\\n\"\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            lang: \"none\",\n            title: \"Pretty\",\n            children: \"============================= Pipeline Overview =============================\\n\\n#   Component       Assigns           Requires         Scores        Retokenizes\\n-   -------------   ---------------   --------------   -----------   -----------\\n0   tagger          token.tag                          tag_acc       False\\n\\n1   entity_linker   token.ent_kb_id   doc.ents         nel_micro_f   False\\n                                      doc.sents        nel_micro_r\\n                                      token.ent_iob    nel_micro_p\\n                                      token.ent_type\\n\\n\\n================================ Problems (4) ================================\\n‚ö† 'entity_linker' requirements not met: doc.ents, doc.sents,\\ntoken.ent_iob, token.ent_type\\n\"\n          })\n        })]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note\",\n        children: _jsxs(_components.p, {\n          children: [\"The pipeline analysis is static and does \", _jsx(_components.strong, {\n            children: \"not actually run the components\"\n          }), \".\\nThis means that it relies on the information provided by the components\\nthemselves. If a custom component declares that it assigns an attribute but it\\ndoesn‚Äôt, the pipeline analysis won‚Äôt catch that.\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-custom-components\",\n      children: [_jsx(_components.h2, {\n        id: \"custom-components\",\n        children: \"Creating custom pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"A pipeline component is a function that receives a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object, modifies it and\\nreturns it ‚Äì for example, by using the current weights to make a prediction and\\nset some annotation on the document. By adding a component to the pipeline,\\nyou‚Äôll get access to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" at any point \", _jsx(_components.strong, {\n          children: \"during processing\"\n        }), \" ‚Äì instead of\\nonly being able to modify it afterwards.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.language import Language\\n\\n@Language.component(\\\"my_component\\\")\\ndef my_component(doc):\\n   # Do something to the doc here\\n   return doc\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Type\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object processed by the previous component.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object processed by this pipeline component.\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#component\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.component\"\n          })\n        }), \" decorator lets you turn a\\nsimple function into a pipeline component. It takes at least one argument, the\\n\", _jsx(_components.strong, {\n          children: \"name\"\n        }), \" of the component factory. You can use this name to add an instance of\\nyour component to the pipeline. It can also be listed in your pipeline config,\\nso you can save, load and train pipelines using your component.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Custom components can be added to the pipeline using the\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"add_pipe\"\n          })\n        }), \" method. Optionally, you can either specify\\na component to add it \", _jsx(_components.strong, {\n          children: \"before or after\"\n        }), \", tell spaCy to add it \", _jsx(_components.strong, {\n          children: \"first or\\nlast\"\n        }), \" in the pipeline, or define a \", _jsx(_components.strong, {\n          children: \"custom name\"\n        }), \". If no name is set and no\\n\", _jsx(InlineCode, {\n          children: \"name\"\n        }), \" attribute is present on your component, the function name is used.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp.add_pipe(\\\"my_component\\\")\\nnlp.add_pipe(\\\"my_component\\\", first=True)\\nnlp.add_pipe(\\\"my_component\\\", before=\\\"parser\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"last\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", component is added \", _jsx(_components.strong, {\n                children: \"last\"\n              }), \" in the pipeline (default). \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"first\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", component is added \", _jsx(_components.strong, {\n                children: \"first\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"before\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name or index to add the new component \", _jsx(_components.strong, {\n                children: \"before\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[str, int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"after\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name or index to add the new component \", _jsx(_components.strong, {\n                children: \"after\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[str, int]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"As of v3.0, components need to be registered using the\\n\", _jsx(_components.a, {\n            href: \"/api/language#component\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.component\"\n            })\n          }), \" or\\n\", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" decorator so spaCy knows that a\\nfunction is a component. \", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            })\n          }), \" now takes the\\n\", _jsx(_components.strong, {\n            children: \"string name\"\n          }), \" of the component factory instead of the component function. This\\ndoesn‚Äôt only save you lines of code, it also allows spaCy to validate and track\\nyour custom components, and make sure they can be saved and loaded.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"- ruler = nlp.create_pipe(\\\"entity_ruler\\\")\\n- nlp.add_pipe(ruler)\\n+ ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\n\"\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-simple\",\n        children: \"Examples: Simple stateless pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"The following component receives the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in the pipeline and prints some\\ninformation about it: the number of tokens, the part-of-speech tags of the\\ntokens and a conditional message based on the document length. The\\n\", _jsx(_components.a, {\n          href: \"/api/language#component\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.component\"\n          })\n        }), \" decorator lets you register the\\ncomponent under the name \", _jsx(InlineCode, {\n          children: \"\\\"info_component\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Add the component first in the pipeline by setting \", _jsx(InlineCode, {\n              children: \"first=True\"\n            }), \". You‚Äôll see\\nthat the part-of-speech tags are empty, because the component now runs\\nbefore the tagger and the tags aren‚Äôt available yet.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the component \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" or remove the \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" argument. You should see\\nthis change reflected in \", _jsx(InlineCode, {\n              children: \"nlp.pipe_names\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Print \", _jsx(InlineCode, {\n              children: \"nlp.pipeline\"\n            }), \". You‚Äôll see a list of tuples describing the component\\nname and the function that‚Äôs called on the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" object in the pipeline.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the first argument to \", _jsx(InlineCode, {\n              children: \"@Language.component\"\n            }), \", the name, to something\\nelse. spaCy should now complain that it doesn‚Äôt know a component of the\\nname \", _jsx(InlineCode, {\n              children: \"\\\"info_component\\\"\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"info_component\\\")\\ndef my_component(doc):\\n    print(f\\\"After tokenization, this doc has {len(doc)} tokens.\\\")\\n    print(\\\"The part-of-speech tags are:\\\", [token.pos_ for token in doc])\\n    if len(doc) < 10:\\n        print(\\\"This is a pretty short document.\\\")\\n    return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"info_component\\\", name=\\\"print_info\\\", last=True)\\nprint(nlp.pipe_names)  # ['tagger', 'parser', 'ner', 'print_info']\\ndoc = nlp(\\\"This is a sentence.\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Here‚Äôs another example of a pipeline component that implements custom logic to\\nimprove the sentence boundaries set by the dependency parser. The custom logic\\nshould therefore be applied \", _jsx(_components.strong, {\n          children: \"after\"\n        }), \" tokenization, but \", _jsx(_components.em, {\n          children: \"before\"\n        }), \" the dependency\\nparsing ‚Äì this way, the parser can also take advantage of the sentence\\nboundaries.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Print \", _jsx(InlineCode, {\n              children: \"[token.dep_ for token in doc]\"\n            }), \" with and without the custom pipeline\\ncomponent. You‚Äôll see that the predicted dependency parse changes to match\\nthe sentence boundaries.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Remove the \", _jsx(InlineCode, {\n              children: \"else\"\n            }), \" block. All other tokens will now have \", _jsx(InlineCode, {\n              children: \"is_sent_start\"\n            }), \" set\\nto \", _jsx(InlineCode, {\n              children: \"None\"\n            }), \" (missing value), the parser will assign sentence boundaries in\\nbetween.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"custom_sentencizer\\\")\\ndef custom_sentencizer(doc):\\n    for i, token in enumerate(doc[:-2]):\\n        # Define sentence start if pipe + titlecase token\\n        if token.text == \\\"|\\\" and doc[i + 1].is_title:\\n            doc[i + 1].is_sent_start = True\\n        else:\\n            # Explicitly set sentence start to False otherwise, to tell\\n            # the parser to leave those tokens alone\\n            doc[i + 1].is_sent_start = False\\n    return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"custom_sentencizer\\\", before=\\\"parser\\\")  # Insert before the parser\\ndoc = nlp(\\\"This is. A sentence. | This is. Another sentence.\\\")\\nfor sent in doc.sents:\\n    print(sent.text)\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"custom-components-factories\",\n        children: \"Component factories and stateful components \"\n      }), _jsxs(_components.p, {\n        children: [\"Component factories are callables that take settings and return a \", _jsx(_components.strong, {\n          children: \"pipeline\\ncomponent function\"\n        }), \". This is useful if your component is stateful and if you\\nneed to customize their creation, or if you need access to the current \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\nobject or the shared vocab. Component factories can be registered using the\\n\", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \" decorator and they need at least\\n\", _jsx(_components.strong, {\n          children: \"two named arguments\"\n        }), \" that are filled in automatically when the component is\\nadded to the pipeline:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.language import Language\\n\\n@Language.factory(\\\"my_component\\\")\\ndef my_component(nlp, name):\\n    return MyComponent()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Can be used to access the shared vocab. \", _jsx(_components.del, {\n                children: \"Language\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.strong, {\n                children: \"instance name\"\n              }), \" of the component in the pipeline. This lets you identify different instances of the same component. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"All other settings can be passed in by the user via the \", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on\\n\", _jsx(_components.a, {\n          href: \"/api/language\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". The\\n\", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \" decorator also lets you define a\\n\", _jsx(InlineCode, {\n          children: \"default_config\"\n        }), \" that‚Äôs used as a fallback.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"With config\",\n          highlight: \"4,9\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.factory(\\\"my_component\\\", default_config={\\\"some_setting\\\": True})\\ndef my_component(nlp, name, some_setting: bool):\\n    return MyComponent(some_setting=some_setting)\\n\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"my_component\\\", config={\\\"some_setting\\\": False})\\n\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"How is @Language.factory different from @Language.component?\",\n        id: \"factories-decorator-component\",\n        children: [_jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/language#component\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.component\"\n            })\n          }), \" decorator is essentially a\\n\", _jsx(_components.strong, {\n            children: \"shortcut\"\n          }), \" for stateless pipeline components that don‚Äôt need any settings.\\nThis means you don‚Äôt have to always write a function that returns your function\\nif there‚Äôs no state to be passed through ‚Äì spaCy can just take care of this for\\nyou. The following two code examples are equivalent:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Stateless component with @Language.factory\\n@Language.factory(\\\"my_component\\\")\\ndef create_my_component():\\n    def my_component(doc):\\n        # Do something to the doc\\n        return doc\\n\\n    return my_component\\n\\n# Stateless component with @Language.component\\n@Language.component(\\\"my_component\\\")\\ndef my_component(doc):\\n    # Do something to the doc\\n    return doc\\n\"\n          })\n        })]\n      }), _jsx(Accordion, {\n        title: \"Can I add the @Language.factory decorator to a class?\",\n        id: \"factories-class-decorator\",\n        spaced: true,\n        children: _jsxs(_components.p, {\n          children: [\"Yes, the \", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" decorator can be added to\\na function or a class. If it‚Äôs added to a class, it expects the \", _jsx(InlineCode, {\n            children: \"__init__\"\n          }), \"\\nmethod to take the arguments \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"name\"\n          }), \", and will populate all other\\narguments from the config. That said, it‚Äôs often cleaner and more intuitive to\\nmake your factory a separate function. That‚Äôs also how spaCy does it internally.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"factories-language\",\n        version: \"3\",\n        children: \"Language-specific factories \"\n      }), _jsxs(_components.p, {\n        children: [\"There are many use cases where you might want your pipeline components to be\\nlanguage-specific. Sometimes this requires entirely different implementation per\\nlanguage, sometimes the only difference is in the settings or data. spaCy allows\\nyou to register factories of the \", _jsx(_components.strong, {\n          children: \"same name\"\n        }), \" on both the \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" base\\nclass, as well as its \", _jsx(_components.strong, {\n          children: \"subclasses\"\n        }), \" like \", _jsx(InlineCode, {\n          children: \"English\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"German\"\n        }), \". Factories are\\nresolved starting with the specific subclass. If the subclass doesn‚Äôt define a\\ncomponent of that name, spaCy will check the \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" base class.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Here‚Äôs an example of a pipeline component that overwrites the normalized form of\\na token, the \", _jsx(InlineCode, {\n          children: \"Token.norm_\"\n        }), \" with an entry from a language-specific lookup table.\\nIt‚Äôs registered twice under the name \", _jsx(InlineCode, {\n          children: \"\\\"token_normalizer\\\"\"\n        }), \" ‚Äì once using\\n\", _jsx(InlineCode, {\n          children: \"@English.factory\"\n        }), \" and once using \", _jsx(InlineCode, {\n          children: \"@German.factory\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"from spacy.lang.en import English\\nfrom spacy.lang.de import German\\n\\nclass TokenNormalizer:\\n    def __init__(self, norm_table):\\n        self.norm_table = norm_table\\n\\n    def __call__(self, doc):\\n        for token in doc:\\n            # Overwrite the token.norm_ if there's an entry in the data\\n            token.norm_ = self.norm_table.get(token.text, token.norm_)\\n        return doc\\n\\n@English.factory(\\\"token_normalizer\\\")\\ndef create_en_normalizer(nlp, name):\\n    return TokenNormalizer({\\\"realise\\\": \\\"realize\\\", \\\"colour\\\": \\\"color\\\"})\\n\\n@German.factory(\\\"token_normalizer\\\")\\ndef create_de_normalizer(nlp, name):\\n    return TokenNormalizer({\\\"da√ü\\\": \\\"dass\\\", \\\"wu√üte\\\": \\\"wusste\\\"})\\n\\nnlp_en = English()\\nnlp_en.add_pipe(\\\"token_normalizer\\\")  # uses the English factory\\nprint([token.norm_ for token in nlp_en(\\\"realise colour da√ü wu√üte\\\")])\\n\\nnlp_de = German()\\nnlp_de.add_pipe(\\\"token_normalizer\\\")  # uses the German factory\\nprint([token.norm_ for token in nlp_de(\\\"realise colour da√ü wu√üte\\\")])\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Implementation details\",\n        children: _jsxs(_components.p, {\n          children: [\"Under the hood, language-specific factories are added to the\\n\", _jsxs(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: [_jsx(InlineCode, {\n              children: \"factories\"\n            }), \" registry\"]\n          }), \" prefixed with the language code,\\ne.g. \", _jsx(InlineCode, {\n            children: \"\\\"en.token_normalizer\\\"\"\n          }), \". When resolving the factory in\\n\", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            })\n          }), \", spaCy first checks for a\\nlanguage-specific version of the factory using \", _jsx(InlineCode, {\n            children: \"nlp.lang\"\n          }), \" and if none is\\navailable, falls back to looking up the regular factory name.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"example-stateful-components\",\n        children: \"Example: Stateful component with settings \"\n      }), _jsxs(_components.p, {\n        children: [\"This example shows a \", _jsx(_components.strong, {\n          children: \"stateful\"\n        }), \" pipeline component for handling acronyms:\\nbased on a dictionary, it will detect acronyms and their expanded forms in both\\ndirections and add them to a list as the custom \", _jsx(InlineCode, {\n          children: \"doc._.acronyms\"\n        }), \"\\n\", _jsx(_components.a, {\n          href: \"#custom-components-attributes\",\n          children: \"extension attribute\"\n        }), \". Under the hood, it uses\\nthe \", _jsx(_components.a, {\n          href: \"/api/phrasematcher\",\n          children: _jsx(InlineCode, {\n            children: \"PhraseMatcher\"\n          })\n        }), \" to find instances of the phrases.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The factory function takes three arguments: the shared \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object and\\ncomponent instance \", _jsx(InlineCode, {\n          children: \"name\"\n        }), \", which are passed in automatically by spaCy, and a\\n\", _jsx(InlineCode, {\n          children: \"case_sensitive\"\n        }), \" config setting that makes the matching and acronym detection\\ncase-sensitive.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" and set \", _jsx(InlineCode, {\n              children: \"\\\"case_sensitive\\\"\"\n            }), \" to\\n\", _jsx(InlineCode, {\n              children: \"True\"\n            }), \". You should see that the expanded acronym for ‚ÄúLOL‚Äù isn‚Äôt detected\\nanymore.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Add some more terms to the \", _jsx(InlineCode, {\n              children: \"DICTIONARY\"\n            }), \" and update the processed text so\\nthey‚Äôre detected.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Add a \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" argument to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" to change the component name. Print\\n\", _jsx(InlineCode, {\n              children: \"nlp.pipe_names\"\n            }), \" to see the change reflected in the pipeline.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Print the config of the current \", _jsx(InlineCode, {\n              children: \"nlp\"\n            }), \" object with\\n\", _jsx(InlineCode, {\n              children: \"print(nlp.config.to_str())\"\n            }), \" and inspect the \", _jsx(InlineCode, {\n              children: \"[components]\"\n            }), \" block. You\\nshould see an entry for the acronyms component, referencing the factory\\n\", _jsx(InlineCode, {\n              children: \"acronyms\"\n            }), \" and the config settings.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"from spacy.language import Language\\nfrom spacy.tokens import Doc\\nfrom spacy.matcher import PhraseMatcher\\nimport spacy\\n\\nDICTIONARY = {\\\"lol\\\": \\\"laughing out loud\\\", \\\"brb\\\": \\\"be right back\\\"}\\nDICTIONARY.update({value: key for key, value in DICTIONARY.items()})\\n\\n@Language.factory(\\\"acronyms\\\", default_config={\\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, case_sensitive: bool):\\n    return AcronymComponent(nlp, case_sensitive)\\n\\nclass AcronymComponent:\\n    def __init__(self, nlp: Language, case_sensitive: bool):\\n        # Create the matcher and match on Token.lower if case-insensitive\\n        matcher_attr = \\\"TEXT\\\" if case_sensitive else \\\"LOWER\\\"\\n        self.matcher = PhraseMatcher(nlp.vocab, attr=matcher_attr)\\n        self.matcher.add(\\\"ACRONYMS\\\", [nlp.make_doc(term) for term in DICTIONARY])\\n        self.case_sensitive = case_sensitive\\n        # Register custom extension on the Doc\\n        if not Doc.has_extension(\\\"acronyms\\\"):\\n            Doc.set_extension(\\\"acronyms\\\", default=[])\\n\\n    def __call__(self, doc: Doc) -> Doc:\\n        # Add the matched spans when doc is processed\\n        for _, start, end in self.matcher(doc):\\n            span = doc[start:end]\\n            acronym = DICTIONARY.get(span.text if self.case_sensitive else span.text.lower())\\n            doc._.acronyms.append((span, acronym))\\n        return doc\\n\\n# Add the component to the pipeline and configure it\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"acronyms\\\", config={\\\"case_sensitive\\\": False})\\n\\n# Process a doc and see the results\\ndoc = nlp(\\\"LOL, be right back\\\")\\nprint(doc._.acronyms)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-component-data\",\n      children: [_jsx(_components.h2, {\n        id: \"component-data\",\n        children: \"Initializing and serializing component data \"\n      }), _jsxs(_components.p, {\n        children: [\"Many stateful components depend on \", _jsx(_components.strong, {\n          children: \"data resources\"\n        }), \" like dictionaries and\\nlookup tables that should ideally be \", _jsx(_components.strong, {\n          children: \"configurable\"\n        }), \". For example, it makes\\nsense to make the \", _jsx(InlineCode, {\n          children: \"DICTIONARY\"\n        }), \" in the above example an argument of the\\nregistered function, so the \", _jsx(InlineCode, {\n          children: \"AcronymComponent\"\n        }), \" can be re-used with different\\ndata. One logical solution would be to make it an argument of the component\\nfactory, and allow it to be initialized with different dictionaries.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.acronyms.data]\\n# üö® Problem: you don't want the data in the config\\nlol = \\\"laugh out loud\\\"\\nbrb = \\\"be right back\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"@Language.factory(\\\"acronyms\\\", default_config={\\\"data\\\": {}, \\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, data: Dict[str, str], case_sensitive: bool):\\n    # üö® Problem: data ends up in the config file\\n    return AcronymComponent(nlp, data, case_sensitive)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"However, passing in the dictionary directly is problematic, because it means\\nthat if a component saves out its config and settings, the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \" will include a dump of the entire data,\\nsince that‚Äôs the config the component was created with. It will also fail if the\\ndata is not JSON-serializable.\"]\n      }), _jsx(_components.h3, {\n        id: \"component-data-function\",\n        children: \"Option 1: Using a registered function \"\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"‚úÖ \", _jsx(_components.strong, {\n              children: \"Pros:\"\n            }), \" can load anything in Python, easy to add to and configure via\\nconfig\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"‚ùå \", _jsx(_components.strong, {\n              children: \"Cons:\"\n            }), \" requires the function and its dependencies to be available at\\nruntime\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If what you‚Äôre passing in isn‚Äôt JSON-serializable ‚Äì e.g. a custom object like a\\n\", _jsx(_components.a, {\n          href: \"#trainable-components\",\n          children: \"model\"\n        }), \" ‚Äì saving out the component config becomes\\nimpossible because there‚Äôs no way for spaCy to know \", _jsx(_components.em, {\n          children: \"how\"\n        }), \" that object was\\ncreated, and what to do to create it again. This makes it much harder to save,\\nload and train custom pipelines with custom components. A simple solution is to\\n\", _jsx(_components.strong, {\n          children: \"register a function\"\n        }), \" that returns your resources. The\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: \"registry\"\n        }), \" lets you \", _jsx(_components.strong, {\n          children: \"map string names to functions\"\n        }), \"\\nthat create objects, so given a name and optional arguments, spaCy will know how\\nto recreate the object. To register a function that returns your custom\\ndictionary, you can use the \", _jsx(InlineCode, {\n          children: \"@spacy.registry.misc\"\n        }), \" decorator with a single\\nargument, the name:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"What‚Äôs the misc registry?\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: _jsx(InlineCode, {\n              children: \"registry\"\n            })\n          }), \" provides different categories for\\ndifferent types of functions ‚Äì for example, model architectures, tokenizers or\\nbatchers. \", _jsx(InlineCode, {\n            children: \"misc\"\n          }), \" is intended for miscellaneous functions that don‚Äôt fit\\nanywhere else.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Registered function for assets\",\n          highlight: \"1\",\n          children: \"@spacy.registry.misc(\\\"acronyms.slang_dict.v1\\\")\\ndef create_acronyms_slang_dict():\\n    dictionary = {\\\"lol\\\": \\\"laughing out loud\\\", \\\"brb\\\": \\\"be right back\\\"}\\n    dictionary.update({value: key for key, value in dictionary.items()})\\n    return dictionary\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In your \", _jsx(InlineCode, {\n          children: \"default_config\"\n        }), \" (and later in your\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"training config\"\n        }), \"), you can now refer to the function\\nregistered under the name \", _jsx(InlineCode, {\n          children: \"\\\"acronyms.slang_dict.v1\\\"\"\n        }), \" using the \", _jsx(InlineCode, {\n          children: \"@misc\"\n        }), \" key. This\\ntells spaCy how to create the value, and when your component is created, the\\nresult of the registered function is passed in as the key \", _jsx(InlineCode, {\n          children: \"\\\"dictionary\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.acronyms]\\nfactory = \\\"acronyms\\\"\\n\\n[components.acronyms.data]\\n@misc = \\\"acronyms.slang_dict.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"- default_config = {\\\"dictionary:\\\" DICTIONARY}\\n+ default_config = {\\\"dictionary\\\": {\\\"@misc\\\": \\\"acronyms.slang_dict.v1\\\"}}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Using a registered function also means that you can easily include your custom\\ncomponents in pipelines that you \", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"train\"\n        }), \". To make sure spaCy\\nknows where to find your custom \", _jsx(InlineCode, {\n          children: \"@misc\"\n        }), \" function, you can pass in a Python file\\nvia the argument \", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \". If someone else is using your component, all they\\nhave to do to customize the data is to register their own function and swap out\\nthe name. Registered functions can also take \", _jsx(_components.strong, {\n          children: \"arguments\"\n        }), \", by the way, that can\\nbe defined in the config as well ‚Äì you can read more about this in the docs on\\n\", _jsx(_components.a, {\n          href: \"/usage/training#custom-code\",\n          children: \"training with custom code\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"component-data-initialization\",\n        children: \"Option 2: Save data with the pipeline and load it in once on initialization \"\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"‚úÖ \", _jsx(_components.strong, {\n              children: \"Pros:\"\n            }), \" lets components save and load their own data and reflect user\\nchanges, load in data assets before training without depending on them at\\nruntime\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"‚ùå \", _jsx(_components.strong, {\n              children: \"Cons:\"\n            }), \" requires more component methods, more complex config and data\\nflow\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Just like models save out their binary weights when you call\\n\", _jsx(_components.a, {\n          href: \"/api/language#to_disk\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.to_disk\"\n          })\n        }), \", components can also \", _jsx(_components.strong, {\n          children: \"serialize\"\n        }), \" any\\nother data assets ‚Äì for instance, an acronym dictionary. If a pipeline component\\nimplements its own \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" methods, those will be called\\nautomatically by \", _jsx(InlineCode, {\n          children: \"nlp.to_disk\"\n        }), \" and will receive the path to the directory to\\nsave to or load from. The component can then perform any custom saving or\\nloading. If a user makes changes to the component data, they will be reflected\\nwhen the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is saved. For more examples of this, see the usage guide\\non \", _jsx(_components.a, {\n          href: \"/usage/saving-loading/#serialization-methods\",\n          children: \"serialization methods\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"About the data path\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"path\"\n          }), \" argument spaCy passes to the serialization methods consists of the\\npath provided by the user, plus a directory of the component name. This means\\nthat when you call \", _jsx(InlineCode, {\n            children: \"nlp.to_disk(\\\"/path\\\")\"\n          }), \", the \", _jsx(InlineCode, {\n            children: \"acronyms\"\n          }), \" component will\\nreceive the directory path \", _jsx(InlineCode, {\n            children: \"/path/acronyms\"\n          }), \" and can then create files in this\\ndirectory.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Custom serialization methods\",\n          highlight: \"7-11,13-15\",\n          children: \"import srsly\\nfrom spacy.util import ensure_path\\n\\nclass AcronymComponent:\\n    # other methods here...\\n\\n    def to_disk(self, path, exclude=tuple()):\\n        path = ensure_path(path)\\n        if not path.exists():\\n            path.mkdir()\\n        srsly.write_json(path / \\\"data.json\\\", self.data)\\n\\n    def from_disk(self, path, exclude=tuple()):\\n        self.data = srsly.read_json(path / \\\"data.json\\\")\\n        return self\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Now the component can save to and load from a directory. The only remaining\\nquestion: How do you \", _jsx(_components.strong, {\n          children: \"load in the initial data\"\n        }), \"? In Python, you could just\\ncall the pipe‚Äôs \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method yourself. But if you‚Äôre adding the component\\nto your \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"training config\"\n        }), \", spaCy will need to know how\\nto set it up, from start to finish, including the data to initialize it with.\"]\n      }), _jsxs(_components.p, {\n        children: [\"While you could use a registered function or a file loader like\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#file_readers\",\n          children: _jsx(InlineCode, {\n            children: \"srsly.read_json.v1\"\n          })\n        }), \" as an argument of the\\ncomponent factory, this approach is problematic: the component factory runs\\n\", _jsx(_components.strong, {\n          children: \"every time the component is created\"\n        }), \". This means it will run when creating\\nthe \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object before training, but also every time a user loads your\\npipeline. So your runtime pipeline would either depend on a local path on your\\nfile system, or it‚Äôs loaded twice: once when the component is created, and then\\nagain when the data is by \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[components.acronyms.data]\\n# üö® Problem: Runtime pipeline depends on local path\\n@readers = \\\"srsly.read_json.v1\\\"\\npath = \\\"/path/to/slang_dict.json\\\"\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[components.acronyms.data]\\n# üö® Problem: this always runs\\n@misc = \\\"acronyms.slang_dict.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"@Language.factory(\\\"acronyms\\\", default_config={\\\"data\\\": {}, \\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, data: Dict[str, str], case_sensitive: bool):\\n    # üö® Problem: data will be loaded every time component is created\\n    return AcronymComponent(nlp, data, case_sensitive)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"To solve this, your component can implement a separate method, \", _jsx(InlineCode, {\n          children: \"initialize\"\n        }), \",\\nwhich will be called by \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" if\\navailable. This typically happens before training, but not at runtime when the\\npipeline is loaded. For more background on this, see the usage guides on the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config-lifecycle\",\n          children: \"config lifecycle\"\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/usage/training#initialization\",\n          children: \"custom initialization\"\n        }), \".\"]\n      }), _jsx(_components.img, {\n        src: \"/images/lifecycle.svg\",\n        alt: \"Illustration of pipeline lifecycle\"\n      }), _jsxs(_components.p, {\n        children: [\"A component‚Äôs \", _jsx(InlineCode, {\n          children: \"initialize\"\n        }), \" method needs to take at least \", _jsx(_components.strong, {\n          children: \"two named\\narguments\"\n        }), \": a \", _jsx(InlineCode, {\n          children: \"get_examples\"\n        }), \" callback that gives it access to the training\\nexamples, and the current \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object. This is mostly used by trainable\\ncomponents so they can initialize their models and label schemes from the data,\\nso we can ignore those arguments here. All \", _jsx(_components.strong, {\n          children: \"other arguments\"\n        }), \" on the method can\\nbe defined via the config ‚Äì in this case a dictionary \", _jsx(InlineCode, {\n          children: \"data\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[initialize.components.my_component]\\n\\n[initialize.components.my_component.data]\\n# ‚úÖ This only runs on initialization\\n@readers = \\\"srsly.read_json.v1\\\"\\npath = \\\"/path/to/slang_dict.json\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Custom initialize method\",\n          highlight: \"5-6\",\n          children: \"class AcronymComponent:\\n    def __init__(self):\\n        self.data = {}\\n\\n    def initialize(self, get_examples=None, nlp=None, data={}):\\n        self.data = data\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" runs before training (or when\\nyou call it in your own code), the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize]\"\n          })\n        }), \" block of the config is\\nloaded and used to construct the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object. The custom acronym component will\\nthen be passed the data loaded from the JSON file. After training, the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\nobject is saved to disk, which will run the component‚Äôs \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" method. When\\nthe pipeline is loaded back into spaCy later to use it, the \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method\\nwill load the data back in.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-type-hints\",\n      children: [_jsx(_components.h2, {\n        id: \"type-hints\",\n        version: \"3\",\n        children: \"Python type hints and validation \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy‚Äôs configs are powered by our machine learning library Thinc‚Äôs\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-config\",\n          children: \"configuration system\"\n        }), \", which supports\\n\", _jsx(_components.a, {\n          href: \"https://docs.python.org/3/library/typing.html\",\n          children: \"type hints\"\n        }), \" and even\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-config#advanced-types\",\n          children: \"advanced type annotations\"\n        }), \"\\nusing \", _jsx(_components.a, {\n          href: \"https://github.com/samuelcolvin/pydantic\",\n          children: _jsx(InlineCode, {\n            children: \"pydantic\"\n          })\n        }), \". If your component\\nfactory provides type hints, the values that are passed in will be \", _jsx(_components.strong, {\n          children: \"checked\\nagainst the expected types\"\n        }), \". If the value can‚Äôt be cast to an integer, spaCy\\nwill raise an error. \", _jsx(InlineCode, {\n          children: \"pydantic\"\n        }), \" also provides strict types like \", _jsx(InlineCode, {\n          children: \"StrictFloat\"\n        }), \",\\nwhich will force the value to be an integer and raise an error if it‚Äôs not ‚Äì for\\ninstance, if your config defines a float.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"If you‚Äôre not using\\n\", _jsx(_components.a, {\n            href: \"https://pydantic-docs.helpmanual.io/usage/types/#strict-types\",\n            children: \"strict types\"\n          }), \",\\nvalues that can be \", _jsx(_components.strong, {\n            children: \"cast to\"\n          }), \" the given type will still be accepted. For\\nexample, \", _jsx(InlineCode, {\n            children: \"1\"\n          }), \" can be cast to a \", _jsx(InlineCode, {\n            children: \"float\"\n          }), \" or a \", _jsx(InlineCode, {\n            children: \"bool\"\n          }), \" type, but not to a\\n\", _jsx(InlineCode, {\n            children: \"List[str]\"\n          }), \". However, if the type is\\n\", _jsx(_components.a, {\n            href: \"https://pydantic-docs.helpmanual.io/usage/types/#strict-types\",\n            children: _jsx(InlineCode, {\n              children: \"StrictFloat\"\n            })\n          }), \",\\nonly a float will be accepted.\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The following example shows a custom pipeline component for debugging. It can be\\nadded anywhere in the pipeline and logs information about the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object and\\nthe \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" that passes through. The \", _jsx(InlineCode, {\n          children: \"log_level\"\n        }), \" config setting lets the user\\ncustomize what log statements are shown ‚Äì for instance, \", _jsx(InlineCode, {\n          children: \"\\\"INFO\\\"\"\n        }), \" will show info\\nlogs and more critical logging statements, whereas \", _jsx(InlineCode, {\n          children: \"\\\"DEBUG\\\"\"\n        }), \" will show\\neverything. The value is annotated as a \", _jsx(InlineCode, {\n          children: \"StrictStr\"\n        }), \", so it will only accept a\\nstring value.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"‚úèÔ∏è Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" to use the log level \", _jsx(InlineCode, {\n              children: \"\\\"INFO\\\"\"\n            }), \".\\nYou should see that only the statement logged with \", _jsx(InlineCode, {\n              children: \"logger.info\"\n            }), \" is shown.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" so that it contains unexpected\\nvalues ‚Äì for example, a boolean instead of a string: \", _jsx(InlineCode, {\n              children: \"\\\"log_level\\\": False\"\n            }), \".\\nYou should see a validation error.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Check out the docs on \", _jsx(InlineCode, {\n              children: \"pydantic\"\n            }), \"‚Äôs\\n\", _jsx(_components.a, {\n              href: \"https://pydantic-docs.helpmanual.io/usage/types/#constrained-types\",\n              children: \"constrained types\"\n            }), \"\\nand write a type hint for \", _jsx(InlineCode, {\n              children: \"log_level\"\n            }), \" that only accepts the exact string\\nvalues \", _jsx(InlineCode, {\n              children: \"\\\"DEBUG\\\"\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"\\\"INFO\\\"\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"\\\"CRITICAL\\\"\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\nfrom spacy.tokens import Doc\\nfrom pydantic import StrictStr\\nimport logging\\n\\n@Language.factory(\\\"debug\\\", default_config={\\\"log_level\\\": \\\"DEBUG\\\"})\\nclass DebugComponent:\\n    def __init__(self, nlp: Language, name: str, log_level: StrictStr):\\n        self.logger = logging.getLogger(f\\\"spacy.{name}\\\")\\n        self.logger.setLevel(log_level)\\n        self.logger.info(f\\\"Pipeline: {nlp.pipe_names}\\\")\\n\\n    def __call__(self, doc: Doc) -> Doc:\\n        is_tagged = doc.has_annotation(\\\"TAG\\\")\\n        self.logger.debug(f\\\"Doc: {len(doc)} tokens, is tagged: {is_tagged}\\\")\\n        return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"debug\\\", config={\\\"log_level\\\": \\\"DEBUG\\\"})\\ndoc = nlp(\\\"This is a text...\\\")\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-trainable-components\",\n      children: [_jsx(_components.h2, {\n        id: \"trainable-components\",\n        version: \"3\",\n        children: \"Trainable components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy‚Äôs \", _jsx(_components.a, {\n          href: \"/api/pipe\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe\"\n          })\n        }), \" class helps you implement your own\\ntrainable components that have their own model instance, make predictions over\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects and can be updated using \", _jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \". This\\nlets you plug fully custom machine learning components into your pipeline.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/trainable_component.svg\",\n        alt: \"Illustration of Pipe methods\"\n      }), _jsx(_components.p, {\n        children: \"You‚Äôll need the following:\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Model:\"\n          }), \" A Thinc \", _jsx(_components.a, {\n            href: \"https://thinc.ai/docs/api-model\",\n            children: _jsx(InlineCode, {\n              children: \"Model\"\n            })\n          }), \" instance. This\\ncan be a model implemented in \", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#thinc\",\n            children: \"Thinc\"\n          }), \", or\\na \", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#frameworks\",\n            children: \"wrapped model\"\n          }), \" implemented in\\nPyTorch, TensorFlow, MXNet or a fully custom solution. The model must take a\\nlist of \", _jsx(_components.a, {\n            href: \"/api/doc\",\n            children: _jsx(InlineCode, {\n              children: \"Doc\"\n            })\n          }), \" objects as input and can have any type of output.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"TrainablePipe subclass:\"\n          }), \" A subclass of \", _jsx(_components.a, {\n            href: \"/api/pipe\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe\"\n            })\n          }), \" that\\nimplements at least two methods: \", _jsx(_components.a, {\n            href: \"/api/pipe#predict\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe.predict\"\n            })\n          }), \"\\nand \", _jsx(_components.a, {\n            href: \"/api/pipe#set_annotations\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe.set_annotations\"\n            })\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Component factory:\"\n          }), \" A component factory registered with\\n\", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" that takes the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object and\\ncomponent \", _jsx(InlineCode, {\n            children: \"name\"\n          }), \" and optional settings provided by the config and returns an\\ninstance of your trainable component.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.pipeline import TrainablePipe\\nfrom spacy.language import Language\\n\\nclass TrainableComponent(TrainablePipe):\\n    def predict(self, docs):\\n        ...\\n\\n    def set_annotations(self, docs, scores):\\n        ...\\n\\n@Language.factory(\\\"my_trainable_component\\\")\\ndef make_component(nlp, name, model):\\n    return TrainableComponent(nlp.vocab, model, name=name)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#predict\",\n                children: _jsx(InlineCode, {\n                  children: \"predict\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Apply the component‚Äôs model to a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects (without modifying them) and return the scores.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#set_annotations\",\n                children: _jsx(InlineCode, {\n                  children: \"set_annotations\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Modify a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects, using pre-computed scores generated by \", _jsx(InlineCode, {\n                children: \"predict\"\n              }), \".\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"By default, \", _jsx(_components.a, {\n          href: \"/api/pipe#init\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe.__init__\"\n          })\n        }), \" takes the shared vocab,\\nthe \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" and the name of the component\\ninstance in the pipeline, which you can use as a key in the losses. All other\\nkeyword arguments will become available as \", _jsx(_components.a, {\n          href: \"/api/pipe#cfg\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe.cfg\"\n          })\n        }), \"\\nand will also be serialized with the component.\"]\n      }), _jsxs(Accordion, {\n        title: \"Why components should be passed a Model instance, not create it\",\n        spaced: true,\n        children: [_jsxs(_components.p, {\n          children: [\"spaCy‚Äôs \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"config system\"\n          }), \" resolves the config describing\\nthe pipeline components and models \", _jsx(_components.strong, {\n            children: \"bottom-up\"\n          }), \". This means that it will\\n\", _jsx(_components.em, {\n            children: \"first\"\n          }), \" create a \", _jsx(InlineCode, {\n            children: \"Model\"\n          }), \" from a \", _jsx(_components.a, {\n            href: \"/api/architectures\",\n            children: \"registered architecture\"\n          }), \",\\nvalidate its arguments and \", _jsx(_components.em, {\n            children: \"then\"\n          }), \" pass the object forward to the component. This\\nmeans that the config can express very complex, nested trees of objects ‚Äì but\\nthe objects don‚Äôt have to pass the model settings all the way down to the\\ncomponents. It also makes the components more \", _jsx(_components.strong, {\n            children: \"modular\"\n          }), \" and lets you\\n\", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#swap-architectures\",\n            children: \"swap\"\n          }), \" different architectures\\nin your config, and re-use model definitions.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg (excerpt)\",\n            children: \"[components]\\n\\n[components.textcat]\\nfactory = \\\"textcat\\\"\\nlabels = []\\n\\n# This function is created and then passed to the \\\"textcat\\\" component as\\n# the argument \\\"model\\\"\\n[components.textcat.model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = true\\nngram_size = 1\\nno_output_layer = false\\n\\n[components.other_textcat]\\nfactory = \\\"textcat\\\"\\n# This references the [components.textcat.model] block above\\nmodel = ${components.textcat.model}\\nlabels = []\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"Your trainable pipeline component factories should therefore always take a\\n\", _jsx(InlineCode, {\n            children: \"model\"\n          }), \" argument instead of instantiating the\\n\", _jsx(_components.a, {\n            href: \"https://thinc.ai/docs/api-model\",\n            children: _jsx(InlineCode, {\n              children: \"Model\"\n            })\n          }), \" inside the component. To register\\ncustom architectures, you can use the\\n\", _jsx(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: _jsx(InlineCode, {\n              children: \"@spacy.registry.architectures\"\n            })\n          }), \" decorator. Also see\\nthe \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"training guide\"\n          }), \" for details.\"]\n        })]\n      }), _jsx(_components.p, {\n        children: \"For some use cases, it makes sense to also overwrite additional methods to\\ncustomize how the model is updated from examples, how it‚Äôs initialized, how the\\nloss is calculated and to add evaluation scores to the training output.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#update\",\n                children: _jsx(InlineCode, {\n                  children: \"update\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Learn from a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects containing the predictions and gold-standard annotations, and update the component‚Äôs model.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"initialize\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Initialize the model. Typically calls into \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-model#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"Model.initialize\"\n                })\n              }), \" and can be passed custom arguments via the \", _jsx(_components.a, {\n                href: \"/api/data-formats#config-initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"[initialize]\"\n                })\n              }), \" config block that are only loaded during training or when you call \", _jsx(_components.a, {\n                href: \"/api/language#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"nlp.initialize\"\n                })\n              }), \", not at runtime.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#get_loss\",\n                children: _jsx(InlineCode, {\n                  children: \"get_loss\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Return a tuple of the loss and the gradient for a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#score\",\n                children: _jsx(InlineCode, {\n                  children: \"score\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Score a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects and return a dictionary of scores. The \", _jsx(_components.a, {\n                href: \"/api/language#factory\",\n                children: _jsx(InlineCode, {\n                  children: \"@Language.factory\"\n                })\n              }), \" decorator can define the \", _jsx(InlineCode, {\n                children: \"default_score_weights\"\n              }), \" of the component to decide which keys of the scores to display during training and how they count towards the final score.\"]\n            })]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Custom trainable components and models\",\n        emoji: \"üìñ\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on how to implement your own trainable components and model\\narchitectures, and plug existing models implemented in PyTorch or TensorFlow\\ninto your spaCy pipeline, see the usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#components\",\n            children: \"layers and model architectures\"\n          }), \".\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-custom-components-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"custom-components-attributes\",\n        version: \"2\",\n        children: \"Extension attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy allows you to set any custom attributes and methods on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \"\\nand \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \", which become available as \", _jsx(InlineCode, {\n          children: \"Doc._\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span._\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token._\"\n        }), \" ‚Äì for\\nexample, \", _jsx(InlineCode, {\n          children: \"Token._.my_attr\"\n        }), \". This lets you store additional information relevant\\nto your application, add new features and functionality to spaCy, and implement\\nyour own models trained with other machine learning libraries. It also lets you\\ntake advantage of spaCy‚Äôs data structures and the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object as the ‚Äúsingle\\nsource of truth‚Äù.\"]\n      }), _jsx(Accordion, {\n        title: \"Why ._ and not just a top-level attribute?\",\n        id: \"why-dot-underscore\",\n        children: _jsxs(_components.p, {\n          children: [\"Writing to a \", _jsx(InlineCode, {\n            children: \"._\"\n          }), \" attribute instead of to the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" directly keeps a clearer\\nseparation and makes it easier to ensure backwards compatibility. For example,\\nif you‚Äôve implemented your own \", _jsx(InlineCode, {\n            children: \".coref\"\n          }), \" property and spaCy claims it one day,\\nit‚Äôll break your code. Similarly, just by looking at the code, you‚Äôll\\nimmediately know what‚Äôs built-in and what‚Äôs custom ‚Äì for example,\\n\", _jsx(InlineCode, {\n            children: \"doc.sentiment\"\n          }), \" is spaCy, while \", _jsx(InlineCode, {\n            children: \"doc._.sent_score\"\n          }), \" isn‚Äôt.\"]\n        })\n      }), _jsx(Accordion, {\n        title: \"How is the ._ implemented?\",\n        id: \"dot-underscore-implementation\",\n        children: _jsxs(_components.p, {\n          children: [\"Extension definitions ‚Äì the defaults, methods, getters and setters you pass in\\nto \", _jsx(InlineCode, {\n            children: \"set_extension\"\n          }), \" ‚Äì are stored in class attributes on the \", _jsx(InlineCode, {\n            children: \"Underscore\"\n          }), \" class.\\nIf you write to an extension attribute, e.g. \", _jsx(InlineCode, {\n            children: \"doc._.hello = True\"\n          }), \", the data is\\nstored within the \", _jsx(_components.a, {\n            href: \"/api/doc#attributes\",\n            children: _jsx(InlineCode, {\n              children: \"Doc.user_data\"\n            })\n          }), \" dictionary. To keep the\\nunderscore data separate from your other dictionary entries, the string \", _jsx(InlineCode, {\n            children: \"\\\"._.\\\"\"\n          }), \"\\nis placed before the name, in a tuple.\"]\n        })\n      }), _jsx(_components.hr, {}), _jsxs(_components.p, {\n        children: [\"There are three main types of extensions, which can be defined using the\\n\", _jsx(_components.a, {\n          href: \"/api/doc#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.set_extension\"\n          })\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"/api/span#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Span.set_extension\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/token#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Token.set_extension\"\n          })\n        }), \" methods.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      children: [_jsx(_components.h2, {\n        children: \"Description\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Attribute extensions.\"\n            }), \" Set a default value for an attribute, which can be\\noverwritten manually at any time. Attribute extensions work like ‚Äúnormal‚Äù\\nvariables and are the quickest way to store arbitrary information on a \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \",\\n\", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \".\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \" Doc.set_extension(\\\"hello\\\", default=True)\\n assert doc._.hello\\n doc._.hello = False\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Property extensions.\"\n            }), \" Define a getter and an optional setter function. If\\nno setter is provided, the extension is immutable. Since the getter and\\nsetter functions are only called when you \", _jsx(_components.em, {\n              children: \"retrieve\"\n            }), \" the attribute, you can\\nalso access values of previously added attribute extensions. For example, a\\n\", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" getter can average over \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" attributes. For \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" extensions,\\nyou‚Äôll almost always want to use a property ‚Äì otherwise, you‚Äôd have to write\\nto \", _jsx(_components.em, {\n              children: \"every possible\"\n            }), \" \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" in the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" to set up the values correctly.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \"Doc.set_extension(\\\"hello\\\", getter=get_hello_value, setter=set_hello_value)\\nassert doc._.hello\\ndoc._.hello = \\\"Hi!\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Method extensions.\"\n            }), \" Assign a function that becomes available as an object\\nmethod. Method extensions are always immutable. For more details and\\nimplementation ideas, see\\n\", _jsx(_components.a, {\n              href: \"/usage/examples#custom-components-attr-methods\",\n              children: \"these examples\"\n            }), \".\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \"Doc.set_extension(\\\"hello\\\", method=lambda doc, name: f\\\"Hi {name}!\\\")\\nassert doc._.hello(\\\"Bob\\\") == \\\"Hi Bob!\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Before you can access a custom extension, you need to register it using the\\n\", _jsx(InlineCode, {\n          children: \"set_extension\"\n        }), \" method on the object you want to add it to, e.g. the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \". Keep\\nin mind that extensions are always \", _jsx(_components.strong, {\n          children: \"added globally\"\n        }), \" and not just on a\\nparticular instance. If an attribute of the same name already exists, or if\\nyou‚Äôre trying to access an attribute that hasn‚Äôt been registered, spaCy will\\nraise an \", _jsx(InlineCode, {\n          children: \"AttributeError\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Example\",\n          children: \"from spacy.tokens import Doc, Span, Token\\n\\nfruits = [\\\"apple\\\", \\\"pear\\\", \\\"banana\\\", \\\"orange\\\", \\\"strawberry\\\"]\\nis_fruit_getter = lambda token: token.text in fruits\\nhas_fruit_getter = lambda obj: any([t.text in fruits for t in obj])\\n\\nToken.set_extension(\\\"is_fruit\\\", getter=is_fruit_getter)\\nDoc.set_extension(\\\"has_fruit\\\", getter=has_fruit_getter)\\nSpan.set_extension(\\\"has_fruit\\\", getter=has_fruit_getter)\\n\"\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Usage example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I have an apple and a melon\\\")\\nassert doc[3]._.is_fruit      # get Token attributes\\nassert not doc[0]._.is_fruit\\nassert doc._.has_fruit        # get Doc attributes\\nassert doc[1:4]._.has_fruit   # get Span attributes\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Once you‚Äôve registered your custom attribute, you can also use the built-in\\n\", _jsx(InlineCode, {\n          children: \"set\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"get\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"has\"\n        }), \" methods to modify and retrieve the attributes. This is\\nespecially useful it you want to pass in a string instead of calling\\n\", _jsx(InlineCode, {\n          children: \"doc._.my_attr\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"component-example3\",\n        children: \"Example: Pipeline component for GPE entities and country meta data via a REST API \"\n      }), _jsxs(_components.p, {\n        children: [\"This example shows the implementation of a pipeline component that fetches\\ncountry meta data via the \", _jsx(_components.a, {\n          href: \"https://restcountries.com\",\n          children: \"REST Countries API\"\n        }), \", sets\\nentity annotations for countries and sets custom attributes on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" ‚Äì for example, the capital, latitude/longitude coordinates and even the\\ncountry flag.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import requests\\nfrom spacy.lang.en import English\\nfrom spacy.language import Language\\nfrom spacy.matcher import PhraseMatcher\\nfrom spacy.tokens import Doc, Span, Token\\n\\n@Language.factory(\\\"rest_countries\\\")\\nclass RESTCountriesComponent:\\n    def __init__(self, nlp, name, label=\\\"GPE\\\"):\\n        r = requests.get(\\\"https://restcountries.com/v2/all\\\")\\n        r.raise_for_status()  # make sure requests raises an error if it fails\\n        countries = r.json()\\n        # Convert API response to dict keyed by country name for easy lookup\\n        self.countries = {c[\\\"name\\\"]: c for c in countries}\\n        self.label = label\\n        # Set up the PhraseMatcher with Doc patterns for each country name\\n        self.matcher = PhraseMatcher(nlp.vocab)\\n        self.matcher.add(\\\"COUNTRIES\\\", [nlp.make_doc(c) for c in self.countries.keys()])\\n        # Register attributes on the Span. We'll be overwriting this based on\\n        # the matches, so we're only setting a default value, not a getter.\\n        Span.set_extension(\\\"is_country\\\", default=None)\\n        Span.set_extension(\\\"country_capital\\\", default=None)\\n        Span.set_extension(\\\"country_latlng\\\", default=None)\\n        Span.set_extension(\\\"country_flag\\\", default=None)\\n        # Register attribute on Doc via a getter that checks if the Doc\\n        # contains a country entity\\n        Doc.set_extension(\\\"has_country\\\", getter=self.has_country)\\n\\n    def __call__(self, doc):\\n        spans = []  # keep the spans for later so we can merge them afterwards\\n        for _, start, end in self.matcher(doc):\\n            # Generate Span representing the entity & set label\\n            entity = Span(doc, start, end, label=self.label)\\n            # Set custom attributes on entity. Can be extended with other data\\n            # returned by the API, like currencies, country code, calling code etc.\\n            entity._.set(\\\"is_country\\\", True)\\n            entity._.set(\\\"country_capital\\\", self.countries[entity.text][\\\"capital\\\"])\\n            entity._.set(\\\"country_latlng\\\", self.countries[entity.text][\\\"latlng\\\"])\\n            entity._.set(\\\"country_flag\\\", self.countries[entity.text][\\\"flag\\\"])\\n            spans.append(entity)\\n        # Overwrite doc.ents and add entity ‚Äì be careful not to replace!\\n        doc.ents = list(doc.ents) + spans\\n        return doc  # don't forget to return the Doc!\\n\\n    def has_country(self, doc):\\n        \\\"\\\"\\\"Getter for Doc attributes. Since the getter is only called\\n        when we access the attribute, we can refer to the Span's 'is_country'\\n        attribute here, which is already set in the processing step.\\\"\\\"\\\"\\n        return any([entity._.get(\\\"is_country\\\") for entity in doc.ents])\\n\\nnlp = English()\\nnlp.add_pipe(\\\"rest_countries\\\", config={\\\"label\\\": \\\"GPE\\\"})\\ndoc = nlp(\\\"Some text about Colombia and the Czech Republic\\\")\\nprint(\\\"Pipeline\\\", nlp.pipe_names)  # pipeline contains component name\\nprint(\\\"Doc has countries\\\", doc._.has_country)  # Doc contains countries\\nfor ent in doc.ents:\\n    if ent._.is_country:\\n        print(ent.text, ent.label_, ent._.country_capital, ent._.country_latlng, ent._.country_flag)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In this case, all data can be fetched on initialization in one request. However,\\nif you‚Äôre working with text that contains incomplete country names, spelling\\nmistakes or foreign-language versions, you could also implement a\\n\", _jsx(InlineCode, {\n          children: \"like_country\"\n        }), \"-style getter function that makes a request to the search API\\nendpoint and returns the best-matching result.\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-user-hooks\",\n        children: \"User hooks \"\n      }), _jsxs(_components.p, {\n        children: [\"While it‚Äôs generally recommended to use the \", _jsx(InlineCode, {\n          children: \"Doc._\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span._\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token._\"\n        }), \"\\nproxies to add your own custom attributes, spaCy offers a few exceptions to\\nallow \", _jsx(_components.strong, {\n          children: \"customizing the built-in methods\"\n        }), \" like\\n\", _jsx(_components.a, {\n          href: \"/api/doc#similarity\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.similarity\"\n          })\n        }), \" or \", _jsx(_components.a, {\n          href: \"/api/doc#vector\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.vector\"\n          })\n        }), \" with\\nyour own hooks, which can rely on components you train yourself. For instance,\\nyou can provide your own on-the-fly sentence segmentation algorithm or document\\nsimilarity method.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Hooks let you customize some of the behaviors of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \"\\nobjects by adding a component to the pipeline. For instance, to customize the\\n\", _jsx(_components.a, {\n          href: \"/api/doc#similarity\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.similarity\"\n          })\n        }), \" method, you can add a component that\\nsets a custom function to \", _jsx(InlineCode, {\n          children: \"doc.user_hooks[\\\"similarity\\\"]\"\n        }), \". The built-in\\n\", _jsx(InlineCode, {\n          children: \"Doc.similarity\"\n        }), \" method will check the \", _jsx(InlineCode, {\n          children: \"user_hooks\"\n        }), \" dict, and delegate to your\\nfunction if you‚Äôve set one. Similar results can be achieved by setting functions\\nto \", _jsx(InlineCode, {\n          children: \"Doc.user_span_hooks\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Doc.user_token_hooks\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Implementation note\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The hooks live on the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" object because the \", _jsx(InlineCode, {\n            children: \"Span\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"Token\"\n          }), \" objects are\\ncreated lazily, and don‚Äôt own any data. They just proxy to their parent \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \".\\nThis turns out to be convenient here ‚Äì we only have to worry about installing\\nhooks in one place.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Customizes\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/doc#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#sents\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.sents\"\n                })\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_token_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/token#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#conjuncts\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.conjuncts\"\n                })\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_span_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/span#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#root\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.root\"\n                })\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Add custom similarity hooks\",\n          children: \"from spacy.language import Language\\n\\n\\nclass SimilarityModel:\\n    def __init__(self, name: str, index: int):\\n        self.name = name\\n        self.index = index\\n\\n    def __call__(self, doc):\\n        doc.user_hooks[\\\"similarity\\\"] = self.similarity\\n        doc.user_span_hooks[\\\"similarity\\\"] = self.similarity\\n        doc.user_token_hooks[\\\"similarity\\\"] = self.similarity\\n        return doc\\n\\n    def similarity(self, obj1, obj2):\\n        return obj1.vector[self.index] + obj2.vector[self.index]\\n\\n\\n@Language.factory(\\\"similarity_component\\\", default_config={\\\"index\\\": 0})\\ndef create_similarity_component(nlp, name, index: int):\\n    return SimilarityModel(name, index)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-plugins\",\n      children: [_jsx(_components.h2, {\n        id: \"plugins\",\n        children: \"Developing plugins and wrappers \"\n      }), _jsxs(_components.p, {\n        children: [\"We‚Äôre very excited about all the new possibilities for community extensions and\\nplugins in spaCy, and we can‚Äôt wait to see what you build with it! To get you\\nstarted, here are a few tips, tricks and best\\npractices.¬†\", _jsx(_components.a, {\n          href: \"/universe/?category=pipeline\",\n          children: \"See here\"\n        }), \" for examples of other spaCy\\nextensions.\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-usage-ideas\",\n        children: \"Usage ideas \"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Adding new features and hooking in models.\"\n          }), \" For example, a sentiment\\nanalysis model, or your preferred solution for lemmatization or sentiment\\nanalysis. spaCy‚Äôs built-in tagger, parser and entity recognizer respect\\nannotations that were already set on the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" in a previous step of the\\npipeline.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Integrating other libraries and APIs.\"\n          }), \" For example, your pipeline component\\ncan write additional information and data directly to the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"Token\"\n          }), \" as\\ncustom attributes, while making sure no information is lost in the process.\\nThis can be output generated by other libraries and models, or an external\\nservice with a REST API.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Debugging and logging.\"\n          }), \" For example, a component which stores and/or\\nexports relevant information about the current state of the processed\\ndocument, and insert it at any point of your pipeline.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-best-practices\",\n        children: \"Best practices \"\n      }), _jsxs(_components.p, {\n        children: [\"Extensions can claim their own \", _jsx(InlineCode, {\n          children: \"._\"\n        }), \" namespace and exist as standalone packages.\\nIf you‚Äôre developing a tool or library and want to make it easy for others to\\nuse it with spaCy and add it to their pipeline, all you have to do is expose a\\nfunction that takes a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", modifies it and returns it.\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Make sure to choose a \", _jsx(_components.strong, {\n              children: \"descriptive and specific name\"\n            }), \" for your pipeline\\ncomponent class, and set it as its \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" attribute. Avoid names that are too\\ncommon or likely to clash with built-in or a user‚Äôs other custom components.\\nWhile it‚Äôs fine to call your package \", _jsx(InlineCode, {\n              children: \"\\\"spacy_my_extension\\\"\"\n            }), \", avoid component\\nnames including \", _jsx(InlineCode, {\n              children: \"\\\"spacy\\\"\"\n            }), \", since this can easily lead to confusion.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ name = \\\"myapp_lemmatizer\\\"\\n- name = \\\"lemmatizer\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"When writing to \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" objects, \", _jsx(_components.strong, {\n              children: \"use getter functions\"\n            }), \"\\nwherever possible, and avoid setting values explicitly. Tokens and spans don‚Äôt\\nown any data themselves, and they‚Äôre implemented as C extension classes ‚Äì so\\nyou can‚Äôt usually add new attributes to them like you could with most pure\\nPython objects.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ is_fruit = lambda token: token.text in (\\\"apple\\\", \\\"orange\\\")\\n+ Token.set_extension(\\\"is_fruit\\\", getter=is_fruit)\\n\\n- token._.set_extension(\\\"is_fruit\\\", default=False)\\n- if token.text in ('\\\"apple\\\", \\\"orange\\\"):\\n-     token._.set(\\\"is_fruit\\\", True)\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Always add your custom attributes to the \", _jsx(_components.strong, {\n              children: \"global\"\n            }), \" \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \"\\nobjects, not a particular instance of them. Add the attributes \", _jsx(_components.strong, {\n              children: \"as early as\\npossible\"\n            }), \", e.g. in your extension‚Äôs \", _jsx(InlineCode, {\n              children: \"__init__\"\n            }), \" method or in the global scope\\nof your module. This means that in the case of namespace collisions, the user\\nwill see an error immediately, not just when they run their pipeline.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ from spacy.tokens import Doc\\n+ def __init__(attr=\\\"my_attr\\\"):\\n+     Doc.set_extension(attr, getter=self.get_doc_attr)\\n\\n- def __call__(doc):\\n-     doc.set_extension(\\\"my_attr\\\", getter=self.get_doc_attr)\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"If your extension is setting properties on the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \",\\ninclude an option to \", _jsx(_components.strong, {\n              children: \"let the user to change those attribute names\"\n            }), \". This\\nmakes it easier to avoid namespace collisions and accommodate users with\\ndifferent naming preferences. We recommend adding an \", _jsx(InlineCode, {\n              children: \"attrs\"\n            }), \" argument to the\\n\", _jsx(InlineCode, {\n              children: \"__init__\"\n            }), \" method of your class so you can write the names to class attributes\\nand reuse them across your component.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ Doc.set_extension(self.doc_attr, default=\\\"some value\\\")\\n- Doc.set_extension(\\\"my_doc_attr\\\", default=\\\"some value\\\")\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Ideally, extensions should be \", _jsx(_components.strong, {\n              children: \"standalone packages\"\n            }), \" with spaCy and\\noptionally, other packages specified as a dependency. They can freely assign\\nto their own \", _jsx(InlineCode, {\n              children: \"._\"\n            }), \" namespace, but should stick to that. If your extension‚Äôs\\nonly job is to provide a better \", _jsx(InlineCode, {\n              children: \".similarity\"\n            }), \" implementation, and your docs\\nstate this explicitly, there‚Äôs no problem with writing to the\\n\", _jsx(_components.a, {\n              href: \"#custom-components-user-hooks\",\n              children: _jsx(InlineCode, {\n                children: \"user_hooks\"\n              })\n            }), \" and overwriting spaCy‚Äôs built-in\\nmethod. However, a third-party extension should \", _jsx(_components.strong, {\n              children: \"never silently overwrite\\nbuilt-ins\"\n            }), \", or attributes set by other extensions.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"If you‚Äôre looking to publish a pipeline package that depends on a custom\\npipeline component, you can either \", _jsx(_components.strong, {\n              children: \"require it\"\n            }), \" in the package‚Äôs\\ndependencies, or ‚Äì if the component is specific and lightweight ‚Äì choose to\\n\", _jsx(_components.strong, {\n              children: \"ship it with your pipeline package\"\n            }), \". Just make sure the\\n\", _jsx(_components.a, {\n              href: \"/api/language#component\",\n              children: _jsx(InlineCode, {\n                children: \"@Language.component\"\n              })\n            }), \" or\\n\", _jsx(_components.a, {\n              href: \"/api/language#factory\",\n              children: _jsx(InlineCode, {\n                children: \"@Language.factory\"\n              })\n            }), \" decorator that registers the\\ncustom component runs in your package‚Äôs \", _jsx(InlineCode, {\n              children: \"__init__.py\"\n            }), \" or is exposed via an\\n\", _jsx(_components.a, {\n              href: \"/usage/saving-loading#entry-points\",\n              children: \"entry point\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Once you‚Äôre ready to share your extension with others, make sure to \", _jsx(_components.strong, {\n              children: \"add docs\\nand installation instructions\"\n            }), \" (you can always link to this page for more\\ninfo). Make it easy for others to install and use your extension, for example\\nby uploading it to \", _jsx(_components.a, {\n              href: \"https://pypi.python.org\",\n              children: \"PyPi\"\n            }), \". If you‚Äôre sharing your\\ncode on GitHub, don‚Äôt forget to tag it with\\n\", _jsx(_components.a, {\n              href: \"https://github.com/topics/spacy?o=desc&s=stars\",\n              children: _jsx(InlineCode, {\n                children: \"spacy\"\n              })\n            }), \" and\\n\", _jsx(_components.a, {\n              href: \"https://github.com/topics/spacy-extension?o=desc&s=stars\",\n              children: _jsx(InlineCode, {\n                children: \"spacy-extension\"\n              })\n            }), \"\\nto help people find it. If you post it on Twitter, feel free to tag\\n\", _jsx(_components.a, {\n              href: \"https://twitter.com/spacy_io\",\n              children: \"@spacy_io\"\n            }), \" so we can check it out.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"wrapping-models-libraries\",\n        children: \"Wrapping other models and libraries \"\n      }), _jsxs(_components.p, {\n        children: [\"Let‚Äôs say you have a custom entity recognizer that takes a list of strings and\\nreturns their \", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#accessing-ner\",\n          children: \"BILUO tags\"\n        }), \". Given an\\ninput like \", _jsx(InlineCode, {\n          children: \"[\\\"A\\\", \\\"text\\\", \\\"about\\\", \\\"Facebook\\\"]\"\n        }), \", it will predict and return\\n\", _jsx(InlineCode, {\n          children: \"[\\\"O\\\", \\\"O\\\", \\\"O\\\", \\\"U-ORG\\\"]\"\n        }), \". To integrate it into your spaCy pipeline and make it\\nadd those entities to the \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \", you can wrap it in a custom pipeline\\ncomponent function and pass it the token texts from the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object received by\\nthe component.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/top-level#biluo_tags_to_spans\",\n          children: _jsx(InlineCode, {\n            children: \"training.biluo_tags_to_spans\"\n          })\n        }), \" is very\\nhelpful here, because it takes a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object and token-based BILUO tags and\\nreturns a sequence of \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" objects in the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" with added labels. So all your\\nwrapper has to do is compute the entity spans and overwrite the \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"How the doc.ents work\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"When you add spans to the \", _jsx(InlineCode, {\n            children: \"doc.ents\"\n          }), \", spaCy will automatically resolve them\\nback to the underlying tokens and set the \", _jsx(InlineCode, {\n            children: \"Token.ent_type\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"Token.ent_iob\"\n          }), \"\\nattributes. By definition, each token can only be part of one entity, so\\noverlapping entity spans are not allowed.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"1,8-9\",\n          children: \"import your_custom_entity_recognizer\\nfrom spacy.training import biluo_tags_to_spans\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"custom_ner_wrapper\\\")\\ndef custom_ner_wrapper(doc):\\n    words = [token.text for token in doc]\\n    custom_entities = your_custom_entity_recognizer(words)\\n    doc.ents = biluo_tags_to_spans(doc, custom_entities)\\n    return doc\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"custom_ner_wrapper\"\n        }), \" can then be added to a blank pipeline using\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". You can also replace the existing\\nentity recognizer of a trained pipeline with\\n\", _jsx(_components.a, {\n          href: \"/api/language#replace_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.replace_pipe\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"Here‚Äôs another example of a custom model, \", _jsx(InlineCode, {\n          children: \"your_custom_model\"\n        }), \", that takes a list\\nof tokens and returns lists of fine-grained part-of-speech tags, coarse-grained\\npart-of-speech tags, dependency labels and head token indices. Here, we can use\\nthe \", _jsx(_components.a, {\n          href: \"/api/doc#from_array\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.from_array\"\n          })\n        }), \" to create a new \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object using\\nthose values. To create a numpy array we need integers, so we can look up the\\nstring labels in the \", _jsx(_components.a, {\n          href: \"/api/stringstore\",\n          children: _jsx(InlineCode, {\n            children: \"StringStore\"\n          })\n        }), \". The\\n\", _jsx(_components.a, {\n          href: \"/api/stringstore#add\",\n          children: _jsx(InlineCode, {\n            children: \"doc.vocab.strings.add\"\n          })\n        }), \" method comes in handy here,\\nbecause it returns the integer ID of the string \", _jsx(_components.em, {\n          children: \"and\"\n        }), \" makes sure it‚Äôs added to\\nthe vocab. This is especially important if the custom model uses a different\\nlabel scheme than spaCy‚Äôs default models.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example: spacy-stanza\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"For an example of an end-to-end wrapper for statistical tokenization, tagging\\nand parsing, check out\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-stanza\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-stanza\"\n            })\n          }), \". It uses a very\\nsimilar approach to the example in this section ‚Äì the only difference is that\\nit fully replaces the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object instead of providing a pipeline component,\\nsince it also needs to handle tokenization.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"1,11,17-19\",\n          children: \"import your_custom_model\\nfrom spacy.language import Language\\nfrom spacy.symbols import POS, TAG, DEP, HEAD\\nfrom spacy.tokens import Doc\\nimport numpy\\n\\n@Language.component(\\\"custom_model_wrapper\\\")\\ndef custom_model_wrapper(doc):\\n    words = [token.text for token in doc]\\n    spaces = [token.whitespace for token in doc]\\n    pos, tags, deps, heads = your_custom_model(words)\\n    # Convert the strings to integers and add them to the string store\\n    pos = [doc.vocab.strings.add(label) for label in pos]\\n    tags = [doc.vocab.strings.add(label) for label in tags]\\n    deps = [doc.vocab.strings.add(label) for label in deps]\\n    # Create a new Doc from a numpy array\\n    attrs = [POS, TAG, DEP, HEAD]\\n    arr = numpy.array(list(zip(pos, tags, deps, heads)), dtype=\\\"uint64\\\")\\n    new_doc = Doc(doc.vocab, words=words, spaces=spaces).from_array(attrs, arr)\\n    return new_doc\\n\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Sentence boundaries and heads\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"If you create a \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" object with dependencies and heads, spaCy is able to\\nresolve the sentence boundaries automatically. However, note that the \", _jsx(InlineCode, {\n            children: \"HEAD\"\n          }), \"\\nvalue used to construct a \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" is the token index \", _jsx(_components.strong, {\n            children: \"relative\"\n          }), \" to the current\\ntoken ‚Äì e.g. \", _jsx(InlineCode, {\n            children: \"-1\"\n          }), \" for the previous token. The CoNLL format typically annotates\\nheads as \", _jsx(InlineCode, {\n            children: \"1\"\n          }), \"-indexed absolute indices with \", _jsx(InlineCode, {\n            children: \"0\"\n          }), \" indicating the root. If that‚Äôs\\nthe case in your annotations, you need to convert them first:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"heads = [2, 0, 4, 2, 2]\\nnew_heads = [head - i - 1 if head != 0 else 0 for i, head in enumerate(heads)]\\n\"\n          })\n        })]\n      }), _jsx(Infobox, {\n        title: \"Advanced usage, serialization and entry points\",\n        emoji: \"üìñ\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on how to write and package custom components, make them\\navailable to spaCy via entry points and implement your own serialization\\nmethods, check out the usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/saving-loading\",\n            children: \"saving and loading\"\n          }), \".\"]\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Language Processing Pipelines","next":"/usage/embeddings-transformers","menu":[["Processing Text","processing"],["Pipelines & Components","pipelines"],["Custom Components","custom-components"],["Component Data","component-data"],["Type Hints & Validation","type-hints"],["Trainable Components","trainable-components"],["Extension Attributes","custom-components-attributes"],["Plugins & Wrappers","plugins"]]},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true}