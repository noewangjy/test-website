{"pageProps":{"title":"Saving and Loading","menu":[["Basics","basics"],["Serializing Docs","docs"],["Serialization Methods","serialization-methods"],["Entry Points","entry-points"],["Trained Pipelines","models"]],"slug":"/usage/saving-loading","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*## Initializing components with data {id=\"initialization\",version=\"3\"}*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Serialization101, InlineCode, Infobox, Iframe, Accordion, Project} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Iframe) _missingMdxReference(\"Iframe\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Project) _missingMdxReference(\"Project\", true);\n  if (!Serialization101) _missingMdxReference(\"Serialization101\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-basics\",\n      children: [_jsx(_components.h2, {\n        id: \"basics\",\n        hidden: \"true\",\n        children: \"Basics \"\n      }), _jsx(Serialization101, {}), _jsx(_components.h3, {\n        id: \"pipeline\",\n        children: \"Serializing the pipeline \"\n      }), _jsxs(_components.p, {\n        children: [\"When serializing the pipeline, keep in mind that this will only save out the\\n\", _jsx(_components.strong, {\n          children: \"binary data for the individual components\"\n        }), \" to allow spaCy to restore them –\\nnot the entire objects. This is a good thing, because it makes serialization\\nsafe. But it also means that you have to take care of storing the config, which\\ncontains the pipeline configuration and all the relevant settings.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Saving the meta and config\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/language#meta\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.meta\"\n            })\n          }), \" attribute is a JSON-serializable\\ndictionary and contains all pipeline meta information like the author and\\nlicense information. The \", _jsx(_components.a, {\n            href: \"/api/language#config\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.config\"\n            })\n          }), \" attribute is a\\ndictionary containing the training configuration, pipeline component factories\\nand other settings. It is saved out with a pipeline as the \", _jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Serialize\",\n          children: \"config = nlp.config\\nbytes_data = nlp.to_bytes()\\n\"\n        })\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Deserialize\",\n          children: \"lang_cls = spacy.util.get_lang_class(config[\\\"nlp\\\"][\\\"lang\\\"])\\nnlp = lang_cls.from_config(config)\\nnlp.from_bytes(bytes_data)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"This is also how spaCy does it under the hood when loading a pipeline: it loads\\nthe \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" containing the language and pipeline information, initializes\\nthe language class, creates and adds the pipeline components based on the config\\nand \", _jsx(_components.em, {\n          children: \"then\"\n        }), \" loads in the binary data. You can read more about this process\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#pipelines\",\n          children: \"here\"\n        }), \".\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-docs\",\n      children: [_jsx(_components.h2, {\n        id: \"docs\",\n        version: \"2.2\",\n        children: \"Serializing Doc objects efficiently \"\n      }), _jsxs(_components.p, {\n        children: [\"If you’re working with lots of data, you’ll probably need to pass analyses\\nbetween machines, either to use something like \", _jsx(_components.a, {\n          href: \"https://dask.org\",\n          children: \"Dask\"\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"https://spark.apache.org\",\n          children: \"Spark\"\n        }), \", or even just to save out work to disk. Often\\nit’s sufficient to use the \", _jsx(_components.a, {\n          href: \"/api/doc#to_array\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.to_array\"\n          })\n        }), \" functionality for\\nthis, and just serialize the numpy arrays – but other times you want a more\\ngeneral way to save and restore \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/docbin\",\n          children: _jsx(InlineCode, {\n            children: \"DocBin\"\n          })\n        }), \" class makes it easy to serialize and deserialize a\\ncollection of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects together, and is much more efficient than calling\\n\", _jsx(_components.a, {\n          href: \"/api/doc#to_bytes\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.to_bytes\"\n          })\n        }), \" on each individual \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object. You can\\nalso control what data gets saved, and you can merge pallets together for easy\\nmap/reduce-style processing.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"4,8,9,13,14\",\n          children: \"import spacy\\nfrom spacy.tokens import DocBin\\n\\ndoc_bin = DocBin(attrs=[\\\"LEMMA\\\", \\\"ENT_IOB\\\", \\\"ENT_TYPE\\\"], store_user_data=True)\\ntexts = [\\\"Some text\\\", \\\"Lots of texts...\\\", \\\"...\\\"]\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nfor doc in nlp.pipe(texts):\\n    doc_bin.add(doc)\\nbytes_data = doc_bin.to_bytes()\\n\\n# Deserialize later, e.g. in a new process\\nnlp = spacy.blank(\\\"en\\\")\\ndoc_bin = DocBin().from_bytes(bytes_data)\\ndocs = list(doc_bin.get_docs(nlp.vocab))\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If \", _jsx(InlineCode, {\n          children: \"store_user_data\"\n        }), \" is set to \", _jsx(InlineCode, {\n          children: \"True\"\n        }), \", the \", _jsx(InlineCode, {\n          children: \"Doc.user_data\"\n        }), \" will be serialized as\\nwell, which includes the values of\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-attributes\",\n          children: \"extension attributes\"\n        }), \"\\n(if they’re serializable with msgpack).\"]\n      }), _jsxs(Infobox, {\n        title: \"Important note on serializing extension attributes\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"Including the \", _jsx(InlineCode, {\n            children: \"Doc.user_data\"\n          }), \" and extension attributes will only serialize the\\n\", _jsx(_components.strong, {\n            children: \"values\"\n          }), \" of the attributes. To restore the values and access them via the\\n\", _jsx(InlineCode, {\n            children: \"doc._.\"\n          }), \" property, you need to register the global attribute on the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" again.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"docs = list(doc_bin.get_docs(nlp.vocab))\\nDoc.set_extension(\\\"my_custom_attr\\\", default=None)\\nprint([doc._.my_custom_attr for doc in docs])\\n\"\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"pickle\",\n        children: \"Using Pickle \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a text.\\\")\\ndata = pickle.dumps(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"When pickling spaCy’s objects like the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" or the\\n\", _jsx(_components.a, {\n          href: \"/api/entityrecognizer\",\n          children: _jsx(InlineCode, {\n            children: \"EntityRecognizer\"\n          })\n        }), \", keep in mind that they all require\\nthe shared \", _jsx(_components.a, {\n          href: \"/api/vocab\",\n          children: _jsx(InlineCode, {\n            children: \"Vocab\"\n          })\n        }), \" (which includes the string to hash mappings,\\nlabel schemes and optional vectors). This means that their pickled\\nrepresentations can become very large, especially if you have word vectors\\nloaded, because it won’t only include the object itself, but also the entire\\nshared vocab it depends on.\"]\n      }), _jsxs(_components.p, {\n        children: [\"If you need to pickle multiple objects, try to pickle them \", _jsx(_components.strong, {\n          children: \"together\"\n        }), \" instead\\nof separately. For instance, instead of pickling all pipeline components, pickle\\nthe entire pipeline once. And instead of pickling several \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects\\nseparately, pickle a list of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects. Since they all share a reference to\\nthe \", _jsx(_components.em, {\n          children: \"same\"\n        }), \" \", _jsx(InlineCode, {\n          children: \"Vocab\"\n        }), \" object, it will only be included once.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Pickling objects with shared data\",\n          highlight: \"8-9\",\n          children: \"doc1 = nlp(\\\"Hello world\\\")\\ndoc2 = nlp(\\\"This is a test\\\")\\n\\ndoc1_data = pickle.dumps(doc1)\\ndoc2_data = pickle.dumps(doc2)\\nprint(len(doc1_data) + len(doc2_data))  # 6636116 😞\\n\\ndoc_data = pickle.dumps([doc1, doc2])\\nprint(len(doc_data))  # 3319761 😃\\n\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Pickling spans and tokens\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"Pickling \", _jsx(InlineCode, {\n            children: \"Token\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"Span\"\n          }), \" objects isn’t supported. They’re only views of the\\n\", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" and can’t exist on their own. Pickling them would always mean pulling in\\nthe parent document and its vocabulary, which has practically no advantage over\\npickling the parent \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \".\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"- data = pickle.dumps(doc[10:20])\\n+ data = pickle.dumps(doc)\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"If you really only need a span – for example, a particular sentence – you can\\nuse \", _jsx(_components.a, {\n            href: \"/api/span#as_doc\",\n            children: _jsx(InlineCode, {\n              children: \"Span.as_doc\"\n            })\n          }), \" to make a copy of it and convert it to a\\n\", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" object. However, note that this will not let you recover contextual\\ninformation from \", _jsx(_components.em, {\n            children: \"outside\"\n          }), \" the span.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"+ span_doc = doc[10:20].as_doc()\\ndata = pickle.dumps(span_doc)\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-serialization-methods\",\n      children: [_jsx(_components.h2, {\n        id: \"serialization-methods\",\n        children: \"Implementing serialization methods \"\n      }), _jsxs(_components.p, {\n        children: [\"When you call \", _jsx(_components.a, {\n          href: \"/api/language#to_disk\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.to_disk\"\n          })\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"/api/language#from_disk\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.from_disk\"\n          })\n        }), \" or load a pipeline package, spaCy\\nwill iterate over the components in the pipeline, check if they expose a\\n\", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method and if so, call it with the path to the pipeline\\ndirectory plus the string name of the component. For example, if you’re calling\\n\", _jsx(InlineCode, {\n          children: \"nlp.to_disk(\\\"/path\\\")\"\n        }), \", the data for the named entity recognizer will be saved\\nin \", _jsx(InlineCode, {\n          children: \"/path/ner\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"If you’re using custom pipeline components that depend on external data – for\\nexample, model weights or terminology lists – you can take advantage of spaCy’s\\nbuilt-in component serialization by making your custom component expose its own\\n\", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"to_bytes\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"from_bytes\"\n        }), \" methods. When an \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\nobject with the component in its pipeline is saved or loaded, the component will\\nthen be able to serialize and deserialize itself.\"]\n      }), _jsx(Infobox, {\n        title: \"Custom components and data\",\n        emoji: \"📖\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on how to work with pipeline components that depend on data\\nresources and manage data loading and initialization at training and runtime,\\nsee the usage guide on initializing and serializing\\n\", _jsx(_components.a, {\n            href: \"/usage/processing-pipelines#component-data\",\n            children: \"component data\"\n          }), \".\"]\n        })\n      }), _jsx(_components.p, {\n        children: \"The following example shows a custom component that keeps arbitrary\\nJSON-serializable data, allows the user to add to that data and saves and loads\\nthe data to and from a JSON file.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Real-world example\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"To see custom serialization methods in action, check out the new\\n\", _jsx(_components.a, {\n            href: \"/api/entityruler\",\n            children: _jsx(InlineCode, {\n              children: \"EntityRuler\"\n            })\n          }), \" component and its\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/entityruler.py\",\n            children: \"source\"\n          }), \". Patterns added to the\\ncomponent will be saved to a \", _jsx(InlineCode, {\n            children: \".jsonl\"\n          }), \" file if the pipeline is serialized to\\ndisk, and to a bytestring if the pipeline is serialized to bytes. This allows\\nsaving out a pipeline with a rule-based entity recognizer and including all\\nrules \", _jsx(_components.em, {\n            children: \"with\"\n          }), \" the component data.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"16-23,25-30\",\n          children: \"import json\\nfrom spacy import Language\\nfrom spacy.util import ensure_path\\n\\n@Language.factory(\\\"my_component\\\")\\nclass CustomComponent:\\n    def __init__(self, nlp: Language, name: str = \\\"my_component\\\"):\\n        self.name = name\\n        self.data = []\\n\\n    def __call__(self, doc):\\n        # Do something to the doc here\\n        return doc\\n\\n    def add(self, data):\\n        # Add something to the component's data\\n        self.data.append(data)\\n\\n    def to_disk(self, path, exclude=tuple()):\\n        # This will receive the directory path + /my_component\\n        path = ensure_path(path)\\n        if not path.exists():\\n            path.mkdir()\\n        data_path = path / \\\"data.json\\\"\\n        with data_path.open(\\\"w\\\", encoding=\\\"utf8\\\") as f:\\n            f.write(json.dumps(self.data))\\n\\n    def from_disk(self, path, exclude=tuple()):\\n        # This will receive the directory path + /my_component\\n        data_path = path / \\\"data.json\\\"\\n        with data_path.open(\\\"r\\\", encoding=\\\"utf8\\\") as f:\\n            self.data = json.load(f)\\n        return self\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"After adding the component to the pipeline and adding some data to it, we can\\nserialize the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object to a directory, which will call the custom\\ncomponent’s \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" method.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"2-4\",\n          children: \"nlp = spacy.load(\\\"en_core_web_sm\\\")\\nmy_component = nlp.add_pipe(\\\"my_component\\\")\\nmy_component.add({\\\"hello\\\": \\\"world\\\"})\\nnlp.to_disk(\\\"/path/to/pipeline\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The contents of the directory would then look like this.\\n\", _jsx(InlineCode, {\n          children: \"CustomComponent.to_disk\"\n        }), \" converted the data to a JSON string and saved it to a\\nfile \", _jsx(InlineCode, {\n          children: \"data.json\"\n        }), \" in its subdirectory:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-yaml\",\n          lang: \"yaml\",\n          title: \"Directory structure\",\n          highlight: \"2-3\",\n          children: \"└── /path/to/pipeline\\n    ├── my_component     # data serialized by \\\"my_component\\\"\\n    │   └── data.json\\n    ├── ner              # data for \\\"ner\\\" component\\n    ├── parser           # data for \\\"parser\\\" component\\n    ├── tagger           # data for \\\"tagger\\\" component\\n    ├── vocab            # pipeline vocabulary\\n    ├── meta.json        # pipeline meta.json\\n    ├── config.cfg       # pipeline config\\n    └── tokenizer        # tokenization rules\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When you load the data back in, spaCy will call the custom component’s\\n\", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method with the given file path, and the component can then load the\\ncontents of \", _jsx(InlineCode, {\n          children: \"data.json\"\n        }), \", convert them to a Python object and restore the\\ncomponent state. The same works for other types of data, of course – for\\ninstance, you could add a\\n\", _jsx(_components.a, {\n          href: \"/usage/layers-architectures#frameworks\",\n          children: \"wrapper for a model\"\n        }), \" trained with a\\ndifferent library like TensorFlow or PyTorch and make spaCy load its weights\\nautomatically when you load the pipeline package.\"]\n      }), _jsx(Infobox, {\n        title: \"Important note on loading custom components\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"When you load back a pipeline with custom components, make sure that the\\ncomponents are \", _jsx(_components.strong, {\n            children: \"available\"\n          }), \" and that the\\n\", _jsx(_components.a, {\n            href: \"/api/language#component\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.component\"\n            })\n          }), \" or\\n\", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" decorators are executed \", _jsx(_components.em, {\n            children: \"before\"\n          }), \"\\nyour pipeline is loaded back. Otherwise, spaCy won’t know how to resolve the\\nstring name of a component factory like \", _jsx(InlineCode, {\n            children: \"\\\"my_component\\\"\"\n          }), \" back to a function. For\\nmore details, see the documentation on\\n\", _jsx(_components.a, {\n            href: \"/usage/processing-pipelines#custom-components-factories\",\n            children: \"adding factories\"\n          }), \" or\\nuse \", _jsx(_components.a, {\n            href: \"#entry-points\",\n            children: \"entry points\"\n          }), \" to make your extension package expose your\\ncustom components to spaCy automatically.\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-entry-points\",\n      children: [_jsx(_components.h2, {\n        id: \"entry-points\",\n        version: \"2.1\",\n        children: \"Using entry points \"\n      }), _jsxs(_components.p, {\n        children: [\"Entry points let you expose parts of a Python package you write to other Python\\npackages. This lets one application easily customize the behavior of another, by\\nexposing an entry point in its \", _jsx(InlineCode, {\n          children: \"setup.py\"\n        }), \". For a quick and fun intro to entry\\npoints in Python, check out\\n\", _jsx(_components.a, {\n          href: \"https://amir.rachum.com/blog/2017/07/28/python-entry-points/\",\n          children: \"this excellent blog post\"\n        }), \".\\nspaCy can load custom functions from several different entry points to add\\npipeline component factories, language classes and other settings. To make spaCy\\nuse your entry points, your package needs to expose them and it needs to be\\ninstalled in the same environment – that’s it.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Entry point\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"#entry-points-components\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy_factories\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Group of entry points for pipeline component factories, keyed by component name. Can be used to expose custom components defined by another package.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"#entry-points-languages\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy_languages\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Group of entry points for custom \", _jsxs(_components.a, {\n                href: \"/usage/linguistic-features#language-data\",\n                children: [_jsx(InlineCode, {\n                  children: \"Language\"\n                }), \" subclasses\"]\n              }), \", keyed by language shortcut.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spacy_lookups\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Group of entry points for custom \", _jsx(_components.a, {\n                href: \"/api/lookups\",\n                children: _jsx(InlineCode, {\n                  children: \"Lookups\"\n                })\n              }), \", including lemmatizer data. Used by spaCy’s \", _jsx(_components.a, {\n                href: \"https://github.com/explosion/spacy-lookups-data\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy-lookups-data\"\n                })\n              }), \" package.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"#entry-points-displacy\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy_displacy_colors\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Group of entry points of custom label colors for the \", _jsx(_components.a, {\n                href: \"/usage/visualizers#ent\",\n                children: \"displaCy visualizer\"\n              }), \". The key name doesn’t matter, but it should point to a dict of labels and color values. Useful for custom models that predict different entity types.\"]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        children: \"Loading probability tables into existing models\"\n      }), _jsxs(_components.p, {\n        children: [\"You can load a probability table from \", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-lookups-data\",\n          children: \"spacy-lookups-data\"\n        }), \" into an existing spaCy model like \", _jsx(InlineCode, {\n          children: \"en_core_web_sm\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Requirements: pip install spacy-lookups-data\\nimport spacy\\nfrom spacy.lookups import load_lookups\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nlookups = load_lookups(\\\"en\\\", [\\\"lexeme_prob\\\"])\\nnlp.vocab.lookups.add_table(\\\"lexeme_prob\\\", lookups.get_table(\\\"lexeme_prob\\\"))\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When training a model from scratch you can also specify probability tables in the \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[initialize.lookups]\\n@misc = \\\"spacy.LookupsDataLoader.v1\\\"\\nlang = ${nlp.lang}\\ntables = [\\\"lexeme_prob\\\"]\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"entry-points-components\",\n        children: \"Custom components via entry points \"\n      }), _jsxs(_components.p, {\n        children: [\"When you load a pipeline, spaCy will generally use its \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" to set up\\nthe language class and construct the pipeline. The pipeline is specified as a\\nlist of strings, e.g. \", _jsx(InlineCode, {\n          children: \"pipeline = [\\\"tagger\\\", \\\"parser\\\", \\\"ner\\\"]\"\n        }), \". For each of\\nthose strings, spaCy will call \", _jsx(InlineCode, {\n          children: \"nlp.add_pipe\"\n        }), \" and look up the name in all\\nfactories defined by the decorators\\n\", _jsx(_components.a, {\n          href: \"/api/language#component\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.component\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \". This means that you have to import\\nyour custom components \", _jsx(_components.em, {\n          children: \"before\"\n        }), \" loading the pipeline.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Using entry points, pipeline packages and extension packages can define their\\nown \", _jsx(InlineCode, {\n          children: \"\\\"spacy_factories\\\"\"\n        }), \", which will be loaded automatically in the background\\nwhen the \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class is initialized. So if a user has your package\\ninstalled, they’ll be able to use your components – even if they \", _jsx(_components.strong, {\n          children: \"don’t import\\nthem\"\n        }), \"!\"]\n      }), _jsxs(_components.p, {\n        children: [\"To stick with the theme of\\n\", _jsx(_components.a, {\n          href: \"https://amir.rachum.com/blog/2017/07/28/python-entry-points/\",\n          children: \"this entry points blog post\"\n        }), \",\\nconsider the following custom spaCy\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-coponents\",\n          children: \"pipeline component\"\n        }), \" that prints a\\nsnake when it’s called:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Package directory structure\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-yaml\",\n            lang: \"yaml\",\n            children: \"├── snek.py   # the extension code\\n└── setup.py  # setup file for pip installation\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"snek.py\",\n          children: \"from spacy.language import Language\\n\\nsnek = \\\"\\\"\\\"\\n    --..,_                     _,.--.\\n       `'.'.                .'`__ o  `;__. {text}\\n          '.'.            .'.'`  '---'`  `\\n            '.`'--....--'`.'\\n              `'--....--'`\\n\\\"\\\"\\\"\\n\\n@Language.component(\\\"snek\\\")\\ndef snek_component(doc):\\n    print(snek.format(text=doc.text))\\n    return doc\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Since it’s a very complex and sophisticated module, you want to split it off\\ninto its own package so you can version it and upload it to PyPi. You also want\\nyour custom package to be able to define \", _jsx(InlineCode, {\n          children: \"pipeline = [\\\"snek\\\"]\"\n        }), \" in its\\n\", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \". For that, you need to be able to tell spaCy where to find the\\ncomponent \", _jsx(InlineCode, {\n          children: \"\\\"snek\\\"\"\n        }), \". If you don’t do this, spaCy will raise an error when you try\\nto load the pipeline because there’s no built-in \", _jsx(InlineCode, {\n          children: \"\\\"snek\\\"\"\n        }), \" component. To add an\\nentry to the factories, you can now expose it in your \", _jsx(InlineCode, {\n          children: \"setup.py\"\n        }), \" via the\\n\", _jsx(InlineCode, {\n          children: \"entry_points\"\n        }), \" dictionary:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Entry point syntax\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"Python entry points for a group are formatted as a \", _jsx(_components.strong, {\n            children: \"list of strings\"\n          }), \", with\\neach string following the syntax of \", _jsx(InlineCode, {\n            children: \"name = module:object\"\n          }), \". In this example,\\nthe created entry point is named \", _jsx(InlineCode, {\n            children: \"snek\"\n          }), \" and points to the function\\n\", _jsx(InlineCode, {\n            children: \"snek_component\"\n          }), \" in the module \", _jsx(InlineCode, {\n            children: \"snek\"\n          }), \", i.e. \", _jsx(InlineCode, {\n            children: \"snek.py\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"setup.py\",\n          highlight: \"5-7\",\n          children: \"from setuptools import setup\\n\\nsetup(\\n    name=\\\"snek\\\",\\n    entry_points={\\n        \\\"spacy_factories\\\": [\\\"snek = snek:snek_component\\\"]\\n    }\\n)\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"The same package can expose multiple entry points, by the way. To make them\\navailable to spaCy, all you need to do is install the package in your\\nenvironment:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python setup.py develop\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"spaCy is now able to create the pipeline component \", _jsx(InlineCode, {\n          children: \"\\\"snek\\\"\"\n        }), \" – even though you\\nnever imported \", _jsx(InlineCode, {\n          children: \"snek_component\"\n        }), \". When you save the\\n\", _jsx(_components.a, {\n          href: \"/api/language#config\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.config\"\n          })\n        }), \" to disk, it includes an entry for your\\n\", _jsx(InlineCode, {\n          children: \"\\\"snek\\\"\"\n        }), \" component and any pipeline you train with this config will include the\\ncomponent and know how to load it – if your \", _jsx(InlineCode, {\n          children: \"snek\"\n        }), \" package is installed.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"[nlp]\\nlang = \\\"en\\\"\\n+ pipeline = [\\\"snek\\\"]\\n\\n[components]\\n\\n+ [components.snek]\\n+ factory = \\\"snek\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          lang: \"none\",\n          children: \">>> from spacy.lang.en import English\\n>>> nlp = English()\\n>>> nlp.add_pipe(\\\"snek\\\")  # this now works! 🐍🎉\\n>>> doc = nlp(\\\"I am snek\\\")\\n    --..,_                     _,.--.\\n       `'.'.                .'`__ o  `;__. I am snek\\n          '.'.            .'.'`  '---'`  `\\n            '.`'--....--'`.'\\n              `'--....--'`\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Instead of making your snek component a simple\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-simple\",\n          children: \"stateless component\"\n        }), \", you\\ncould also make it a\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-factories\",\n          children: \"factory\"\n        }), \" that takes\\nsettings. Your users can then pass in an optional \", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" when they add your\\ncomponent to the pipeline and customize its appearance – for example, the\\n\", _jsx(InlineCode, {\n          children: \"snek_style\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"[components.snek]\\nfactory = \\\"snek\\\"\\n+ snek_style = \\\"basic\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"SNEKS = {\\\"basic\\\": snek, \\\"cute\\\": cute_snek}  # collection of sneks\\n\\n@Language.factory(\\\"snek\\\", default_config={\\\"snek_style\\\": \\\"basic\\\"})\\nclass SnekFactory:\\n    def __init__(self, nlp: Language, name: str, snek_style: str):\\n        self.nlp = nlp\\n        self.snek_style = snek_style\\n        self.snek = SNEKS[self.snek_style]\\n\\n    def __call__(self, doc):\\n        print(self.snek)\\n        return doc\\n\"\n        })\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          title: \"setup.py\",\n          children: \"entry_points={\\n-   \\\"spacy_factories\\\": [\\\"snek = snek:snek_component\\\"]\\n+   \\\"spacy_factories\\\": [\\\"snek = snek:SnekFactory\\\"]\\n}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The factory can also implement other pipeline component methods like \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \"\\nand \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" for serialization, or even \", _jsx(InlineCode, {\n          children: \"update\"\n        }), \" to make the component\\ntrainable. If a component exposes a \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method and is included in a\\npipeline, spaCy will call it on load. This lets you ship custom data with your\\npipeline package. When you save out a pipeline using \", _jsx(InlineCode, {\n          children: \"nlp.to_disk\"\n        }), \" and the\\ncomponent exposes a \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" method, it will be called with the disk path.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from spacy.util import ensure_path\\n\\ndef to_disk(self, path, exclude=tuple()):\\n    path = ensure_path(path)\\n    if not path.exists():\\n        path.mkdir()\\n    snek_path = path / \\\"snek.txt\\\"\\n    with snek_path.open(\\\"w\\\", encoding=\\\"utf8\\\") as snek_file:\\n        snek_file.write(self.snek)\\n\\ndef from_disk(self, path, exclude=tuple()):\\n    snek_path = path / \\\"snek.txt\\\"\\n    with snek_path.open(\\\"r\\\", encoding=\\\"utf8\\\") as snek_file:\\n        self.snek = snek_file.read()\\n    return self\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The above example will serialize the current snake in a \", _jsx(InlineCode, {\n          children: \"snek.txt\"\n        }), \" in the data\\ndirectory. When a pipeline using the \", _jsx(InlineCode, {\n          children: \"snek\"\n        }), \" component is loaded, it will open\\nthe \", _jsx(InlineCode, {\n          children: \"snek.txt\"\n        }), \" and make it available to the component.\"]\n      }), _jsx(_components.h3, {\n        id: \"entry-points-languages\",\n        children: \"Custom language classes via entry points \"\n      }), _jsxs(_components.p, {\n        children: [\"To stay with the theme of the previous example and\\n\", _jsx(_components.a, {\n          href: \"https://amir.rachum.com/blog/2017/07/28/python-entry-points/\",\n          children: \"this blog post on entry points\"\n        }), \",\\nlet’s imagine you wanted to implement your own \", _jsx(InlineCode, {\n          children: \"SnekLanguage\"\n        }), \" class for your\\ncustom pipeline – but you don’t necessarily want to modify spaCy’s code to add a\\nlanguage. In your package, you could then implement the following\\n\", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#language-subclass\",\n          children: \"custom language subclass\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"snek.py\",\n          children: \"from spacy.language import Language\\n\\nclass SnekDefaults(Language.Defaults):\\n    stop_words = set([\\\"sss\\\", \\\"hiss\\\"])\\n\\nclass SnekLanguage(Language):\\n    lang = \\\"snk\\\"\\n    Defaults = SnekDefaults\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Alongside the \", _jsx(InlineCode, {\n          children: \"spacy_factories\"\n        }), \", there’s also an entry point option for\\n\", _jsx(InlineCode, {\n          children: \"spacy_languages\"\n        }), \", which maps language codes to language-specific \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \"\\nsubclasses:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          title: \"setup.py\",\n          children: \"from setuptools import setup\\n\\nsetup(\\n    name=\\\"snek\\\",\\n    entry_points={\\n        \\\"spacy_factories\\\": [\\\"snek = snek:SnekFactory\\\"],\\n+       \\\"spacy_languages\\\": [\\\"snk = snek:SnekLanguage\\\"]\\n    }\\n)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In spaCy, you can then load the custom \", _jsx(InlineCode, {\n          children: \"snk\"\n        }), \" language and it will be resolved to\\n\", _jsx(InlineCode, {\n          children: \"SnekLanguage\"\n        }), \" via the custom entry point. This is especially relevant for\\npipeline packages you \", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"train\"\n        }), \", which could then specify\\n\", _jsx(InlineCode, {\n          children: \"lang = snk\"\n        }), \" in their \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" without spaCy raising an error because the\\nlanguage is not available in the core library.\"]\n      }), _jsx(_components.h3, {\n        id: \"entry-points-displacy\",\n        version: \"2.2\",\n        children: \"Custom displaCy colors via entry points \"\n      }), _jsxs(_components.p, {\n        children: [\"If you’re training a named entity recognition model for a custom domain, you may\\nend up training different labels that don’t have pre-defined colors in the\\n\", _jsxs(_components.a, {\n          href: \"/usage/visualizers#ent\",\n          children: [_jsx(InlineCode, {\n            children: \"displacy\"\n          }), \" visualizer\"]\n        }), \". The \", _jsx(InlineCode, {\n          children: \"spacy_displacy_colors\"\n        }), \"\\nentry point lets you define a dictionary of entity labels mapped to their color\\nvalues. It’s added to the pre-defined colors and can also overwrite existing\\nvalues.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Domain-specific NER labels\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"Good examples of pipelines with domain-specific label schemes are\\n\", _jsx(_components.a, {\n            href: \"/universe/project/scispacy\",\n            children: \"scispaCy\"\n          }), \" and\\n\", _jsx(_components.a, {\n            href: \"/universe/project/blackstone\",\n            children: \"Blackstone\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"snek.py\",\n          children: \"displacy_colors = {\\\"SNEK\\\": \\\"#3dff74\\\", \\\"HUMAN\\\": \\\"#cfc5ff\\\"}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Given the above colors, the entry point can be defined as follows. Entry points\\nneed to have a name, so we use the key \", _jsx(InlineCode, {\n          children: \"colors\"\n        }), \". However, the name doesn’t\\nmatter and whatever is defined in the entry point group will be used.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          title: \"setup.py\",\n          children: \"from setuptools import setup\\n\\nsetup(\\n    name=\\\"snek\\\",\\n    entry_points={\\n+       \\\"spacy_displacy_colors\\\": [\\\"colors = snek:displacy_colors\\\"]\\n    }\\n)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"After installing the package, the custom colors will be used when visualizing\\ntext with \", _jsx(InlineCode, {\n          children: \"displacy\"\n        }), \". Whenever the label \", _jsx(InlineCode, {\n          children: \"SNEK\"\n        }), \" is assigned, it will be\\ndisplayed in \", _jsx(InlineCode, {\n          children: \"#3dff74\"\n        }), \".\"]\n      }), _jsx(Iframe, {\n        title: \"displaCy visualization of entities\",\n        src: \"/images/displacy-ent-snek.html\",\n        height: 100\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-models\",\n      children: [_jsx(_components.h2, {\n        id: \"models\",\n        children: \"Saving, loading and distributing trained pipelines \"\n      }), _jsxs(_components.p, {\n        children: [\"After training your pipeline, you’ll usually want to save its state, and load it\\nback later. You can do this with the \", _jsx(_components.a, {\n          href: \"/api/language#to_disk\",\n          children: _jsx(InlineCode, {\n            children: \"Language.to_disk\"\n          })\n        }), \"\\nmethod:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp.to_disk(\\\"./en_example_pipeline\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The directory will be created if it doesn’t exist, and the whole pipeline data,\\nmeta and configuration will be written out. To make the pipeline more convenient\\nto deploy, we recommend wrapping it as a \", _jsx(_components.a, {\n          href: \"/api/cli#package\",\n          children: \"Python package\"\n        }), \".\"]\n      }), _jsxs(Accordion, {\n        title: \"What’s the difference between the config.cfg and meta.json?\",\n        spaced: true,\n        id: \"models-meta-vs-config\",\n        spaced: true,\n        children: [_jsxs(_components.p, {\n          children: [\"When you save a pipeline in spaCy v3.0+, two files will be exported: a\\n\", _jsx(_components.a, {\n            href: \"/api/data-formats#config\",\n            children: _jsx(InlineCode, {\n              children: \"config.cfg\"\n            })\n          }), \" based on\\n\", _jsx(_components.a, {\n            href: \"/api/language#config\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.config\"\n            })\n          }), \" and a \", _jsx(_components.a, {\n            href: \"/api/data-formats#meta\",\n            children: _jsx(InlineCode, {\n              children: \"meta.json\"\n            })\n          }), \"\\nbased on \", _jsx(_components.a, {\n            href: \"/api/language#meta\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.meta\"\n            })\n          }), \".\"]\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"config\"\n            }), \": Configuration used to create the current \", _jsx(InlineCode, {\n              children: \"nlp\"\n            }), \" object, its\\npipeline components and models, as well as training settings and\\nhyperparameters. Can include references to registered functions like\\n\", _jsx(_components.a, {\n              href: \"/usage/processing-pipelines#custom-components\",\n              children: \"pipeline components\"\n            }), \" or\\n\", _jsx(_components.a, {\n              href: \"/api/architectures\",\n              children: \"model architectures\"\n            }), \". Given a config, spaCy is able\\nreconstruct the whole tree of objects and the \", _jsx(InlineCode, {\n              children: \"nlp\"\n            }), \" object. An exported config\\ncan also be used to \", _jsx(_components.a, {\n              href: \"/usage/training#config\",\n              children: \"train a pipeline\"\n            }), \" with the same\\nsettings.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"meta\"\n            }), \": Meta information about the pipeline and the Python package, such as\\nthe author information, license, version, data sources and label scheme. This\\nis mostly used for documentation purposes and for packaging pipelines. It has\\nno impact on the functionality of the \", _jsx(InlineCode, {\n              children: \"nlp\"\n            }), \" object.\"]\n          }), \"\\n\"]\n        })]\n      }), _jsx(Project, {\n        id: \"pipelines/tagger_parser_ud\",\n        children: _jsxs(_components.p, {\n          children: [\"The easiest way to get started with an end-to-end workflow is to clone a\\n\", _jsx(_components.a, {\n            href: \"/usage/projects\",\n            children: \"project template\"\n          }), \" and run it – for example, this template that\\nlets you train a \", _jsx(_components.strong, {\n            children: \"part-of-speech tagger\"\n          }), \" and \", _jsx(_components.strong, {\n            children: \"dependency parser\"\n          }), \" on a\\nUniversal Dependencies treebank and generates an installable Python package.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"models-generating\",\n        children: \"Generating a pipeline package \"\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Pipeline packages are typically \", _jsx(_components.strong, {\n            children: \"not suitable\"\n          }), \" for the public\\n\", _jsx(_components.a, {\n            href: \"https://pypi.python.org\",\n            children: \"pypi.python.org\"\n          }), \" directory, which is not designed for\\nbinary data and files over 50 MB. However, if your company is running an\\n\", _jsx(_components.strong, {\n            children: \"internal installation\"\n          }), \" of PyPi, publishing your pipeline packages on there\\ncan be a convenient way to share them with your team.\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"spaCy comes with a handy CLI command that will create all required files, and\\nwalk you through generating the meta data. You can also create the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#meta\",\n          children: _jsx(InlineCode, {\n            children: \"meta.json\"\n          })\n        }), \" manually and place it in the data\\ndirectory, or supply a path to it using the \", _jsx(InlineCode, {\n          children: \"--meta\"\n        }), \" flag. For more info on\\nthis, see the \", _jsx(_components.a, {\n          href: \"/api/cli#package\",\n          children: _jsx(InlineCode, {\n            children: \"package\"\n          })\n        }), \" docs.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"meta.json (example)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            children: \"{\\n  \\\"name\\\": \\\"example_pipeline\\\",\\n  \\\"lang\\\": \\\"en\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"spacy_version\\\": \\\">=2.0.0,<3.0.0\\\",\\n  \\\"description\\\": \\\"Example pipeline for spaCy\\\",\\n  \\\"author\\\": \\\"You\\\",\\n  \\\"email\\\": \\\"you@example.com\\\",\\n  \\\"license\\\": \\\"CC BY-SA 3.0\\\"\\n}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy package ./en_example_pipeline ./packages\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"This command will create a pipeline package directory and will run\\n\", _jsx(InlineCode, {\n          children: \"python setup.py sdist\"\n        }), \" in that directory to create a binary \", _jsx(InlineCode, {\n          children: \".whl\"\n        }), \" file or\\n\", _jsx(InlineCode, {\n          children: \".tar.gz\"\n        }), \" archive of your package that can be installed using \", _jsx(InlineCode, {\n          children: \"pip install\"\n        }), \".\\nInstalling the binary wheel is usually more efficient.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-yaml\",\n          lang: \"yaml\",\n          title: \"Directory structure\",\n          children: \"└── /\\n    ├── MANIFEST.in                           # to include meta.json\\n    ├── meta.json                             # pipeline meta data\\n    ├── setup.py                              # setup file for pip installation\\n    ├── en_example_pipeline                   # pipeline directory\\n    │    ├── __init__.py                      # init for pip installation\\n    │    └── en_example_pipeline-1.0.0        # pipeline data\\n    │        ├── config.cfg                   # pipeline config\\n    │        ├── meta.json                    # pipeline meta\\n    │        └── ...                          # directories with component data\\n    └── dist\\n        └── en_example_pipeline-1.0.0.tar.gz  # installable package\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"You can also find templates for all files in the\\n\", _jsxs(_components.a, {\n          href: \"https://github.com/explosion/spacy/tree/master/spacy/cli/package.py\",\n          children: [_jsx(InlineCode, {\n            children: \"cli/package.py\"\n          }), \" source\"]\n        }), \".\\nIf you’re creating the package manually, keep in mind that the directories need\\nto be named according to the naming conventions of \", _jsx(InlineCode, {\n          children: \"lang_name\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"lang_name-version\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"models-custom\",\n        children: \"Including custom functions and components \"\n      }), _jsxs(_components.p, {\n        children: [\"If your pipeline includes\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components\",\n          children: \"custom components\"\n        }), \", model\\narchitectures or other \", _jsx(_components.a, {\n          href: \"/usage/training#custom-code\",\n          children: \"code\"\n        }), \", those functions need\\nto be registered \", _jsx(_components.strong, {\n          children: \"before\"\n        }), \" your pipeline is loaded. Otherwise, spaCy won’t know\\nhow to create the objects referenced in the config. If you’re loading your own\\npipeline in Python, you can make custom components available just by importing\\nthe code that defines them before calling\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \". This is also how the \", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \"\\nargument to CLI commands works.\"]\n      }), _jsxs(_components.p, {\n        children: [\"With the \", _jsx(_components.a, {\n          href: \"/api/cli#package\",\n          children: _jsx(InlineCode, {\n            children: \"spacy package\"\n          })\n        }), \" command, you can provide one or\\nmore paths to Python files containing custom registered functions using the\\n\", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \" argument.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"__init__.py (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from . import functions\\n\\ndef load(**overrides):\\n   ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy package ./en_example_pipeline ./packages --code functions.py\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The Python files will be copied over into the root of the package, and the\\npackage’s \", _jsx(InlineCode, {\n          children: \"__init__.py\"\n        }), \" will import them as modules. This ensures that functions\\nare registered when the pipeline is imported, e.g. when you call \", _jsx(InlineCode, {\n          children: \"spacy.load\"\n        }), \". A\\nsimple import is all that’s needed to make registered functions available.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Make sure to include \", _jsx(_components.strong, {\n          children: \"all Python files\"\n        }), \" that are referenced in your custom\\ncode, including modules imported by others. If your custom code depends on\\n\", _jsx(_components.strong, {\n          children: \"external packages\"\n        }), \", make sure they’re listed in the list of \", _jsx(InlineCode, {\n          children: \"\\\"requirements\\\"\"\n        }), \"\\nin your \", _jsx(_components.a, {\n          href: \"/api/data-formats#meta\",\n          children: _jsx(InlineCode, {\n            children: \"meta.json\"\n          })\n        }), \". For the majority of use cases,\\nregistered functions should provide you with all customizations you need, from\\ncustom components to custom model architectures and lifecycle hooks. However, if\\nyou do want to customize the setup in more detail, you can edit the package’s\\n\", _jsx(InlineCode, {\n          children: \"__init__.py\"\n        }), \" and the package’s \", _jsx(InlineCode, {\n          children: \"load\"\n        }), \" function that’s called by\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \".\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note on making manual edits\",\n        children: _jsxs(_components.p, {\n          children: [\"While it’s no problem to edit the package code or meta information, avoid making\\nedits to the \", _jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" \", _jsx(_components.strong, {\n            children: \"after\"\n          }), \" training, as this can easily lead to data\\nincompatibility. For instance, changing an architecture or hyperparameter can\\nmean that the trained weights are now incompatible. If you want to make\\nadjustments, you can do so before training. Otherwise, you should always trust\\nspaCy to export the current state of its \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" objects via\\n\", _jsx(_components.a, {\n            href: \"/api/language#config\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.config\"\n            })\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"loading\",\n        children: \"Loading a custom pipeline package \"\n      }), _jsxs(_components.p, {\n        children: [\"To load a pipeline from a data directory, you can use\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load()\"\n          })\n        }), \" with the local path. This will look\\nfor a \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" in the directory and use the \", _jsx(InlineCode, {\n          children: \"lang\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"pipeline\"\n        }), \" settings\\nto initialize a \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class with a processing pipeline and load in the\\nmodel data.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"/path/to/pipeline\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If you want to \", _jsx(_components.strong, {\n          children: \"load only the binary data\"\n        }), \", you’ll have to create a \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \"\\nclass and call \", _jsx(_components.a, {\n          href: \"/api/language#from_disk\",\n          children: _jsx(InlineCode, {\n            children: \"from_disk\"\n          })\n        }), \" instead.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.blank(\\\"en\\\").from_disk(\\\"/path/to/data\\\")\\n\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Saving and Loading","menu":[["Basics","basics"],["Serializing Docs","docs"],["Serialization Methods","serialization-methods"],["Entry Points","entry-points"],["Trained Pipelines","models"]]},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":{"slug":"/usage/visualizers","title":"Visualizers"}},"__N_SSG":true}