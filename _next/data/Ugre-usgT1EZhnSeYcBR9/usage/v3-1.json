{"pageProps":{"title":"What's New in v3.1","teaser":"New features and how to upgrade","menu":[["New Features","features"],["Upgrading Notes","upgrading"]],"slug":"/usage/v3-1","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*TODO: more details and/or example project?*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    strong: \"strong\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components), {InlineCode, Project, Infobox, Image} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Project) _missingMdxReference(\"Project\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-features\",\n      children: [_jsx(_components.h2, {\n        id: \"features\",\n        hidden: \"true\",\n        children: \"New Features \"\n      }), _jsxs(_components.p, {\n        children: [\"It’s been great to see the adoption of the new spaCy v3, which introduced\\n\", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers\",\n          children: \"transformer-based\"\n        }), \" pipelines, a new\\n\", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"config and training system\"\n        }), \" for reproducible experiments,\\n\", _jsx(_components.a, {\n          href: \"/usage/projects\",\n          children: \"projects\"\n        }), \" for end-to-end workflows, and many\\n\", _jsx(_components.a, {\n          href: \"/usage/v3\",\n          children: \"other features\"\n        }), \". Version 3.1 adds more on top of it, including the\\nability to use predicted annotations during training, a new \", _jsx(InlineCode, {\n          children: \"SpanCategorizer\"\n        }), \"\\ncomponent for predicting arbitrary and potentially overlapping spans, support\\nfor partial incorrect annotations in the entity recognizer, new trained\\npipelines for Catalan and Danish, as well as many bug fixes and improvements.\"]\n      }), _jsx(_components.h3, {\n        id: \"predicted-annotations-training\",\n        children: \"Using predicted annotations during training \"\n      }), _jsxs(_components.p, {\n        children: [\"By default, components are updated in isolation during training, which means\\nthat they don’t see the predictions of any earlier components in the pipeline.\\nThe new\\n\", _jsx(_components.a, {\n          href: \"/usage/training#annotating-components\",\n          children: _jsx(InlineCode, {\n            children: \"[training.annotating_components]\"\n          })\n        }), \"\\nconfig setting lets you specify pipeline components that should set annotations\\non the predicted docs during training. This makes it easy to use the predictions\\nof a previous component in the pipeline as features for a subsequent component,\\ne.g. the dependency labels in the tagger:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          highlight: \"7,12\",\n          children: \"[nlp]\\npipeline = [\\\"parser\\\", \\\"tagger\\\"]\\n\\n[components.tagger.model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v1\\\"\\nwidth = ${components.tagger.model.tok2vec.encode.width}\\nattrs = [\\\"NORM\\\",\\\"DEP\\\"]\\nrows = [5000,2500]\\ninclude_static_vectors = false\\n\\n[training]\\nannotating_components = [\\\"parser\\\"]\\n\"\n        })\n      }), _jsx(Project, {\n        id: \"pipelines/tagger_parser_predicted_annotations\",\n        children: _jsxs(_components.p, {\n          children: [\"This project shows how to use the \", _jsx(InlineCode, {\n            children: \"token.dep\"\n          }), \" attribute predicted by the parser\\nas a feature for a subsequent tagger component in the pipeline.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"spancategorizer\",\n        tag: \"experimental\",\n        children: \"SpanCategorizer for predicting arbitrary and overlapping spans \"\n      }), _jsxs(_components.p, {\n        children: [\"A common task in applied NLP is extracting spans of texts from documents,\\nincluding longer phrases or nested expressions. Named entity recognition isn’t\\nthe right tool for this problem, since an entity recognizer typically predicts\\nsingle token-based tags that are very sensitive to boundaries. This is effective\\nfor proper nouns and self-contained expressions, but less useful for other types\\nof phrases or overlapping spans. The new\\n\", _jsx(_components.a, {\n          href: \"/api/spancategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"SpanCategorizer\"\n          })\n        }), \" component and\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#spancategorizer\",\n          children: \"SpanCategorizer\"\n        }), \" architecture let you label\\narbitrary and potentially overlapping spans of texts. A span categorizer\\nconsists of two parts: a \", _jsx(_components.a, {\n          href: \"/api/spancategorizer#suggesters\",\n          children: \"suggester function\"\n        }), \"\\nthat proposes candidate spans, which may or may not overlap, and a labeler model\\nthat predicts zero or more labels for each candidate. The predicted spans are\\navailable via the \", _jsx(_components.a, {\n          href: \"/api/doc#spans\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.spans\"\n          })\n        }), \" container.\"]\n      }), _jsx(Project, {\n        id: \"experimental/ner_spancat\",\n        children: _jsx(_components.p, {\n          children: \"This project trains a span categorizer for Indonesian NER.\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Tip: Create data with Prodigy's new span annotation UI\",\n        children: [_jsx(Image, {\n          src: \"/images/prodigy_spans-manual.jpg\",\n          href: \"https://support.prodi.gy/t/3861\",\n          alt: \"Prodigy: example of the new manual spans UI\"\n        }), _jsxs(_components.p, {\n          children: [\"The upcoming version of our annotation tool \", _jsx(_components.a, {\n            href: \"https://prodi.gy\",\n            children: \"Prodigy\"\n          }), \"\\n(currently available as a \", _jsx(_components.a, {\n            href: \"https://support.prodi.gy/t/3861\",\n            children: \"pre-release\"\n          }), \" for all\\nusers) features a \", _jsx(_components.a, {\n            href: \"https://support.prodi.gy/t/3861\",\n            children: \"new workflow and UI\"\n          }), \" for\\nannotating overlapping and nested spans. You can use it to create training data\\nfor spaCy’s \", _jsx(InlineCode, {\n            children: \"SpanCategorizer\"\n          }), \" component.\"]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"negative-samples\",\n        children: \"Update the entity recognizer with partial incorrect annotations \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.ner]\\nfactory = \\\"ner\\\"\\nincorrect_spans_key = \\\"incorrect_spans\\\"\\nmoves = null\\nupdate_with_oracle_cut_size = 100\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/entityrecognizer\",\n          children: _jsx(InlineCode, {\n            children: \"EntityRecognizer\"\n          })\n        }), \" can now be updated with known\\nincorrect annotations, which lets you take advantage of partial and sparse data.\\nFor example, you’ll be able to use the information that certain spans of text\\nare definitely \", _jsx(_components.strong, {\n          children: \"not\"\n        }), \" \", _jsx(InlineCode, {\n          children: \"PERSON\"\n        }), \" entities, without having to provide the complete\\ngold-standard annotations for the given example. The incorrect span annotations\\ncan be added via the \", _jsx(_components.a, {\n          href: \"/api/doc#spans\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.spans\"\n          })\n        }), \" in the training data under\\nthe key defined as \", _jsx(_components.a, {\n          href: \"/api/entityrecognizer#init\",\n          children: _jsx(InlineCode, {\n            children: \"incorrect_spans_key\"\n          })\n        }), \" in the\\ncomponent config.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"train_doc = nlp.make_doc(\\\"Barack Obama was born in Hawaii.\\\")\\n# The doc.spans key can be defined in the config\\ntrain_doc.spans[\\\"incorrect_spans\\\"] = [\\n  Span(doc, 0, 2, label=\\\"ORG\\\"),\\n  Span(doc, 5, 6, label=\\\"PRODUCT\\\")\\n]\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"pipeline-packages\",\n        children: \"New pipeline packages for Catalan and Danish \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy v3.1 adds 5 new pipeline packages, including a new core family for Catalan\\nand a new transformer-based pipeline for Danish using the\\n\", _jsx(_components.a, {\n          href: \"http://huggingface.co/Maltehb/danish-bert-botxo\",\n          children: _jsx(InlineCode, {\n            children: \"danish-bert-botxo\"\n          })\n        }), \" weights.\\nSee the \", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"models directory\"\n        }), \" for an overview of all available trained\\npipelines and the \", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"training guide\"\n        }), \" for details on how to train\\nyour own.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Thanks to Carlos Rodríguez Penagos and the\\n\", _jsx(_components.a, {\n            href: \"https://temu.bsc.es/\",\n            children: \"Barcelona Supercomputing Center\"\n          }), \" for their\\ncontributions for Catalan and to Kenneth Enevoldsen for Danish. For additional\\nDanish pipelines, check out \", _jsx(_components.a, {\n            href: \"https://github.com/KennethEnevoldsen/DaCy\",\n            children: \"DaCy\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Package\"\n            }), _jsx(_components.th, {\n              children: \"Language\"\n            }), _jsx(_components.th, {\n              align: \"right\",\n              children: \"UPOS\"\n            }), _jsx(_components.th, {\n              align: \"right\",\n              children: \"Parser LAS\"\n            }), _jsx(_components.th, {\n              align: \"right\",\n              children: \"NER F\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/models/ca#ca_core_news_sm\",\n                children: _jsx(InlineCode, {\n                  children: \"ca_core_news_sm\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Catalan\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"98.2\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"87.4\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"79.8\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/models/ca#ca_core_news_md\",\n                children: _jsx(InlineCode, {\n                  children: \"ca_core_news_md\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Catalan\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"98.3\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"88.2\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"84.0\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/models/ca#ca_core_news_lg\",\n                children: _jsx(InlineCode, {\n                  children: \"ca_core_news_lg\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Catalan\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"98.5\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"88.4\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"84.2\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/models/ca#ca_core_news_trf\",\n                children: _jsx(InlineCode, {\n                  children: \"ca_core_news_trf\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Catalan\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"98.9\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"93.0\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"91.2\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/models/da#da_core_news_trf\",\n                children: _jsx(InlineCode, {\n                  children: \"da_core_news_trf\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Danish\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"98.0\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"85.0\"\n            }), _jsx(_components.td, {\n              align: \"right\",\n              children: \"82.9\"\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"resizable-textcat\",\n        children: \"Resizable text classification architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"Previously, the \", _jsx(_components.a, {\n          href: \"/api/textcategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"TextCategorizer\"\n          })\n        }), \" architectures could\\nnot be resized, meaning that you couldn’t add new labels to an already trained\\nmodel. In spaCy v3.1, the \", _jsx(_components.a, {\n          href: \"/api/architectures#TextCatCNN\",\n          children: \"TextCatCNN\"\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TextCatBOW\",\n          children: \"TextCatBOW\"\n        }), \" architectures are now resizable,\\nwhile ensuring that the predictions for the old labels remain the same.\"]\n      }), _jsx(_components.h3, {\n        id: \"assemble\",\n        children: \"CLI command to assemble pipeline from config \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/cli#assemble\",\n          children: _jsx(InlineCode, {\n            children: \"spacy assemble\"\n          })\n        }), \" command lets you assemble a pipeline\\nfrom a config file without additional training. It can be especially useful for\\ncreating a blank pipeline with a custom tokenizer, rule-based components or word\\nvectors.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy assemble config.cfg ./output\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"package-readme\",\n        children: \"Pretty pipeline package READMEs \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/cli#package\",\n          children: _jsx(InlineCode, {\n            children: \"spacy package\"\n          })\n        }), \" command now auto-generates a pretty\\n\", _jsx(InlineCode, {\n          children: \"README.md\"\n        }), \" based on the pipeline information defined in the \", _jsx(InlineCode, {\n          children: \"meta.json\"\n        }), \". This\\nincludes a table with a general overview, as well as the label scheme and\\naccuracy figures, if available. For an example, see the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-models/releases\",\n          children: \"model releases\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"streaming-corpora\",\n        children: \"Support for streaming large or infinite corpora \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[training]\\nmax_epochs = -1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The training process now supports streaming large or infinite corpora\\nout-of-the-box, which can be controlled via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#training\",\n          children: _jsx(InlineCode, {\n            children: \"[training.max_epochs]\"\n          })\n        }), \" config setting. Setting it\\nto \", _jsx(InlineCode, {\n          children: \"-1\"\n        }), \" means that the train corpus should be streamed rather than loaded into\\nmemory with no shuffling within the training loop. For details on how to\\nimplement a custom corpus loader, e.g. to stream in data from a remote storage,\\nsee the usage guide on\\n\", _jsx(_components.a, {\n          href: \"/usage/training#custom-code-readers-batchers\",\n          children: \"custom data reading\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"When streaming a corpus, only the first 100 examples will be used for\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config-lifecycle\",\n          children: \"initialization\"\n        }), \". This is no problem if you’re\\ntraining a component like the text classifier with data that specifies all\\navailable labels in every example. If necessary, you can use the\\n\", _jsx(_components.a, {\n          href: \"/api/cli#init-labels\",\n          children: _jsx(InlineCode, {\n            children: \"init labels\"\n          })\n        }), \" command to pre-generate the labels for\\nyour components using a representative sample so the model can be initialized\\ncorrectly before training.\"]\n      }), _jsx(_components.h3, {\n        id: \"pos-lemmatizers\",\n        children: \"New lemmatizers for Catalan and Italian \"\n      }), _jsxs(_components.p, {\n        children: [\"The trained pipelines for \", _jsx(_components.a, {\n          href: \"/models/ca\",\n          children: \"Catalan\"\n        }), \" and \", _jsx(_components.a, {\n          href: \"/models/it\",\n          children: \"Italian\"\n        }), \" now\\ninclude lemmatizers that use the predicted part-of-speech tags as part of the\\nlookup lemmatization for higher lemmatization accuracy. If you’re training your\\nown pipelines for these languages and you want to include a lemmatizer, make\\nsure you have the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-lookups-data\",\n          children: _jsx(InlineCode, {\n            children: \"spacy-lookups-data\"\n          })\n        }), \" package\\ninstalled, which provides the relevant tables.\"]\n      }), _jsx(_components.h3, {\n        id: \"huggingface-hub\",\n        children: \"Upload your pipelines to the Hugging Face Hub \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"https://huggingface.co/\",\n          children: \"Hugging Face Hub\"\n        }), \" lets you upload models and share\\nthem with others, and it now supports spaCy pipelines out-of-the-box. The new\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-huggingface-hub\",\n          children: _jsx(InlineCode, {\n            children: \"spacy-huggingface-hub\"\n          })\n        }), \"\\npackage automatically adds the \", _jsx(InlineCode, {\n          children: \"huggingface-hub\"\n        }), \" command to your \", _jsx(InlineCode, {\n          children: \"spacy\"\n        }), \" CLI. It\\nlets you upload any pipelines packaged with \", _jsx(_components.a, {\n          href: \"/api/cli#package\",\n          children: _jsx(InlineCode, {\n            children: \"spacy package\"\n          })\n        }), \"\\nand \", _jsx(InlineCode, {\n          children: \"--build wheel\"\n        }), \" and takes care of auto-generating all required meta\\ninformation.\"]\n      }), _jsxs(_components.p, {\n        children: [\"After uploading, you’ll get a live URL for your model page that includes all\\ndetails, files and interactive visualizers, as well as a direct URL to the wheel\\nfile that you can install via \", _jsx(InlineCode, {\n          children: \"pip install\"\n        }), \". For examples, check out the\\n\", _jsx(_components.a, {\n          href: \"https://huggingface.co/spacy\",\n          children: \"spaCy pipelines\"\n        }), \" we’ve uploaded.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ pip install spacy-huggingface-hub\\n$ huggingface-cli login\\n$ python -m spacy package ./en_ner_fashion ./output --build wheel\\n$ cd ./output/en_ner_fashion-0.0.0/dist\\n$ python -m spacy huggingface-hub push en_ner_fashion-0.0.0-py3-none-any.whl\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"You can also integrate the upload command into your\\n\", _jsx(_components.a, {\n          href: \"/usage/projects#huggingface_hub\",\n          children: \"project template\"\n        }), \" to automatically upload your\\npackaged pipelines after training.\"]\n      }), _jsx(Project, {\n        id: \"integrations/huggingface_hub\",\n        children: _jsx(_components.p, {\n          children: \"Get started with uploading your models to the Hugging Face hub using our project\\ntemplate. It trains a simple pipeline, packages it and uploads it if the\\npackaged model has changed. This makes it easy to deploy your models end-to-end.\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-upgrading\",\n      children: [_jsx(_components.h2, {\n        id: \"upgrading\",\n        children: \"Notes about upgrading from v3.0 \"\n      }), _jsx(_components.h3, {\n        id: \"version-compat\",\n        children: \"Pipeline package version compatibility \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Using legacy implementations\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"In spaCy v3, you’ll still be able to load and reference legacy implementations\\nvia \", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-legacy\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-legacy\"\n            })\n          }), \", even if the\\ncomponents or architectures change and newer versions are available in the\\ncore library.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"When you’re loading a pipeline package trained with spaCy v3.0, you will see a\\nwarning telling you that the pipeline may be incompatible. This doesn’t\\nnecessarily have to be true, but we recommend running your pipelines against\\nyour test suite or evaluation data to make sure there are no unexpected results.\\nIf you’re using one of the \", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"trained pipelines\"\n        }), \" we provide, you should\\nrun \", _jsx(_components.a, {\n          href: \"/api/cli#download\",\n          children: _jsx(InlineCode, {\n            children: \"spacy download\"\n          })\n        }), \" to update to the latest version. To\\nsee an overview of all installed packages and their compatibility, you can run\\n\", _jsx(_components.a, {\n          href: \"/api/cli#validate\",\n          children: _jsx(InlineCode, {\n            children: \"spacy validate\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"If you’ve trained your own custom pipeline and you’ve confirmed that it’s still\\nworking as expected, you can update the spaCy version requirements in the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#meta\",\n          children: _jsx(InlineCode, {\n            children: \"meta.json\"\n          })\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"- \\\"spacy_version\\\": \\\">=3.0.0,<3.1.0\\\",\\n+ \\\"spacy_version\\\": \\\">=3.0.0,<3.2.0\\\",\\n\"\n        })\n      }), _jsx(_components.h3, {\n        children: \"Updating v3.0 configs\"\n      }), _jsxs(_components.p, {\n        children: [\"To update a config from spaCy v3.0 with the new v3.1 settings, run\\n\", _jsx(_components.a, {\n          href: \"/api/cli#init-fill-config\",\n          children: _jsx(InlineCode, {\n            children: \"init fill-config\"\n          })\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"python -m spacy init fill-config config-v3.0.cfg config-v3.1.cfg\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In many cases (\", _jsx(InlineCode, {\n          children: \"spacy train\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"spacy.load()\"\n        }), \"), the new defaults will be filled\\nin automatically, but you’ll need to fill in the new settings to run\\n\", _jsx(_components.a, {\n          href: \"/api/cli#debug\",\n          children: _jsx(InlineCode, {\n            children: \"debug config\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/cli#debug-data\",\n          children: _jsx(InlineCode, {\n            children: \"debug data\"\n          })\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"source-vectors\",\n        children: \"Sourcing pipeline components with vectors \"\n      }), _jsxs(_components.p, {\n        children: [\"If you’re sourcing a pipeline component that requires static vectors (for\\nexample, a tagger or parser from an \", _jsx(InlineCode, {\n          children: \"md\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"lg\"\n        }), \" pretrained pipeline), be sure\\nto include the source model’s vectors in the setting \", _jsx(InlineCode, {\n          children: \"[initialize.vectors]\"\n        }), \". In\\nspaCy v3.0, a bug allowed vectors to be loaded implicitly through \", _jsx(InlineCode, {\n          children: \"source\"\n        }), \",\\nhowever in v3.1 this setting must be provided explicitly as\\n\", _jsx(InlineCode, {\n          children: \"[initialize.vectors]\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[components.ner]\\nsource = \\\"en_core_web_md\\\"\\n\\n[initialize]\\nvectors = \\\"en_core_web_md\\\"\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsx(_components.p, {\n          children: \"Each pipeline can only store one set of static vectors, so it’s not possible to\\nassemble a pipeline with components that were trained on different static\\nvectors.\"\n        })\n      }), _jsxs(_components.p, {\n        children: [_jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/cli#assemble\",\n          children: _jsx(InlineCode, {\n            children: \"spacy assemble\"\n          })\n        }), \" will\\nprovide warnings if the source and target pipelines don’t contain the same\\nvectors. If you are sourcing a rule-based component like an entity ruler or\\nlemmatizer that does not use the vectors as a model feature, then this warning\\ncan be safely ignored.\"]\n      }), _jsx(_components.h3, {\n        id: \"warnings\",\n        children: \"Warnings \"\n      }), _jsxs(_components.p, {\n        children: [\"Logger warnings have been converted to Python warnings. Use\\n\", _jsx(_components.a, {\n          href: \"https://docs.python.org/3/library/warnings.html#warnings.filterwarnings\",\n          children: _jsx(InlineCode, {\n            children: \"warnings.filterwarnings\"\n          })\n        }), \"\\nor the new helper method \", _jsx(InlineCode, {\n          children: \"spacy.errors.filter_warning(action, error_msg='')\"\n        }), \" to\\nmanage warnings.\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"What's New in v3.1","teaser":"New features and how to upgrade","menu":[["New Features","features"],["Upgrading Notes","upgrading"]]},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":{"slug":"/usage/v3-2","title":"New in v3.2"}},"__N_SSG":true}