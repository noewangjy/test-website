{"pageProps":{"title":"PhraseMatcher","teaser":"Match sequences of tokens, based on documents","tag":"class","source":"spacy/matcher/phrasematcher.pyx","version":2,"slug":"/api/phrasematcher","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Tag, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"PhraseMatcher\"\n        }), \" lets you efficiently match large terminology lists. While\\nthe \", _jsx(_components.a, {\n          href: \"/api/matcher\",\n          children: _jsx(InlineCode, {\n            children: \"Matcher\"\n          })\n        }), \" lets you match sequences based on lists of token\\ndescriptions, the \", _jsx(InlineCode, {\n          children: \"PhraseMatcher\"\n        }), \" accepts match patterns in the form of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"\\nobjects. See the \", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching#phrasematcher\",\n          children: \"usage guide\"\n        }), \" for\\nexamples.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"PhraseMatcher.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Create the rule-based \", _jsx(InlineCode, {\n          children: \"PhraseMatcher\"\n        }), \". Setting a different \", _jsx(InlineCode, {\n          children: \"attr\"\n        }), \" to match on\\nwill change the token attributes that will be compared to determine a match. By\\ndefault, the incoming \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" is checked for sequences of tokens with the same\\n\", _jsx(InlineCode, {\n          children: \"ORTH\"\n        }), \" value, i.e. the verbatim token text. Matching on the attribute \", _jsx(InlineCode, {\n          children: \"LOWER\"\n        }), \"\\nwill result in case-insensitive matching, since only the lowercase token texts\\nare compared. In theory, it’s also possible to match on sequences of the same\\npart-of-speech tags or dependency labels.\"]\n      }), _jsxs(_components.p, {\n        children: [\"If \", _jsx(InlineCode, {\n          children: \"validate=True\"\n        }), \" is set, additional validation is performed when pattern are\\nadded. At the moment, it will check whether a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" has attributes assigned that\\naren’t necessary to produce the matches (for example, part-of-speech tags if the\\n\", _jsx(InlineCode, {\n          children: \"PhraseMatcher\"\n        }), \" matches on the token text). Since this can often lead to\\nsignificantly worse performance when creating the pattern, a \", _jsx(InlineCode, {\n          children: \"UserWarning\"\n        }), \" will\\nbe shown.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import PhraseMatcher\\nmatcher = PhraseMatcher(nlp.vocab)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The vocabulary object, which must be shared with the documents the matcher will operate on. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token attribute to match on. Defaults to \", _jsx(InlineCode, {\n                children: \"ORTH\"\n              }), \", i.e. the verbatim token text. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Validate patterns added to the matcher. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"PhraseMatcher.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Find all token sequences matching the supplied patterns on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.matcher import PhraseMatcher\\n\\nmatcher = PhraseMatcher(nlp.vocab)\\nmatcher.add(\\\"OBAMA\\\", [nlp(\\\"Barack Obama\\\")])\\ndoc = nlp(\\\"Barack Obama lifts America one last time in emotional farewell\\\")\\nmatches = matcher(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doclike\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" to match over. \", _jsx(_components.del, {\n                children: \"Union[Doc, Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"as_spans\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Instead of tuples, return a list of \", _jsx(_components.a, {\n                href: \"/api/span\",\n                children: _jsx(InlineCode, {\n                  children: \"Span\"\n                })\n              }), \" objects of the matches, with the \", _jsx(InlineCode, {\n                children: \"match_id\"\n              }), \" assigned as the span label. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of \", _jsx(InlineCode, {\n                children: \"(match_id, start, end)\"\n              }), \" tuples, describing the matches. A match tuple describes a span \", _jsx(InlineCode, {\n                children: \"doc[start:end\"\n              }), \"]. The \", _jsx(InlineCode, {\n                children: \"match_id\"\n              }), \" is the ID of the added match pattern. If \", _jsx(InlineCode, {\n                children: \"as_spans\"\n              }), \" is set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", a list of \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects is returned instead. \", _jsx(_components.del, {\n                children: \"Union[List[Tuple[int, int, int]], List[Span]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(Infobox, {\n        title: \"Note on retrieving the string representation of the match_id\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"Because spaCy stores all strings as integers, the \", _jsx(InlineCode, {\n            children: \"match_id\"\n          }), \" you get back will\\nbe an integer, too – but you can always get the string representation by looking\\nit up in the vocabulary’s \", _jsx(InlineCode, {\n            children: \"StringStore\"\n          }), \", i.e. \", _jsx(InlineCode, {\n            children: \"nlp.vocab.strings\"\n          }), \":\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"match_id_string = nlp.vocab.strings[match_id]\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"PhraseMatcher.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"Get the number of rules added to the matcher. Note that this only returns the\\nnumber of rules (identical with the number of IDs), not the number of individual\\npatterns.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"  matcher = PhraseMatcher(nlp.vocab)\\n  assert len(matcher) == 0\\n  matcher.add(\\\"OBAMA\\\", [nlp(\\\"Barack Obama\\\")])\\n  assert len(matcher) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rules. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-contains\",\n      children: [_jsx(_components.h2, {\n        id: \"contains\",\n        tag: \"method\",\n        children: \"PhraseMatcher.__contains__ \"\n      }), _jsx(_components.p, {\n        children: \"Check whether the matcher contains rules for a match ID.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"  matcher = PhraseMatcher(nlp.vocab)\\n  assert \\\"OBAMA\\\" not in matcher\\n  matcher.add(\\\"OBAMA\\\", [nlp(\\\"Barack Obama\\\")])\\n  assert \\\"OBAMA\\\" in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The match ID. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the matcher contains rules for this match ID. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add\",\n      children: [_jsx(_components.h2, {\n        id: \"add\",\n        tag: \"method\",\n        children: \"PhraseMatcher.add \"\n      }), _jsxs(_components.p, {\n        children: [\"Add a rule to the matcher, consisting of an ID key, one or more patterns, and a\\ncallback function to act on the matches. The callback function will receive the\\narguments \", _jsx(InlineCode, {\n          children: \"matcher\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"i\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"matches\"\n        }), \". If a pattern already exists for\\nthe given ID, the patterns will be extended. An \", _jsx(InlineCode, {\n          children: \"on_match\"\n        }), \" callback will be\\noverwritten.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"  def on_match(matcher, doc, id, matches):\\n      print('Matched!', matches)\\n\\n  matcher = PhraseMatcher(nlp.vocab)\\n  matcher.add(\\\"OBAMA\\\", [nlp(\\\"Barack Obama\\\")], on_match=on_match)\\n  matcher.add(\\\"HEALTH\\\", [nlp(\\\"health care reform\\\"), nlp(\\\"healthcare reform\\\")], on_match=on_match)\\n  doc = nlp(\\\"Barack Obama urges Congress to find courage to defend his healthcare reforms\\\")\\n  matches = matcher(doc)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"As of spaCy v3.0, \", _jsx(InlineCode, {\n            children: \"PhraseMatcher.add\"\n          }), \" takes a list of patterns as the second\\nargument (instead of a variable number of arguments). The \", _jsx(InlineCode, {\n            children: \"on_match\"\n          }), \" callback\\nbecomes an optional keyword argument.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"patterns = [nlp(\\\"health care reform\\\"), nlp(\\\"healthcare reform\\\")]\\n- matcher.add(\\\"HEALTH\\\", on_match, *patterns)\\n+ matcher.add(\\\"HEALTH\\\", patterns, on_match=on_match)\\n\"\n          })\n        })]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An ID for the thing you’re matching. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" objects of the phrases to match. \", _jsx(_components.del, {\n                children: \"List[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"on_match\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Callback function to act on matches. Takes the arguments \", _jsx(InlineCode, {\n                children: \"matcher\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"doc\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"i\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"matches\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Matcher, Doc, int, List[tuple], Any]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove\",\n      children: [_jsx(_components.h2, {\n        id: \"remove\",\n        tag: \"method\",\n        version: \"2.2\",\n        children: \"PhraseMatcher.remove \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove a rule from the matcher by match ID. A \", _jsx(InlineCode, {\n          children: \"KeyError\"\n        }), \" is raised if the key\\ndoes not exist.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"matcher = PhraseMatcher(nlp.vocab)\\nmatcher.add(\\\"OBAMA\\\", [nlp(\\\"Barack Obama\\\")])\\nassert \\\"OBAMA\\\" in matcher\\nmatcher.remove(\\\"OBAMA\\\")\\nassert \\\"OBAMA\\\" not in matcher\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the match rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"PhraseMatcher","teaser":"Match sequences of tokens, based on documents","tag":"class","source":"spacy/matcher/phrasematcher.pyx","version":2},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}