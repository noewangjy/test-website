{"pageProps":{"title":"Example","teaser":"A training instance","tag":"class","source":"spacy/training/example.pyx","version":3,"slug":"/api/example","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"An \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" holds the information for one training instance. It stores two\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects: one for holding the gold-standard reference data, and one for\\nholding the predictions of the pipeline. An\\n\", _jsx(_components.a, {\n          href: \"/api/example#alignment-object\",\n          children: _jsx(InlineCode, {\n            children: \"Alignment\"\n          })\n        }), \" object stores the alignment between\\nthese two documents, as they can differ in tokenization.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Example.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Construct an \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" object from the \", _jsx(InlineCode, {\n          children: \"predicted\"\n        }), \" document and the \", _jsx(InlineCode, {\n          children: \"reference\"\n        }), \"\\ndocument. If \", _jsx(InlineCode, {\n          children: \"alignment\"\n        }), \" is \", _jsx(InlineCode, {\n          children: \"None\"\n        }), \", it will be initialized from the words in\\nboth documents.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nfrom spacy.training import Example\\npred_words = [\\\"Apply\\\", \\\"some\\\", \\\"sunscreen\\\"]\\npred_spaces = [True, True, False]\\ngold_words = [\\\"Apply\\\", \\\"some\\\", \\\"sun\\\", \\\"screen\\\"]\\ngold_spaces = [True, True, False, False]\\ngold_tags = [\\\"VERB\\\", \\\"DET\\\", \\\"NOUN\\\", \\\"NOUN\\\"]\\npredicted = Doc(nlp.vocab, words=pred_words, spaces=pred_spaces)\\nreference = Doc(nlp.vocab, words=gold_words, spaces=gold_spaces, tags=gold_tags)\\nexample = Example(predicted, reference)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"predicted\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing (partial) predictions. Cannot be \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"reference\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing gold-standard annotations. Cannot be \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"alignment\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An object holding the alignment between the tokens of the \", _jsx(InlineCode, {\n                children: \"predicted\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"reference\"\n              }), \" documents. \", _jsx(_components.del, {\n                children: \"Optional[Alignment]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_dict\",\n      children: [_jsx(_components.h2, {\n        id: \"from_dict\",\n        tag: \"classmethod\",\n        children: \"Example.from_dict \"\n      }), _jsxs(_components.p, {\n        children: [\"Construct an \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" object from the \", _jsx(InlineCode, {\n          children: \"predicted\"\n        }), \" document and the reference\\nannotations provided as a dictionary. For more details on the required format,\\nsee the \", _jsx(_components.a, {\n          href: \"/api/data-formats#dict-input\",\n          children: \"training format documentation\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nfrom spacy.training import Example\\n\\npredicted = Doc(vocab, words=[\\\"Apply\\\", \\\"some\\\", \\\"sunscreen\\\"])\\ntoken_ref = [\\\"Apply\\\", \\\"some\\\", \\\"sun\\\", \\\"screen\\\"]\\ntags_ref = [\\\"VERB\\\", \\\"DET\\\", \\\"NOUN\\\", \\\"NOUN\\\"]\\nexample = Example.from_dict(predicted, {\\\"words\\\": token_ref, \\\"tags\\\": tags_ref})\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"predicted\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing (partial) predictions. Cannot be \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"example_dict\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The gold-standard annotations as a dictionary. Cannot be \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The newly constructed object. \", _jsx(_components.del, {\n                children: \"Example\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-text\",\n      children: [_jsx(_components.h2, {\n        id: \"text\",\n        tag: \"property\",\n        children: \"Example.text \"\n      }), _jsxs(_components.p, {\n        children: [\"The text of the \", _jsx(InlineCode, {\n          children: \"predicted\"\n        }), \" document in this \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"raw_text = example.text\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The text of the \", _jsx(InlineCode, {\n                children: \"predicted\"\n              }), \" document. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-predicted\",\n      children: [_jsx(_components.h2, {\n        id: \"predicted\",\n        tag: \"property\",\n        children: \"Example.predicted \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" holding the predictions. Occasionally also referred to as \", _jsx(InlineCode, {\n          children: \"example.x\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"docs = [eg.predicted for eg in examples]\\npredictions, _ = model.begin_update(docs)\\nset_annotations(docs, predictions)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing (partial) predictions. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-reference\",\n      children: [_jsx(_components.h2, {\n        id: \"reference\",\n        tag: \"property\",\n        children: \"Example.reference \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" holding the gold-standard annotations. Occasionally also referred to\\nas \", _jsx(InlineCode, {\n          children: \"example.y\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"for i, eg in enumerate(examples):\\n    for j, label in enumerate(all_labels):\\n        gold_labels[i][j] = eg.reference.cats.get(label, 0.0)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-alignment\",\n      children: [_jsx(_components.h2, {\n        id: \"alignment\",\n        tag: \"property\",\n        children: \"Example.alignment \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/example#alignment-object\",\n          children: _jsx(InlineCode, {\n            children: \"Alignment\"\n          })\n        }), \" object mapping the tokens of\\nthe \", _jsx(InlineCode, {\n          children: \"predicted\"\n        }), \" document to those of the \", _jsx(InlineCode, {\n          children: \"reference\"\n        }), \" document.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"tokens_x = [\\\"Apply\\\", \\\"some\\\", \\\"sunscreen\\\"]\\nx = Doc(vocab, words=tokens_x)\\ntokens_y = [\\\"Apply\\\", \\\"some\\\", \\\"sun\\\", \\\"screen\\\"]\\nexample = Example.from_dict(x, {\\\"words\\\": tokens_y})\\nalignment = example.alignment\\nassert list(alignment.y2x.data) == [[0], [1], [2], [2]]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document containing gold-standard annotations. \", _jsx(_components.del, {\n                children: \"Alignment\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_aligned\",\n      children: [_jsx(_components.h2, {\n        id: \"get_aligned\",\n        tag: \"method\",\n        children: \"Example.get_aligned \"\n      }), _jsx(_components.p, {\n        children: \"Get the aligned view of a certain token attribute, denoted by its int ID or\\nstring name.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"predicted = Doc(vocab, words=[\\\"Apply\\\", \\\"some\\\", \\\"sunscreen\\\"])\\ntoken_ref = [\\\"Apply\\\", \\\"some\\\", \\\"sun\\\", \\\"screen\\\"]\\ntags_ref = [\\\"VERB\\\", \\\"DET\\\", \\\"NOUN\\\", \\\"NOUN\\\"]\\nexample = Example.from_dict(predicted, {\\\"words\\\": token_ref, \\\"tags\\\": tags_ref})\\nassert example.get_aligned(\\\"TAG\\\", as_string=True) == [\\\"VERB\\\", \\\"DET\\\", \\\"NOUN\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"field\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attribute ID or string name. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"as_string\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether or not to return the list of values as strings. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of integer values, or string values if \", _jsx(InlineCode, {\n                children: \"as_string\"\n              }), \" is \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[List[int], List[str]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_aligned_parse\",\n      children: [_jsx(_components.h2, {\n        id: \"get_aligned_parse\",\n        tag: \"method\",\n        children: \"Example.get_aligned_parse \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the aligned view of the dependency parse. If \", _jsx(InlineCode, {\n          children: \"projectivize\"\n        }), \" is set to\\n\", _jsx(InlineCode, {\n          children: \"True\"\n        }), \", non-projective dependency trees are made projective through the\\nPseudo-Projective Dependency Parsing algorithm by Nivre and Nilsson (2005).\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"He pretty quickly walks away\\\")\\nexample = Example.from_dict(doc, {\\\"heads\\\": [3, 2, 3, 0, 2]})\\nproj_heads, proj_labels = example.get_aligned_parse(projectivize=True)\\nassert proj_heads == [3, 2, 3, 0, 3]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"projectivize\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether or not to projectivize the dependency trees. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of integer values, or string values if \", _jsx(InlineCode, {\n                children: \"as_string\"\n              }), \" is \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[List[int], List[str]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_aligned_ner\",\n      children: [_jsx(_components.h2, {\n        id: \"get_aligned_ner\",\n        tag: \"method\",\n        children: \"Example.get_aligned_ner \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the aligned view of the NER\\n\", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#accessing-ner\",\n          children: \"BILUO\"\n        }), \" tags.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"words = [\\\"Mrs\\\", \\\"Smith\\\", \\\"flew\\\", \\\"to\\\", \\\"New York\\\"]\\ndoc = Doc(en_vocab, words=words)\\nentities = [(0, 9, \\\"PERSON\\\"), (18, 26, \\\"LOC\\\")]\\ngold_words = [\\\"Mrs Smith\\\", \\\"flew\\\", \\\"to\\\", \\\"New\\\", \\\"York\\\"]\\nexample = Example.from_dict(doc, {\\\"words\\\": gold_words, \\\"entities\\\": entities})\\nner_tags = example.get_aligned_ner()\\nassert ner_tags == [\\\"B-PERSON\\\", \\\"L-PERSON\\\", \\\"O\\\", \\\"O\\\", \\\"U-LOC\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of BILUO values, denoting whether tokens are part of an NER annotation or not. \", _jsx(_components.del, {\n                children: \"List[str]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_aligned_spans_y2x\",\n      children: [_jsx(_components.h2, {\n        id: \"get_aligned_spans_y2x\",\n        tag: \"method\",\n        children: \"Example.get_aligned_spans_y2x \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the aligned view of any set of \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" objects defined over\\n\", _jsx(_components.a, {\n          href: \"/api/example#reference\",\n          children: _jsx(InlineCode, {\n            children: \"Example.reference\"\n          })\n        }), \". The resulting span indices will\\nalign to the tokenization in \", _jsx(_components.a, {\n          href: \"/api/example#predicted\",\n          children: _jsx(InlineCode, {\n            children: \"Example.predicted\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"words = [\\\"Mr and Mrs Smith\\\", \\\"flew\\\", \\\"to\\\", \\\"New York\\\"]\\ndoc = Doc(en_vocab, words=words)\\nentities = [(0, 16, \\\"PERSON\\\")]\\ntokens_ref = [\\\"Mr\\\", \\\"and\\\", \\\"Mrs\\\", \\\"Smith\\\", \\\"flew\\\", \\\"to\\\", \\\"New\\\", \\\"York\\\"]\\nexample = Example.from_dict(doc, {\\\"words\\\": tokens_ref, \\\"entities\\\": entities})\\nents_ref = example.reference.ents\\nassert [(ent.start, ent.end) for ent in ents_ref] == [(0, 4)]\\nents_y2x = example.get_aligned_spans_y2x(ents_ref)\\nassert [(ent.start, ent.end) for ent in ents_y2x] == [(0, 1)]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"y_spans\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects aligned to the tokenization of \", _jsx(InlineCode, {\n                children: \"reference\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"allow_overlap\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the resulting \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects may overlap or not. Set to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" by default. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects aligned to the tokenization of \", _jsx(InlineCode, {\n                children: \"predicted\"\n              }), \". \", _jsx(_components.del, {\n                children: \"List[Span]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_aligned_spans_x2y\",\n      children: [_jsx(_components.h2, {\n        id: \"get_aligned_spans_x2y\",\n        tag: \"method\",\n        children: \"Example.get_aligned_spans_x2y \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the aligned view of any set of \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" objects defined over\\n\", _jsx(_components.a, {\n          href: \"/api/example#predicted\",\n          children: _jsx(InlineCode, {\n            children: \"Example.predicted\"\n          })\n        }), \". The resulting span indices will\\nalign to the tokenization in \", _jsx(_components.a, {\n          href: \"/api/example#reference\",\n          children: _jsx(InlineCode, {\n            children: \"Example.reference\"\n          })\n        }), \". This\\nmethod is particularly useful to assess the accuracy of predicted entities\\nagainst the original gold-standard annotation.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp.add_pipe(\\\"my_ner\\\")\\ndoc = nlp(\\\"Mr and Mrs Smith flew to New York\\\")\\ntokens_ref = [\\\"Mr and Mrs\\\", \\\"Smith\\\", \\\"flew\\\", \\\"to\\\", \\\"New York\\\"]\\nexample = Example.from_dict(doc, {\\\"words\\\": tokens_ref})\\nents_pred = example.predicted.ents\\n# Assume the NER model has found \\\"Mr and Mrs Smith\\\" as a named entity\\nassert [(ent.start, ent.end) for ent in ents_pred] == [(0, 4)]\\nents_x2y = example.get_aligned_spans_x2y(ents_pred)\\nassert [(ent.start, ent.end) for ent in ents_x2y] == [(0, 2)]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"x_spans\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects aligned to the tokenization of \", _jsx(InlineCode, {\n                children: \"predicted\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"allow_overlap\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the resulting \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects may overlap or not. Set to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" by default. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"Span\"\n              }), \" objects aligned to the tokenization of \", _jsx(InlineCode, {\n                children: \"reference\"\n              }), \". \", _jsx(_components.del, {\n                children: \"List[Span]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_dict\",\n      children: [_jsx(_components.h2, {\n        id: \"to_dict\",\n        tag: \"method\",\n        children: \"Example.to_dict \"\n      }), _jsxs(_components.p, {\n        children: [\"Return a \", _jsx(_components.a, {\n          href: \"/api/data-formats#dict-input\",\n          children: \"dictionary representation\"\n        }), \" of the\\nreference annotation contained in this \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"eg_dict = example.to_dict()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Dictionary representation of the reference annotation. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-split_sents\",\n      children: [_jsx(_components.h2, {\n        id: \"split_sents\",\n        tag: \"method\",\n        children: \"Example.split_sents \"\n      }), _jsxs(_components.p, {\n        children: [\"Split one \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" into multiple \", _jsx(InlineCode, {\n          children: \"Example\"\n        }), \" objects, one for each sentence.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I went yesterday had lots of fun\\\")\\ntokens_ref = [\\\"I\\\", \\\"went\\\", \\\"yesterday\\\", \\\"had\\\", \\\"lots\\\", \\\"of\\\", \\\"fun\\\"]\\nsents_ref = [True, False, False, True, False, False, False]\\nexample = Example.from_dict(doc, {\\\"words\\\": tokens_ref, \\\"sent_starts\\\": sents_ref})\\nsplit_examples = example.split_sents()\\nassert split_examples[0].text == \\\"I went yesterday \\\"\\nassert split_examples[1].text == \\\"had lots of fun\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of \", _jsx(InlineCode, {\n                children: \"Example\"\n              }), \" objects, one for each original sentence. \", _jsx(_components.del, {\n                children: \"List[Example]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-alignment-object\",\n      children: [_jsx(_components.h2, {\n        id: \"alignment-object\",\n        version: \"3\",\n        children: \"Alignment \"\n      }), _jsx(_components.p, {\n        children: \"Calculate alignment tables between two tokenizations.\"\n      }), _jsx(_components.h3, {\n        id: \"alignment-attributes\",\n        children: \"Alignment attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"Alignment attributes are managed using \", _jsx(InlineCode, {\n          children: \"AlignmentArray\"\n        }), \", which is a simplified\\nversion of Thinc’s \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-types#ragged\",\n          children: \"Ragged\"\n        }), \" type that\\nonly supports the \", _jsx(InlineCode, {\n          children: \"data\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"length\"\n        }), \" attributes.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"x2y\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"AlignmentArray\"\n              }), \" object holding the alignment from \", _jsx(InlineCode, {\n                children: \"x\"\n              }), \" to \", _jsx(InlineCode, {\n                children: \"y\"\n              }), \". \", _jsx(_components.del, {\n                children: \"AlignmentArray\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"y2x\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"AlignmentArray\"\n              }), \" object holding the alignment from \", _jsx(InlineCode, {\n                children: \"y\"\n              }), \" to \", _jsx(InlineCode, {\n                children: \"x\"\n              }), \". \", _jsx(_components.del, {\n                children: \"AlignmentArray\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"The current implementation of the alignment algorithm assumes that both\\ntokenizations add up to the same string. For example, you’ll be able to align\\n\", _jsx(InlineCode, {\n            children: \"[\\\"I\\\", \\\"'\\\", \\\"m\\\"]\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"[\\\"I\\\", \\\"'m\\\"]\"\n          }), \", which both add up to \", _jsx(InlineCode, {\n            children: \"\\\"I'm\\\"\"\n          }), \", but not\\n\", _jsx(InlineCode, {\n            children: \"[\\\"I\\\", \\\"'m\\\"]\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"[\\\"I\\\", \\\"am\\\"]\"\n          }), \".\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.training import Alignment\\n\\nbert_tokens = [\\\"obama\\\", \\\"'\\\", \\\"s\\\", \\\"podcast\\\"]\\nspacy_tokens = [\\\"obama\\\", \\\"'s\\\", \\\"podcast\\\"]\\nalignment = Alignment.from_strings(bert_tokens, spacy_tokens)\\na2b = alignment.x2y\\nassert list(a2b.data) == [0, 1, 1, 2]\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"If \", _jsx(InlineCode, {\n            children: \"a2b.data[1] == a2b.data[2] == 1\"\n          }), \", that means that \", _jsx(InlineCode, {\n            children: \"A[1]\"\n          }), \" (\", _jsx(InlineCode, {\n            children: \"\\\"'\\\"\"\n          }), \") and\\n\", _jsx(InlineCode, {\n            children: \"A[2]\"\n          }), \" (\", _jsx(InlineCode, {\n            children: \"\\\"s\\\"\"\n          }), \") both align to \", _jsx(InlineCode, {\n            children: \"B[1]\"\n          }), \" (\", _jsx(InlineCode, {\n            children: \"\\\"'s\\\"\"\n          }), \").\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"classmethod\",\n        tag: \"function\",\n        children: \"Alignment.from_strings \"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"A\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String values of candidate tokens to align. \", _jsx(_components.del, {\n                children: \"List[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"B\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String values of reference tokens to align. \", _jsx(_components.del, {\n                children: \"List[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An \", _jsx(InlineCode, {\n                children: \"Alignment\"\n              }), \" object describing the alignment. \", _jsx(_components.del, {\n                children: \"Alignment\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Example","teaser":"A training instance","tag":"class","source":"spacy/training/example.pyx","version":3},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}