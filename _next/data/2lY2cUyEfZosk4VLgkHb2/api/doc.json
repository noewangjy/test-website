{"pageProps":{"title":"Doc","tag":"class","teaser":"A container for accessing linguistic annotations.","source":"spacy/tokens/doc.pyx","slug":"/api/doc","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {InlineCode, Tag, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"A \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" is a sequence of \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \" objects. Access sentences and\\nnamed entities, export annotations to numpy arrays, losslessly serialize to\\ncompressed binary strings. The \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object holds an array of\\n\", _jsx(_components.a, {\n          href: \"/api/cython-structs#tokenc\",\n          children: _jsx(InlineCode, {\n            children: \"TokenC\"\n          })\n        }), \" structs. The Python-level \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" objects are views of this array, i.e. they don’t own the\\ndata themselves.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"Doc.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Construct a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object. The most common way to get a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object is via the\\n\", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction 1\\ndoc = nlp(\\\"Some text\\\")\\n\\n# Construction 2\\nfrom spacy.tokens import Doc\\n\\nwords = [\\\"hello\\\", \\\"world\\\", \\\"!\\\"]\\nspaces = [True, False, False]\\ndoc = Doc(nlp.vocab, words=words, spaces=spaces)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A storage container for lexical types. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"words\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings or integer hash values to add to the document as words. \", _jsx(_components.del, {\n                children: \"Optional[List[Union[str,int]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spaces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of boolean values indicating whether each word has a subsequent space. Must have the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", if specified. Defaults to a sequence of \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[bool]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional extra data to attach to the Doc. \", _jsx(_components.del, {\n                children: \"Dict\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"tags\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.tag\"\n              }), \" for each word. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"pos\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.pos\"\n              }), \" for each word. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"morphs\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.morph\"\n              }), \" for each word. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"lemmas\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.lemma\"\n              }), \" for each word. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"heads\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of values, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as the head for each word. Head indices are the absolute position of the head in the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[int]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"deps\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.dep\"\n              }), \" for each word. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"sent_starts\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of values, of the same length as \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign as \", _jsx(InlineCode, {\n                children: \"token.is_sent_start\"\n              }), \". Will be overridden by heads if \", _jsx(InlineCode, {\n                children: \"heads\"\n              }), \" is provided. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[Union[bool, int, None]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"ents\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"A list of strings, of the same length of \", _jsx(InlineCode, {\n                children: \"words\"\n              }), \", to assign the token-based IOB tag. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-getitem\",\n      children: [_jsx(_components.h2, {\n        id: \"getitem\",\n        tag: \"method\",\n        children: \"Doc.__getitem__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Get a \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \" object at position \", _jsx(InlineCode, {\n          children: \"i\"\n        }), \", where \", _jsx(InlineCode, {\n          children: \"i\"\n        }), \" is an integer.\\nNegative indexing is supported, and follows the usual Python semantics, i.e.\\n\", _jsx(InlineCode, {\n          children: \"doc[-2]\"\n        }), \" is \", _jsx(InlineCode, {\n          children: \"doc[len(doc) - 2]\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\nassert doc[0].text == \\\"Give\\\"\\nassert doc[-1].text == \\\".\\\"\\nspan = doc[1:3]\\nassert span.text == \\\"it back\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"i\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token at \", _jsx(InlineCode, {\n                children: \"doc[i]\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"Get a \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" object, starting at position \", _jsx(InlineCode, {\n          children: \"start\"\n        }), \" (token index) and\\nending at position \", _jsx(InlineCode, {\n          children: \"end\"\n        }), \" (token index). For instance, \", _jsx(InlineCode, {\n          children: \"doc[2:5]\"\n        }), \" produces a span\\nconsisting of tokens 2, 3 and 4. Stepped slices (e.g. \", _jsx(InlineCode, {\n          children: \"doc[start : end : step]\"\n        }), \")\\nare not supported, as \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" objects must be contiguous (cannot have gaps). You\\ncan use negative indices and open-ended ranges, which have their normal Python\\nsemantics.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"start_end\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The slice of the document to get. \", _jsx(_components.del, {\n                children: \"Tuple[int, int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The span at \", _jsx(InlineCode, {\n                children: \"doc[start:end]\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Span\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-iter\",\n      children: [_jsx(_components.h2, {\n        id: \"iter\",\n        tag: \"method\",\n        children: \"Doc.__iter__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Iterate over \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" objects, from which the annotations can be easily accessed.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back\\\")\\nassert [t.text for t in doc] == [\\\"Give\\\", \\\"it\\\", \\\"back\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"This is the main way of accessing \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \" objects, which are the\\nmain way annotations are accessed from Python. If faster-than-Python speeds are\\nrequired, you can instead access the annotations as a numpy array, or access the\\nunderlying C data directly from Cython.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"Doc.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"Get the number of tokens in the document.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\nassert len(doc) == 7\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tokens in the document. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"set_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Doc.set_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Define a custom attribute on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" which becomes available via \", _jsx(InlineCode, {\n          children: \"Doc._\"\n        }), \". For\\ndetails, see the documentation on\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-attributes\",\n          children: \"custom attributes\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\ncity_getter = lambda doc: any(city in doc.text for city in (\\\"New York\\\", \\\"Paris\\\", \\\"Berlin\\\"))\\nDoc.set_extension(\\\"has_city\\\", getter=city_getter)\\ndoc = nlp(\\\"I like New York\\\")\\nassert doc._.has_city\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the attribute to set by the extension. For example, \", _jsx(InlineCode, {\n                children: \"\\\"my_attr\\\"\"\n              }), \" will be available as \", _jsx(InlineCode, {\n                children: \"doc._.my_attr\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"default\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional default value of the attribute if no getter or method is defined. \", _jsx(_components.del, {\n                children: \"Optional[Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"method\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Set a custom method on the object, for example \", _jsx(InlineCode, {\n                children: \"doc._.compare(other_doc)\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Doc, …], Any]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"getter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Getter function that takes the object and returns an attribute value. Is called when the user accesses the \", _jsx(InlineCode, {\n                children: \"._\"\n              }), \" attribute. \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Doc], Any]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"setter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Setter function that takes the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" and a value, and modifies the object. Is called when the user writes to the \", _jsx(InlineCode, {\n                children: \"Doc._\"\n              }), \" attribute. \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Doc, Any], None]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"force\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Force overwriting existing attribute. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"get_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Doc.get_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Look up a previously registered extension by name. Returns a 4-tuple\\n\", _jsx(InlineCode, {\n          children: \"(default, method, getter, setter)\"\n        }), \" if the extension is registered. Raises a\\n\", _jsx(InlineCode, {\n          children: \"KeyError\"\n        }), \" otherwise.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nDoc.set_extension(\\\"has_city\\\", default=False)\\nextension = Doc.get_extension(\\\"has_city\\\")\\nassert extension == (False, None, None, None)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"(default, method, getter, setter)\"\n              }), \" tuple of the extension. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Any], Optional[Callable], Optional[Callable], Optional[Callable]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"has_extension\",\n        tag: \"classmethod\",\n        version: \"2\",\n        children: \"Doc.has_extension \"\n      }), _jsxs(_components.p, {\n        children: [\"Check whether an extension has been registered on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" class.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nDoc.set_extension(\\\"has_city\\\", default=False)\\nassert Doc.has_extension(\\\"has_city\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension to check. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the extension has been registered. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove_extension\",\n      children: [_jsx(_components.h2, {\n        id: \"remove_extension\",\n        tag: \"classmethod\",\n        version: \"2.0.12\",\n        children: \"Doc.remove_extension \"\n      }), _jsx(_components.p, {\n        children: \"Remove a previously registered extension.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nDoc.set_extension(\\\"has_city\\\", default=False)\\nremoved = Doc.remove_extension(\\\"has_city\\\")\\nassert not Doc.has_extension(\\\"has_city\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Name of the extension. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"(default, method, getter, setter)\"\n              }), \" tuple of the removed extension. \", _jsx(_components.del, {\n                children: \"Tuple[Optional[Any], Optional[Callable], Optional[Callable], Optional[Callable]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-char_span\",\n      children: [_jsx(_components.h2, {\n        id: \"char_span\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Doc.char_span \"\n      }), _jsxs(_components.p, {\n        children: [\"Create a \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" object from the slice \", _jsx(InlineCode, {\n          children: \"doc.text[start_idx:end_idx]\"\n        }), \". Returns\\n\", _jsx(InlineCode, {\n          children: \"None\"\n        }), \" if the character indices don’t map to a valid span using the default\\nalignment mode `“strict”.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like New York\\\")\\nspan = doc.char_span(7, 15, label=\\\"GPE\\\")\\nassert span.text == \\\"New York\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"start\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the first character of the span. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"end\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the last character after the span. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A label to attach to the span, e.g. for named entities. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"kb_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An ID from a knowledge base to capture the meaning of a named entity. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vector\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A meaning representation of the span. \", _jsx(_components.del, {\n                children: \"numpy.ndarray[ndim=1, dtype=float32]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"alignment_mode\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"How character indices snap to token boundaries. Options: \", _jsx(InlineCode, {\n                children: \"\\\"strict\\\"\"\n              }), \" (no snapping), \", _jsx(InlineCode, {\n                children: \"\\\"contract\\\"\"\n              }), \" (span of all tokens completely within the character span), \", _jsx(InlineCode, {\n                children: \"\\\"expand\\\"\"\n              }), \" (span of all tokens at least partially covered by the character span). Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"strict\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"span_id\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.3.1\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"An identifier to associate with the span. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The newly constructed object or \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Span]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-set_ents\",\n      children: [_jsx(_components.h2, {\n        id: \"set_ents\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"Doc.set_ents \"\n      }), _jsx(_components.p, {\n        children: \"Set the named entities in the document.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Span\\ndoc = nlp(\\\"Mr. Best flew to New York on Saturday morning.\\\")\\ndoc.set_ents([Span(doc, 0, 2, \\\"PERSON\\\")])\\nents = list(doc.ents)\\nassert ents[0].label_ == \\\"PERSON\\\"\\nassert ents[0].text == \\\"Mr. Best\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entities\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Spans with labels to set as entities. \", _jsx(_components.del, {\n                children: \"List[Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"blocked\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Spans to set as “blocked” (never an entity) for spacy’s built-in NER component. Other components may ignore this setting. \", _jsx(_components.del, {\n                children: \"Optional[List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"missing\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Spans with missing/unknown entity information. \", _jsx(_components.del, {\n                children: \"Optional[List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"outside\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Spans outside of entities (O in IOB). \", _jsx(_components.del, {\n                children: \"Optional[List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"default\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"How to set entity annotation for tokens outside of any provided spans. Options: \", _jsx(InlineCode, {\n                children: \"\\\"blocked\\\"\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"\\\"missing\\\"\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"\\\"outside\\\"\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"\\\"unmodified\\\"\"\n              }), \" (preserve current state). Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"outside\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-similarity\",\n      children: [_jsx(_components.h2, {\n        id: \"similarity\",\n        tag: \"method\",\n        model: \"vectors\",\n        children: \"Doc.similarity \"\n      }), _jsx(_components.p, {\n        children: \"Make a semantic similarity estimate. The default estimate is cosine similarity\\nusing an average of word vectors.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"apples = nlp(\\\"I like apples\\\")\\noranges = nlp(\\\"I like oranges\\\")\\napples_oranges = apples.similarity(oranges)\\noranges_apples = oranges.similarity(apples)\\nassert apples_oranges == oranges_apples\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"other\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The object to compare with. By default, accepts \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"Lexeme\"\n              }), \" objects. \", _jsx(_components.del, {\n                children: \"Union[Doc, Span, Token, Lexeme]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A scalar similarity score. Higher is more similar. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-count_by\",\n      children: [_jsx(_components.h2, {\n        id: \"count_by\",\n        tag: \"method\",\n        children: \"Doc.count_by \"\n      }), _jsxs(_components.p, {\n        children: [\"Count the frequencies of a given attribute. Produces a dict of\\n\", _jsx(InlineCode, {\n          children: \"{attr (int): count (ints)}\"\n        }), \" frequencies, keyed by the values of the given\\nattribute ID.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs import ORTH\\ndoc = nlp(\\\"apple apple orange banana\\\")\\nassert doc.count_by(ORTH) == {7024: 1, 119552: 1, 2087: 2}\\ndoc.to_array([ORTH])\\n# array([[11880], [11880], [7561], [12800]])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute ID. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary mapping attributes to integer counts. \", _jsx(_components.del, {\n                children: \"Dict[int, int]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-get_lca_matrix\",\n      children: [_jsx(_components.h2, {\n        id: \"get_lca_matrix\",\n        tag: \"method\",\n        children: \"Doc.get_lca_matrix \"\n      }), _jsxs(_components.p, {\n        children: [\"Calculates the lowest common ancestor matrix for a given \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \". Returns LCA\\nmatrix containing the integer index of the ancestor, or \", _jsx(InlineCode, {\n          children: \"-1\"\n        }), \" if no common\\nancestor is found, e.g. if span excludes a necessary ancestor.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a test\\\")\\nmatrix = doc.get_lca_matrix()\\n# array([[0, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 3], [1, 1, 3, 3]], dtype=int32)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The lowest common ancestor matrix of the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \". \", _jsx(_components.del, {\n                children: \"numpy.ndarray[ndim=2, dtype=int32]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_annotation\",\n      children: [_jsx(_components.h2, {\n        id: \"has_annotation\",\n        tag: \"method\",\n        children: \"Doc.has_annotation \"\n      }), _jsxs(_components.p, {\n        children: [\"Check whether the doc contains annotation on a\\n\", _jsxs(_components.a, {\n          href: \"/api/token#attributes\",\n          children: [_jsx(InlineCode, {\n            children: \"Token\"\n          }), \" attribute\"]\n        }), \".\"]\n      }), _jsxs(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"This method replaces the previous boolean attributes like \", _jsx(InlineCode, {\n            children: \"Doc.is_tagged\"\n          }), \",\\n\", _jsx(InlineCode, {\n            children: \"Doc.is_parsed\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"Doc.is_sentenced\"\n          }), \".\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"doc = nlp(\\\"This is a text\\\")\\n- assert doc.is_parsed\\n+ assert doc.has_annotation(\\\"DEP\\\")\\n\"\n          })\n        })]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute string name or int ID. \", _jsx(_components.del, {\n                children: \"Union[int, str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"require_complete\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to check that the attribute is set on every token in the doc. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether specified annotation is present in the doc. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_array\",\n      children: [_jsx(_components.h2, {\n        id: \"to_array\",\n        tag: \"method\",\n        children: \"Doc.to_array \"\n      }), _jsxs(_components.p, {\n        children: [\"Export given token attributes to a numpy \", _jsx(InlineCode, {\n          children: \"ndarray\"\n        }), \". If \", _jsx(InlineCode, {\n          children: \"attr_ids\"\n        }), \" is a sequence\\nof \", _jsx(InlineCode, {\n          children: \"M\"\n        }), \" attributes, the output array will be of shape \", _jsx(InlineCode, {\n          children: \"(N, M)\"\n        }), \", where \", _jsx(InlineCode, {\n          children: \"N\"\n        }), \" is the\\nlength of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" (in tokens). If \", _jsx(InlineCode, {\n          children: \"attr_ids\"\n        }), \" is a single attribute, the output\\nshape will be \", _jsx(InlineCode, {\n          children: \"(N,)\"\n        }), \". You can specify attributes by integer ID (e.g.\\n\", _jsx(InlineCode, {\n          children: \"spacy.attrs.LEMMA\"\n        }), \") or string name (e.g. “LEMMA” or “lemma”). The values will\\nbe 64-bit integers.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Returns a 2D array with one row per token and one column per attribute (when\\n\", _jsx(InlineCode, {\n          children: \"attr_ids\"\n        }), \" is a list), or as a 1D numpy array, with one item per attribute (when\\n\", _jsx(InlineCode, {\n          children: \"attr_ids\"\n        }), \" is a single value).\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs import LOWER, POS, ENT_TYPE, IS_ALPHA\\ndoc = nlp(text)\\n# All strings mapped to integers, for easy export to numpy\\nnp_array = doc.to_array([LOWER, POS, ENT_TYPE, IS_ALPHA])\\nnp_array = doc.to_array(\\\"POS\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attr_ids\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of attributes (int IDs or string names) or a single attribute (int ID or string name). \", _jsx(_components.del, {\n                children: \"Union[int, str, List[Union[int, str]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The exported attributes as a numpy array. \", _jsx(_components.del, {\n                children: \"Union[numpy.ndarray[ndim=2, dtype=uint64], numpy.ndarray[ndim=1, dtype=uint64]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_array\",\n      children: [_jsx(_components.h2, {\n        id: \"from_array\",\n        tag: \"method\",\n        children: \"Doc.from_array \"\n      }), _jsxs(_components.p, {\n        children: [\"Load attributes from a numpy array. Write to a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object, from an \", _jsx(InlineCode, {\n          children: \"(M, N)\"\n        }), \"\\narray of attributes.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs import LOWER, POS, ENT_TYPE, IS_ALPHA\\nfrom spacy.tokens import Doc\\ndoc = nlp(\\\"Hello world!\\\")\\nnp_array = doc.to_array([LOWER, POS, ENT_TYPE, IS_ALPHA])\\ndoc2 = Doc(doc.vocab, words=[t.text for t in doc])\\ndoc2.from_array([LOWER, POS, ENT_TYPE, IS_ALPHA], np_array)\\nassert doc[0].pos_ == doc2[0].pos_\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of attribute ID ints. \", _jsx(_components.del, {\n                children: \"List[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"array\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attribute values to load. \", _jsx(_components.del, {\n                children: \"numpy.ndarray[ndim=2, dtype=int32]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" itself. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_docs\",\n      children: [_jsx(_components.h2, {\n        id: \"from_docs\",\n        tag: \"staticmethod\",\n        version: \"3\",\n        children: \"Doc.from_docs \"\n      }), _jsxs(_components.p, {\n        children: [\"Concatenate multiple \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects to form a new one. Raises an error if the\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects do not all share the same \", _jsx(InlineCode, {\n          children: \"Vocab\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\ntexts = [\\\"London is the capital of the United Kingdom.\\\",\\n         \\\"The River Thames flows through London.\\\",\\n         \\\"The famous Tower Bridge crosses the River Thames.\\\"]\\ndocs = list(nlp.pipe(texts))\\nc_doc = Doc.from_docs(docs)\\nassert str(c_doc) == \\\" \\\".join(texts)\\nassert len(list(c_doc.sents)) == len(docs)\\nassert [str(ent) for ent in c_doc.ents] == \\\\\\n       [str(ent) for doc in docs for ent in doc.ents]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"docs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" objects. \", _jsx(_components.del, {\n                children: \"List[Doc]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ensure_whitespace\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Insert a space between two adjacent docs whenever the first doc does not end in whitespace. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional list of attribute ID ints or attribute name strings. \", _jsx(_components.del, {\n                children: \"Optional[List[Union[str, int]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"exclude\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"String names of Doc attributes to exclude. Supported: \", _jsx(InlineCode, {\n                children: \"spans\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"tensor\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"user_data\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The new \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object that is containing the other docs or \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \", if \", _jsx(InlineCode, {\n                children: \"docs\"\n              }), \" is empty or \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Doc]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Doc.to_disk \"\n      }), _jsx(_components.p, {\n        children: \"Save the current state to a directory.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc.to_disk(\\\"/path/to/doc\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory, which will be created if it doesn’t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        version: \"2\",\n        children: \"Doc.from_disk \"\n      }), _jsx(_components.p, {\n        children: \"Loads state from a directory. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\nfrom spacy.vocab import Vocab\\ndoc = Doc(Vocab()).from_disk(\\\"/path/to/doc\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"Doc.to_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Serialize, i.e. export the document contents to a binary string.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Give it back! He pleaded.\\\")\\ndoc_bytes = doc.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A losslessly serialized copy of the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \", including all annotations. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"Doc.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Deserialize, i.e. import the document contents from a binary string.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\ndoc = nlp(\\\"Give it back! He pleaded.\\\")\\ndoc_bytes = doc.to_bytes()\\ndoc2 = Doc(doc.vocab).from_bytes(doc_bytes)\\nassert doc.text == doc2.text\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string to load from. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_json\",\n      children: [_jsx(_components.h2, {\n        id: \"to_json\",\n        tag: \"method\",\n        children: \"Doc.to_json \"\n      }), _jsxs(_components.p, {\n        children: [\"Serializes a document to JSON. Note that this is format differs from the\\ndeprecated \", _jsx(_components.a, {\n          href: \"/api/data-formats#json-input\",\n          children: _jsx(InlineCode, {\n            children: \"JSON training format\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"All we have to decide is what to do with the time that is given us.\\\")\\nassert doc.to_json()[\\\"text\\\"] == doc.text\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"underscore\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional list of string names of custom \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" attributes. Attribute values need to be JSON-serializable. Values will be added to an \", _jsx(InlineCode, {\n                children: \"\\\"_\\\"\"\n              }), \" key in the data, e.g. \", _jsx(InlineCode, {\n                children: \"\\\"_\\\": {\\\"foo\\\": \\\"bar\\\"}\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[List[str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The data in JSON format. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_json\",\n      children: [_jsx(_components.h2, {\n        id: \"from_json\",\n        tag: \"method\",\n        version: \"3.3.1\",\n        children: \"Doc.from_json \"\n      }), _jsxs(_components.p, {\n        children: [\"Deserializes a document from JSON, i.e. generates a document from the provided\\nJSON data as generated by \", _jsx(_components.a, {\n          href: \"/api/doc#to_json\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.to_json()\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import Doc\\ndoc = nlp(\\\"All we have to decide is what to do with the time that is given us.\\\")\\ndoc_json = doc.to_json()\\ndeserialized_doc = Doc(nlp.vocab).from_json(doc_json)\\nassert deserialized_doc.text == doc.text == doc_json[\\\"text\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc_json\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The Doc data in JSON format from \", _jsx(_components.a, {\n                href: \"#to_json\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.to_json\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to validate the JSON input against the expected schema for detailed debugging. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" corresponding to the provided JSON. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-retokenize\",\n      children: [_jsx(_components.h2, {\n        id: \"retokenize\",\n        tag: \"contextmanager\",\n        version: \"2.1\",\n        children: \"Doc.retokenize \"\n      }), _jsxs(_components.p, {\n        children: [\"Context manager to handle retokenization of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \". Modifications to the\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"’s tokenization are stored, and then made all at once when the context\\nmanager exits. This is much more efficient, and less error-prone. All views of\\nthe \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" (\", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \") created before the retokenization are\\ninvalidated, although they may accidentally continue to work.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Hello world!\\\")\\nwith doc.retokenize() as retokenizer:\\n    retokenizer.merge(doc[0:2])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The retokenizer. \", _jsx(_components.del, {\n                children: \"Retokenizer\"\n              })]\n            })]\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"retokenizer.merge\",\n        tag: \"method\",\n        children: \"Retokenizer.merge \"\n      }), _jsxs(_components.p, {\n        children: [\"Mark a span for merging. The \", _jsx(InlineCode, {\n          children: \"attrs\"\n        }), \" will be applied to the resulting token (if\\nthey’re context-dependent token attributes like \", _jsx(InlineCode, {\n          children: \"LEMMA\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"DEP\"\n        }), \") or to the\\nunderlying lexeme (if they’re context-independent lexical attributes like\\n\", _jsx(InlineCode, {\n          children: \"LOWER\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"IS_STOP\"\n        }), \"). Writable custom extension attributes can be provided\\nusing the \", _jsx(InlineCode, {\n          children: \"\\\"_\\\"\"\n        }), \" key and specifying a dictionary that maps attribute names to\\nvalues.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like David Bowie\\\")\\nwith doc.retokenize() as retokenizer:\\n    attrs = {\\\"LEMMA\\\": \\\"David Bowie\\\"}\\n    retokenizer.merge(doc[2:4], attrs=attrs)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"span\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The span to merge. \", _jsx(_components.del, {\n                children: \"Span\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attributes to set on the merged token. \", _jsx(_components.del, {\n                children: \"Dict[Union[str, int], Any]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"retokenizer.split\",\n        tag: \"method\",\n        children: \"Retokenizer.split \"\n      }), _jsxs(_components.p, {\n        children: [\"Mark a token for splitting, into the specified \", _jsx(InlineCode, {\n          children: \"orths\"\n        }), \". The \", _jsx(InlineCode, {\n          children: \"heads\"\n        }), \" are required\\nto specify how the new subtokens should be integrated into the dependency tree.\\nThe list of per-token heads can either be a token in the original document, e.g.\\n\", _jsx(InlineCode, {\n          children: \"doc[2]\"\n        }), \", or a tuple consisting of the token in the original document and its\\nsubtoken index. For example, \", _jsx(InlineCode, {\n          children: \"(doc[3], 1)\"\n        }), \" will attach the subtoken to the\\nsecond subtoken of \", _jsx(InlineCode, {\n          children: \"doc[3]\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"This mechanism allows attaching subtokens to other newly created subtokens,\\nwithout having to keep track of the changing token indices. If the specified\\nhead token will be split within the retokenizer block and no subtoken index is\\nspecified, it will default to \", _jsx(InlineCode, {\n          children: \"0\"\n        }), \". Attributes to set on subtokens can be\\nprovided as a list of values. They’ll be applied to the resulting token (if\\nthey’re context-dependent token attributes like \", _jsx(InlineCode, {\n          children: \"LEMMA\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"DEP\"\n        }), \") or to the\\nunderlying lexeme (if they’re context-independent lexical attributes like\\n\", _jsx(InlineCode, {\n          children: \"LOWER\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"IS_STOP\"\n        }), \").\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I live in NewYork\\\")\\nwith doc.retokenize() as retokenizer:\\n    heads = [(doc[3], 1), doc[2]]\\n    attrs = {\\\"POS\\\": [\\\"PROPN\\\", \\\"PROPN\\\"],\\n             \\\"DEP\\\": [\\\"pobj\\\", \\\"compound\\\"]}\\n    retokenizer.split(doc[3], [\\\"New\\\", \\\"York\\\"], heads=heads, attrs=attrs)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"token\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token to split. \", _jsx(_components.del, {\n                children: \"Token\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"orths\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The verbatim text of the split tokens. Needs to match the text of the original token. \", _jsx(_components.del, {\n                children: \"List[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"heads\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"List of \", _jsx(InlineCode, {\n                children: \"token\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"(token, subtoken)\"\n              }), \" tuples specifying the tokens to attach the newly split subtokens to. \", _jsx(_components.del, {\n                children: \"List[Union[Token, Tuple[Token, int]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Attributes to set on all split tokens. Attribute names mapped to list of per-token attribute values. \", _jsx(_components.del, {\n                children: \"Dict[Union[str, int], List[Any]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-ents\",\n      children: [_jsx(_components.h2, {\n        id: \"ents\",\n        tag: \"property\",\n        model: \"NER\",\n        children: \"Doc.ents \"\n      }), _jsxs(_components.p, {\n        children: [\"The named entities in the document. Returns a tuple of named entity \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \"\\nobjects, if the entity recognizer has been applied.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Mr. Best flew to New York on Saturday morning.\\\")\\nents = list(doc.ents)\\nassert ents[0].label_ == \\\"PERSON\\\"\\nassert ents[0].text == \\\"Mr. Best\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Entities in the document, one \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" per entity. \", _jsx(_components.del, {\n                children: \"Tuple[Span]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-spans\",\n      children: [_jsx(_components.h2, {\n        id: \"spans\",\n        tag: \"property\",\n        children: \"Doc.spans \"\n      }), _jsxs(_components.p, {\n        children: [\"A dictionary of named span groups, to store and access additional span\\nannotations. You can write to it by assigning a list of \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \"\\nobjects or a \", _jsx(_components.a, {\n          href: \"/api/spangroup\",\n          children: _jsx(InlineCode, {\n            children: \"SpanGroup\"\n          })\n        }), \" to a given key.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Their goi ng home\\\")\\ndoc.spans[\\\"errors\\\"] = [doc[0:1], doc[1:3]]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The span groups assigned to the document. \", _jsx(_components.del, {\n                children: \"Dict[str, SpanGroup]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-cats\",\n      children: [_jsx(_components.h2, {\n        id: \"cats\",\n        tag: \"property\",\n        model: \"text classifier\",\n        children: \"Doc.cats \"\n      }), _jsxs(_components.p, {\n        children: [\"Maps a label to a score for categories applied to the document. Typically set by\\nthe \", _jsx(_components.a, {\n          href: \"/api/textcategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"TextCategorizer\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a text about football.\\\")\\nprint(doc.cats)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The text categories mapped to scores. \", _jsx(_components.del, {\n                children: \"Dict[str, float]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-noun_chunks\",\n      children: [_jsx(_components.h2, {\n        id: \"noun_chunks\",\n        tag: \"property\",\n        model: \"parser\",\n        children: \"Doc.noun_chunks \"\n      }), _jsxs(_components.p, {\n        children: [\"Iterate over the base noun phrases in the document. Yields base noun-phrase\\n\", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" objects, if the document has been syntactically parsed. A base noun\\nphrase, or “NP chunk”, is a noun phrase that does not permit other NPs to be\\nnested within it – so no NP-level coordination, no prepositional phrases, and no\\nrelative clauses.\"]\n      }), _jsxs(_components.p, {\n        children: [\"To customize the noun chunk iterator in a loaded pipeline, modify\\n\", _jsx(_components.a, {\n          href: \"/api/vocab#attributes\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.vocab.get_noun_chunks\"\n          })\n        }), \". If the \", _jsx(InlineCode, {\n          children: \"noun_chunk\"\n        }), \"\\n\", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#language-data\",\n          children: \"syntax iterator\"\n        }), \" has not been\\nimplemented for the given language, a \", _jsx(InlineCode, {\n          children: \"NotImplementedError\"\n        }), \" is raised.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"A phrase with another phrase occurs.\\\")\\nchunks = list(doc.noun_chunks)\\nassert len(chunks) == 2\\nassert chunks[0].text == \\\"A phrase\\\"\\nassert chunks[1].text == \\\"another phrase\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Noun chunks in the document. \", _jsx(_components.del, {\n                children: \"Span\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-sents\",\n      children: [_jsx(_components.h2, {\n        id: \"sents\",\n        tag: \"property\",\n        model: \"sentences\",\n        children: \"Doc.sents \"\n      }), _jsx(_components.p, {\n        children: \"Iterate over the sentences in the document. Sentence spans have no label.\"\n      }), _jsxs(_components.p, {\n        children: [\"This property is only available when\\n\", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#sbd\",\n          children: \"sentence boundaries\"\n        }), \" have been set on the\\ndocument by the \", _jsx(InlineCode, {\n          children: \"parser\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"senter\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"sentencizer\"\n        }), \" or some custom function. It\\nwill raise an error otherwise.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"This is a sentence. Here's another...\\\")\\nsents = list(doc.sents)\\nassert len(sents) == 2\\nassert [s.root.text for s in sents] == [\\\"is\\\", \\\"'s\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"YIELDS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Sentences in the document. \", _jsx(_components.del, {\n                children: \"Span\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-has_vector\",\n      children: [_jsx(_components.h2, {\n        id: \"has_vector\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Doc.has_vector \"\n      }), _jsx(_components.p, {\n        children: \"A boolean value indicating whether a word vector is associated with the object.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples\\\")\\nassert doc.has_vector\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the document has a vector data attached. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-vector\",\n      children: [_jsx(_components.h2, {\n        id: \"vector\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Doc.vector \"\n      }), _jsx(_components.p, {\n        children: \"A real-valued meaning representation. Defaults to an average of the token\\nvectors.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I like apples\\\")\\nassert doc.vector.dtype == \\\"float32\\\"\\nassert doc.vector.shape == (300,)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A 1-dimensional array representing the document’s vector. \", _jsx(_components.del, {\n                children: \"numpy.ndarray[ndim=1, dtype=float32]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-vector_norm\",\n      children: [_jsx(_components.h2, {\n        id: \"vector_norm\",\n        tag: \"property\",\n        model: \"vectors\",\n        children: \"Doc.vector_norm \"\n      }), _jsx(_components.p, {\n        children: \"The L2 norm of the document’s vector representation.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc1 = nlp(\\\"I like apples\\\")\\ndoc2 = nlp(\\\"I like oranges\\\")\\ndoc1.vector_norm  # 4.54232424414368\\ndoc2.vector_norm  # 3.304373298575751\\nassert doc1.vector_norm != doc2.vector_norm\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The L2 norm of the vector representation. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"attributes\",\n        children: \"Attributes \"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"text\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A string representation of the document text. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"text_with_ws\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An alias of \", _jsx(InlineCode, {\n                children: \"Doc.text\"\n              }), \", provided for duck-type compatibility with \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"mem\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document’s local memory heap, for all C data it owns. \", _jsx(_components.del, {\n                children: \"cymem.Pool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The store of lexical types. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tensor\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Container for dense vector representations. \", _jsx(_components.del, {\n                children: \"numpy.ndarray\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A generic storage area, for user custom data. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lang\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Language of the document’s vocabulary. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lang_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Language of the document’s vocabulary. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sentiment\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document’s positivity/negativity score, if available. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary that allows customization of the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \"’s properties. \", _jsx(_components.del, {\n                children: \"Dict[str, Callable]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_token_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary that allows customization of properties of \", _jsx(InlineCode, {\n                children: \"Token\"\n              }), \" children. \", _jsx(_components.del, {\n                children: \"Dict[str, Callable]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_span_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A dictionary that allows customization of properties of \", _jsx(InlineCode, {\n                children: \"Span\"\n              }), \" children. \", _jsx(_components.del, {\n                children: \"Dict[str, Callable]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"has_unknown_spaces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the document was constructed without known spacing between tokens (typically when created from gold tokenization). \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"User space for adding custom \", _jsx(_components.a, {\n                href: \"/usage/processing-pipelines#custom-components-attributes\",\n                children: \"attribute extensions\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Underscore\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-serialization-fields\",\n      children: [_jsx(_components.h2, {\n        id: \"serialization-fields\",\n        children: \"Serialization fields \"\n      }), _jsxs(_components.p, {\n        children: [\"During serialization, spaCy will export several data fields used to restore\\ndifferent aspects of the object. If needed, you can exclude them from\\nserialization by passing in the string names via the \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" argument.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"data = doc.to_bytes(exclude=[\\\"text\\\", \\\"tensor\\\"])\\ndoc.from_disk(\\\"./doc.bin\\\", exclude=[\\\"user_data\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"text\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the \", _jsx(InlineCode, {\n                children: \"Doc.text\"\n              }), \" attribute.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sentiment\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the \", _jsx(InlineCode, {\n                children: \"Doc.sentiment\"\n              }), \" attribute.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tensor\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the \", _jsx(InlineCode, {\n                children: \"Doc.tensor\"\n              }), \" attribute.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the \", _jsx(InlineCode, {\n                children: \"Doc.user_data\"\n              }), \" dictionary.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_data_keys\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The keys of the \", _jsx(InlineCode, {\n                children: \"Doc.user_data\"\n              }), \" dictionary.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_data_values\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The values of the \", _jsx(InlineCode, {\n                children: \"Doc.user_data\"\n              }), \" dictionary.\"]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Doc","tag":"class","teaser":"A container for accessing linguistic annotations.","source":"spacy/tokens/doc.pyx"},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}