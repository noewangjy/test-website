{"pageProps":{"title":"Cython Structs","teaser":"C-language objects that let you group variables together","next":null,"menu":[["TokenC","tokenc"],["LexemeC","lexemec"]],"slug":"/api/cython-structs","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-tokenc\",\n      children: [_jsx(_components.h2, {\n        id: \"tokenc\",\n        tag: \"C struct\",\n        source: \"spacy/structs.pxd\",\n        children: \"TokenC \"\n      }), _jsxs(_components.p, {\n        children: [\"Cython data container for the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" object.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"token = &doc.c[3]\\ntoken_ptr = &doc.c[3]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lex\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to the lexeme for the token. \", _jsx(_components.del, {\n                children: \"const LexemeC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"morph\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An ID allowing lookup of morphological attributes. \", _jsx(_components.del, {\n                children: \"uint64_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pos\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Coarse-grained part-of-speech tag. \", _jsx(_components.del, {\n                children: \"univ_pos_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spacy\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A binary value indicating whether the token has trailing whitespace. \", _jsx(_components.del, {\n                children: \"bint\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tag\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Fine-grained part-of-speech tag. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"idx\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The character offset of the token within the parent document. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lemma\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Base form of the token, with no inflectional suffixes. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sense\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Space for storing a word sense ID, currently unused. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"head\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Offset of the syntactic parent relative to the token. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dep\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Syntactic dependency relation. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"l_kids\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Number of left children. \", _jsx(_components.del, {\n                children: \"uint32_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"r_kids\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Number of right children. \", _jsx(_components.del, {\n                children: \"uint32_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"l_edge\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Offset of the leftmost token of this token’s syntactic descendants. \", _jsx(_components.del, {\n                children: \"uint32_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"r_edge\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Offset of the rightmost token of this token’s syntactic descendants. \", _jsx(_components.del, {\n                children: \"uint32_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sent_start\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Ternary value indicating whether the token is the first word of a sentence. \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" indicates a missing value, \", _jsx(InlineCode, {\n                children: \"-1\"\n              }), \" indicates \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \" indicates \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". The default value, 0, is interpreted as no sentence break. Sentence boundary detectors will usually set 0 for all tokens except tokens that follow a sentence boundary. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_iob\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"IOB code of named entity tag. \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" indicates a missing value, \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \" indicates \", _jsx(InlineCode, {\n                children: \"I\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" indicates \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \" indicates \", _jsx(InlineCode, {\n                children: \"B\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_type\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Named entity type. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the entity the token is an instance of, if any. Currently not used, but potentially for coreference resolution. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"token_get_struct_attr\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/tokens/token.pxd\",\n        children: \"Token.get_struct_attr \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the value of an attribute from the \", _jsx(InlineCode, {\n          children: \"TokenC\"\n        }), \" struct by attribute ID.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport IS_ALPHA\\nfrom spacy.tokens cimport Token\\n\\nis_alpha = Token.get_struct_attr(&doc.c[3], IS_ALPHA)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"token\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"TokenC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const TokenC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"feat_name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the attribute to look up. The attributes are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the attribute. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"token_set_struct_attr\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/tokens/token.pxd\",\n        children: \"Token.set_struct_attr \"\n      }), _jsxs(_components.p, {\n        children: [\"Set the value of an attribute of the \", _jsx(InlineCode, {\n          children: \"TokenC\"\n        }), \" struct by attribute ID.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport TAG\\nfrom spacy.tokens cimport Token\\n\\ntoken = &doc.c[3]\\nToken.set_struct_attr(token, TAG, 0)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"token\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"TokenC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const TokenC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"feat_name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the attribute to look up. The attributes are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"value\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value to set. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"token_by_start\",\n        tag: \"function\",\n        source: \"spacy/tokens/doc.pxd\",\n        children: \"token_by_start \"\n      }), _jsxs(_components.p, {\n        children: [\"Find a token in a \", _jsx(InlineCode, {\n          children: \"TokenC*\"\n        }), \" array by the offset of its first character.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens.doc cimport Doc, token_by_start\\nfrom spacy.vocab cimport Vocab\\n\\ndoc = Doc(Vocab(), words=[\\\"hello\\\", \\\"world\\\"])\\nassert token_by_start(doc.c, doc.length, 6) == 1\\nassert token_by_start(doc.c, doc.length, 4) == -1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"TokenC*\"\n              }), \" array. \", _jsx(_components.del, {\n                children: \"const TokenC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tokens in the array. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"start_char\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The start index to search for. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token in the array or \", _jsx(InlineCode, {\n                children: \"-1\"\n              }), \" if not found. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"token_by_end\",\n        tag: \"function\",\n        source: \"spacy/tokens/doc.pxd\",\n        children: \"token_by_end \"\n      }), _jsxs(_components.p, {\n        children: [\"Find a token in a \", _jsx(InlineCode, {\n          children: \"TokenC*\"\n        }), \" array by the offset of its final character.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens.doc cimport Doc, token_by_end\\nfrom spacy.vocab cimport Vocab\\n\\ndoc = Doc(Vocab(), words=[\\\"hello\\\", \\\"world\\\"])\\nassert token_by_end(doc.c, doc.length, 5) == 0\\nassert token_by_end(doc.c, doc.length, 1) == -1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"TokenC*\"\n              }), \" array. \", _jsx(_components.del, {\n                children: \"const TokenC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tokens in the array. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"end_char\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The end index to search for. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token in the array or \", _jsx(InlineCode, {\n                children: \"-1\"\n              }), \" if not found. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"set_children_from_heads\",\n        tag: \"function\",\n        source: \"spacy/tokens/doc.pxd\",\n        children: \"set_children_from_heads \"\n      }), _jsxs(_components.p, {\n        children: [\"Set attributes that allow lookup of syntactic children on a \", _jsx(InlineCode, {\n          children: \"TokenC*\"\n        }), \" array.\\nThis function must be called after making changes to the \", _jsx(InlineCode, {\n          children: \"TokenC.head\"\n        }), \"\\nattribute, in order to make the parse tree navigation consistent.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens.doc cimport Doc, set_children_from_heads\\nfrom spacy.vocab cimport Vocab\\n\\ndoc = Doc(Vocab(), words=[\\\"Baileys\\\", \\\"from\\\", \\\"a\\\", \\\"shoe\\\"])\\ndoc.c[0].head = 0\\ndoc.c[1].head = 0\\ndoc.c[2].head = 3\\ndoc.c[3].head = 1\\nset_children_from_heads(doc.c, doc.length)\\nassert doc.c[3].l_kids == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A \", _jsx(InlineCode, {\n                children: \"TokenC*\"\n              }), \" array. \", _jsx(_components.del, {\n                children: \"const TokenC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tokens in the array. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-lexemec\",\n      children: [_jsx(_components.h2, {\n        id: \"lexemec\",\n        tag: \"C struct\",\n        source: \"spacy/structs.pxd\",\n        children: \"LexemeC \"\n      }), _jsxs(_components.p, {\n        children: [\"Struct holding information about a lexical type. \", _jsx(InlineCode, {\n          children: \"LexemeC\"\n        }), \" structs are usually\\nowned by the \", _jsx(InlineCode, {\n          children: \"Vocab\"\n        }), \", and accessed through a read-only pointer on the \", _jsx(InlineCode, {\n          children: \"TokenC\"\n        }), \"\\nstruct.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"lex = doc.c[3].lex\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"flags\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Bit-field for binary lexical flag values. \", _jsx(_components.del, {\n                children: \"flags_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Usually used to map lexemes to rows in a matrix, e.g. for word vectors. Does not need to be unique, so currently misnamed. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Number of unicode characters in the lexeme. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"orth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the verbatim text content. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lower\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the lowercase form of the lexeme. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"norm\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"ID of the lexeme’s norm, i.e. a normalized form of the text. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"shape\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Transform of the lexeme’s string, to show orthographic features. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Length-N substring from the start of the lexeme. Defaults to \", _jsx(InlineCode, {\n                children: \"N=1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"suffix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Length-N substring from the end of the lexeme. Defaults to \", _jsx(InlineCode, {\n                children: \"N=3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"lexeme_get_struct_attr\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/lexeme.pxd\",\n        children: \"Lexeme.get_struct_attr \"\n      }), _jsxs(_components.p, {\n        children: [\"Get the value of an attribute from the \", _jsx(InlineCode, {\n          children: \"LexemeC\"\n        }), \" struct by attribute ID.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport IS_ALPHA\\nfrom spacy.lexeme cimport Lexeme\\n\\nlexeme = doc.c[3].lex\\nis_alpha = Lexeme.get_struct_attr(lexeme, IS_ALPHA)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lex\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"LexemeC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const LexemeC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"feat_name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the attribute to look up. The attributes are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value of the attribute. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"lexeme_set_struct_attr\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/lexeme.pxd\",\n        children: \"Lexeme.set_struct_attr \"\n      }), _jsxs(_components.p, {\n        children: [\"Set the value of an attribute of the \", _jsx(InlineCode, {\n          children: \"LexemeC\"\n        }), \" struct by attribute ID.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport NORM\\nfrom spacy.lexeme cimport Lexeme\\n\\nlexeme = doc.c[3].lex\\nLexeme.set_struct_attr(lexeme, NORM, lexeme.lower)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lex\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"LexemeC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const LexemeC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"feat_name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the attribute to look up. The attributes are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"value\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value to set. \", _jsx(_components.del, {\n                children: \"attr_t (uint64_t)\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"lexeme_c_check_flag\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/lexeme.pxd\",\n        children: \"Lexeme.c_check_flag \"\n      }), _jsx(_components.p, {\n        children: \"Check the value of a binary flag attribute.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport IS_STOP\\nfrom spacy.lexeme cimport Lexeme\\n\\nlexeme = doc.c[3].lex\\nis_stop = Lexeme.c_check_flag(lexeme, IS_STOP)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lexeme\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"LexemeC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const LexemeC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"flag_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the flag to look up. The flag IDs are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The boolean value of the flag. \", _jsx(_components.del, {\n                children: \"bint\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"lexeme_c_set_flag\",\n        tag: \"staticmethod, nogil\",\n        source: \"spacy/lexeme.pxd\",\n        children: \"Lexeme.c_set_flag \"\n      }), _jsx(_components.p, {\n        children: \"Set the value of a binary flag attribute.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.attrs cimport IS_STOP\\nfrom spacy.lexeme cimport Lexeme\\n\\nlexeme = doc.c[3].lex\\nLexeme.c_set_flag(lexeme, IS_STOP, 0)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lexeme\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A pointer to a \", _jsx(InlineCode, {\n                children: \"LexemeC\"\n              }), \" struct. \", _jsx(_components.del, {\n                children: \"const LexemeC*\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"flag_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the flag to look up. The flag IDs are enumerated in \", _jsx(InlineCode, {\n                children: \"spacy.typedefs\"\n              }), \". \", _jsx(_components.del, {\n                children: \"attr_id_t\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"value\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The value to set. \", _jsx(_components.del, {\n                children: \"bint\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Cython Structs","teaser":"C-language objects that let you group variables together","next":"/api/cython-classes","menu":[["TokenC","tokenc"],["LexemeC","lexemec"]]},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true}