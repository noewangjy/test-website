{"pageProps":{"title":"EntityRuler","tag":"class","source":"spacy/pipeline/entityruler.py","version":2.1,"teaser":"Pipeline component for rule-based named entity recognition","api_string_name":"entity_ruler","api_trainable":false,"slug":"/api/entityruler","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Tag} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The entity ruler lets you add spans to the \", _jsx(_components.a, {\n          href: \"/api/doc#ents\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.ents\"\n          })\n        }), \" using\\ntoken-based rules or exact phrase matches. It can be combined with the\\nstatistical \", _jsx(_components.a, {\n          href: \"/api/entityrecognizer\",\n          children: _jsx(InlineCode, {\n            children: \"EntityRecognizer\"\n          })\n        }), \" to boost accuracy, or\\nused on its own to implement a purely rule-based entity recognition system. For\\nusage examples, see the docs on\\n\", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching#entityruler\",\n          children: \"rule-based entity recognition\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-assigned-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"assigned-attributes\",\n        children: \"Assigned Attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"This component assigns predictions basically the same way as the\\n\", _jsx(_components.a, {\n          href: \"/api/entityrecognizer\",\n          children: _jsx(InlineCode, {\n            children: \"EntityRecognizer\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"Predictions can be accessed under \", _jsx(InlineCode, {\n          children: \"Doc.ents\"\n        }), \" as a tuple. Each label will also be\\nreflected in each underlying token, where it is saved in the \", _jsx(InlineCode, {\n          children: \"Token.ent_type\"\n        }), \"\\nand \", _jsx(InlineCode, {\n          children: \"Token.ent_iob\"\n        }), \" fields. Note that by definition each token can only have one\\nlabel.\"]\n      }), _jsxs(_components.p, {\n        children: [\"When setting \", _jsx(InlineCode, {\n          children: \"Doc.ents\"\n        }), \" to create training data, all the spans must be valid and\\nnon-overlapping, or an error will be thrown.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Location\"\n            }), _jsx(_components.th, {\n              children: \"Value\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Doc.ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The annotated spans. \", _jsx(_components.del, {\n                children: \"Tuple[Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_iob\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An enum encoding of the IOB part of the named entity tag. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_iob_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The IOB part of the named entity tag. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_type\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label part of the named entity tag (hash). \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_type_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label part of the named entity tag. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-config\",\n      children: [_jsx(_components.h2, {\n        id: \"config\",\n        children: \"Config and implementation \"\n      }), _jsxs(_components.p, {\n        children: [\"The default config is defined by the pipeline component factory and describes\\nhow the component should be configured. You can override its settings via the\\n\", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" or in your\\n\", _jsxs(_components.a, {\n          href: \"/usage/training#config\",\n          children: [_jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" for training\"]\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\n   \\\"phrase_matcher_attr\\\": None,\\n   \\\"validate\\\": True,\\n   \\\"overwrite_ents\\\": False,\\n   \\\"ent_id_sep\\\": \\\"||\\\",\\n}\\nnlp.add_pipe(\\\"entity_ruler\\\", config=config)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional attribute name match on for the internal \", _jsx(_components.a, {\n                href: \"/api/phrasematcher\",\n                children: _jsx(InlineCode, {\n                  children: \"PhraseMatcher\"\n                })\n              }), \", e.g. \", _jsx(InlineCode, {\n                children: \"LOWER\"\n              }), \" to match on the lowercase token text. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"matcher_fuzzy_compare\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.5\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The fuzzy comparison method, passed on to the internal \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"spacy.matcher.levenshtein.levenshtein_compare\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated (passed to the \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"PhraseMatcher\"\n              }), \"). Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"overwrite_ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If existing entities are present, e.g. entities added by the model, overwrite them by matches if necessary. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_id_sep\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Separator used internally for entity IDs. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"||\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#get_ner_prf\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy.scorer.get_ner_prf\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/entityruler.py\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/entityruler.py\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"EntityRuler.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the entity ruler. If patterns are supplied here, they need to be a\\nlist of dictionaries with a \", _jsx(InlineCode, {\n          children: \"\\\"label\\\"\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"\\\"pattern\\\"\"\n        }), \" key. A pattern can either\\nbe a token pattern (list) or a phrase pattern (string). For example:\\n\", _jsx(InlineCode, {\n          children: \"{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction via add_pipe\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\n\\n# Construction from class\\nfrom spacy.pipeline import EntityRuler\\nruler = EntityRuler(nlp, overwrite_ents=True)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared nlp object to pass the vocab to the matchers and process phrase patterns. \", _jsx(_components.del, {\n                children: \"Language\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"name\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"Instance name of the current pipeline component. Typically passed in automatically from the factory when the component is added. Used to disable the current entity ruler while creating phrase patterns with the nlp object. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional attribute name match on for the internal \", _jsx(_components.a, {\n                href: \"/api/phrasematcher\",\n                children: _jsx(InlineCode, {\n                  children: \"PhraseMatcher\"\n                })\n              }), \", e.g. \", _jsx(InlineCode, {\n                children: \"LOWER\"\n              }), \" to match on the lowercase token text. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"matcher_fuzzy_compare\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.5\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The fuzzy comparison method, passed on to the internal \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"spacy.matcher.levenshtein.levenshtein_compare\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated, passed to Matcher and PhraseMatcher as \", _jsx(InlineCode, {\n                children: \"validate\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"overwrite_ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If existing entities are present, e.g. entities added by the model, overwrite them by matches if necessary. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ent_id_sep\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Separator used internally for entity IDs. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"||\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional patterns to load in on initialization. \", _jsx(_components.del, {\n                children: \"Optional[List[Dict[str, Union[str, List[dict]]]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#get_ner_prf\",\n                children: _jsx(InlineCode, {\n                  children: \"spacy.scorer.get_ner_prf\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-initialize\",\n      children: [_jsx(_components.h2, {\n        id: \"initialize\",\n        tag: \"method\",\n        version: \"3\",\n        children: \"EntityRuler.initialize \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the component with data and used before training to load in rules\\nfrom a \", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching/#entityruler-files\",\n          children: \"pattern file\"\n        }), \". This\\nmethod is typically called by \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Language.initialize\"\n          })\n        }), \"\\nand lets you customize arguments it receives via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize.components]\"\n          })\n        }), \" block in the\\nconfig.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"entity_ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nentity_ruler.initialize(lambda: [], nlp=nlp, patterns=patterns)\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[initialize.components.entity_ruler]\\n\\n[initialize.components.entity_ruler.patterns]\\n@readers = \\\"srsly.read_jsonl.v1\\\"\\npath = \\\"corpus/entity_ruler_patterns.jsonl\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that returns gold-standard annotations in the form of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects. Not used by the \", _jsx(InlineCode, {\n                children: \"EntityRuler\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[], Iterable[Example]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The list of patterns. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Sequence[Dict[str, Union[str, List[Dict[str, Any]]]]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"EntityRuler.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"The number of all patterns added to the entity ruler.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nassert len(ruler) == 0\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\nassert len(ruler) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of patterns. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-contains\",\n      children: [_jsx(_components.h2, {\n        id: \"contains\",\n        tag: \"method\",\n        children: \"EntityRuler.__contains__ \"\n      }), _jsx(_components.p, {\n        children: \"Whether a label is present in the patterns.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\nassert \\\"ORG\\\" in ruler\\nassert not \\\"PERSON\\\" in ruler\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label to check. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the entity ruler contains the label. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"EntityRuler.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Find matches in the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and add them to the \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \". Typically, this\\nhappens automatically after the component has been added to the pipeline using\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". If the entity ruler was initialized\\nwith \", _jsx(InlineCode, {\n          children: \"overwrite_ents=True\"\n        }), \", existing entities will be replaced if they overlap\\nwith the matches. When matches overlap in a Doc, the entity ruler prioritizes\\nlonger patterns over shorter, and if equal the match occuring first in the Doc\\nis chosen.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\n\\ndoc = nlp(\\\"A text about Apple.\\\")\\nents = [(ent.text, ent.label_) for ent in doc.ents]\\nassert ents == [(\\\"Apple\\\", \\\"ORG\\\")]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to process, e.g. the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with added entities, if available. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add_patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"add_patterns\",\n        tag: \"method\",\n        children: \"EntityRuler.add_patterns \"\n      }), _jsxs(_components.p, {\n        children: [\"Add patterns to the entity ruler. A pattern can either be a token pattern (list\\nof dicts) or a phrase pattern (string). For more details, see the usage guide on\\n\", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching\",\n          children: \"rule-based matching\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [\\n    {\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"},\\n    {\\\"label\\\": \\\"GPE\\\", \\\"pattern\\\": [{\\\"lower\\\": \\\"san\\\"}, {\\\"lower\\\": \\\"francisco\\\"}]}\\n]\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.add_patterns(patterns)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The patterns to add. \", _jsx(_components.del, {\n                children: \"List[Dict[str, Union[str, List[dict]]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove\",\n      children: [_jsx(_components.h2, {\n        id: \"remove\",\n        tag: \"method\",\n        version: \"3.2.1\",\n        children: \"EntityRuler.remove \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove a pattern by its ID from the entity ruler. A \", _jsx(InlineCode, {\n          children: \"ValueError\"\n        }), \" is raised if\\nthe ID does not exist.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\", \\\"id\\\": \\\"apple\\\"}]\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.add_patterns(patterns)\\nruler.remove(\\\"apple\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the pattern rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        children: \"EntityRuler.to_disk \"\n      }), _jsxs(_components.p, {\n        children: [\"Save the entity ruler patterns to a directory. The patterns will be saved as\\nnewline-delimited JSON (JSONL). If a file with the suffix \", _jsx(InlineCode, {\n          children: \".jsonl\"\n        }), \" is provided,\\nonly the patterns are saved as JSONL. If a directory name is provided, a\\n\", _jsx(InlineCode, {\n          children: \"patterns.jsonl\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"cfg\"\n        }), \" file with the component configuration is exported.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.to_disk(\\\"/path/to/patterns.jsonl\\\")  # saves patterns only\\nruler.to_disk(\\\"/path/to/entity_ruler\\\")    # saves patterns and config\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a JSONL file or directory, which will be created if it doesn’t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        children: \"EntityRuler.from_disk \"\n      }), _jsxs(_components.p, {\n        children: [\"Load the entity ruler from a path. Expects either a file containing\\nnewline-delimited JSON (JSONL) with one entry per line, or a directory\\ncontaining a \", _jsx(InlineCode, {\n          children: \"patterns.jsonl\"\n        }), \" file and a \", _jsx(InlineCode, {\n          children: \"cfg\"\n        }), \" file with the component\\nconfiguration.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.from_disk(\\\"/path/to/patterns.jsonl\\\")  # loads patterns only\\nruler.from_disk(\\\"/path/to/entity_ruler\\\")    # loads patterns and config\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a JSONL file or directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"EntityRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"EntityRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"EntityRuler.to_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Serialize the entity ruler patterns to a bytestring.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler_bytes = ruler.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized patterns. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"EntityRuler.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from a bytestring. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler_bytes = ruler.to_bytes()\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\nruler.from_bytes(ruler_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The bytestring to load. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"EntityRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"EntityRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-labels\",\n      children: [_jsx(_components.h2, {\n        id: \"labels\",\n        tag: \"property\",\n        children: \"EntityRuler.labels \"\n      }), _jsx(_components.p, {\n        children: \"All labels present in the match patterns.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string labels. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-ent_ids\",\n      children: [_jsx(_components.h2, {\n        id: \"ent_ids\",\n        tag: \"property\",\n        version: \"2.2.2\",\n        children: \"EntityRuler.ent_ids \"\n      }), _jsxs(_components.p, {\n        children: [\"All entity IDs present in the \", _jsx(InlineCode, {\n          children: \"id\"\n        }), \" properties of the match patterns.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string IDs. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"patterns\",\n        tag: \"property\",\n        children: \"EntityRuler.patterns \"\n      }), _jsx(_components.p, {\n        children: \"Get all patterns that were added to the entity ruler.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The original patterns, one dictionary per pattern. \", _jsx(_components.del, {\n                children: \"List[Dict[str, Union[str, dict]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"attributes\",\n        children: \"Attributes \"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"matcher\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The underlying matcher used to process token patterns. \", _jsx(_components.del, {\n                children: \"Matcher\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The underlying phrase matcher used to process phrase patterns. \", _jsx(_components.del, {\n                children: \"PhraseMatcher\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"token_patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token patterns present in the entity ruler, keyed by label. \", _jsx(_components.del, {\n                children: \"Dict[str, List[Dict[str, Union[str, List[dict]]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The phrase patterns present in the entity ruler, keyed by label. \", _jsx(_components.del, {\n                children: \"Dict[str, List[Doc]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"EntityRuler","tag":"class","source":"spacy/pipeline/entityruler.py","version":2.1,"teaser":"Pipeline component for rule-based named entity recognition","api_string_name":"entity_ruler","api_trainable":false},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":"entity_ruler","baseClass":null,"trainable":false},"isIndex":false,"next":null},"__N_SSG":true}