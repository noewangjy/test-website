{"pageProps":{"title":"Model Architectures","teaser":"Pre-defined model architectures included with the core library","source":"spacy/ml/models","menu":[["Tok2Vec","tok2vec-arch"],["Transformers","transformers"],["Pretraining","pretrain"],["Parser & NER","parser"],["Tagging","tagger"],["Text Classification","textcat"],["Span Classification","spancat"],["Entity Linking","entitylinker"],["Coreference","coref-architectures"]],"slug":"/api/architectures","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h2: \"h2\",\n    h3: \"h3\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {InlineCode, Infobox, Accordion} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"model architecture\"\n        }), \" is a function that wires up a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" instance, which you can then use in a\\npipeline component or as a layer of a larger network. This page documents\\nspaCy’s built-in architectures that are used for different NLP tasks. All\\ntrainable \", _jsx(_components.a, {\n          href: \"/api#architecture-pipeline\",\n          children: \"built-in components\"\n        }), \" expect a \", _jsx(InlineCode, {\n          children: \"model\"\n        }), \"\\nargument defined in the config and document their the default architecture.\\nCustom architectures can be registered using the\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: _jsx(InlineCode, {\n            children: \"@spacy.registry.architectures\"\n          })\n        }), \" decorator and used as\\npart of the \", _jsx(_components.a, {\n          href: \"/usage/training#custom-functions\",\n          children: \"training config\"\n        }), \". Also see the\\nusage documentation on\\n\", _jsx(_components.a, {\n          href: \"/usage/layers-architectures\",\n          children: \"layers and model architectures\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-tok2vec-arch\",\n      children: [_jsx(_components.h2, {\n        id: \"tok2vec-arch\",\n        source: \"spacy/ml/models/tok2vec.py\",\n        children: \"Tok2Vec architectures \"\n      }), _jsx(_components.h3, {\n        id: \"Tok2Vec\",\n        children: \"spacy.Tok2Vec.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[model.embed]\\n@architectures = \\\"spacy.CharacterEmbed.v2\\\"\\n# ...\\n\\n[model.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\n# ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Construct a tok2vec model out of two subnetworks: one for embedding and one for\\nencoding. See the\\n\", _jsx(_components.a, {\n          href: \"https://explosion.ai/blog/deep-learning-formula-nlp\",\n          children: \"“Embed, Encode, Attend, Predict”\"\n        }), \"\\nblog post for background.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"embed\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Embed tokens into context-independent word vector representations. For example, \", _jsx(_components.a, {\n                href: \"/api/architectures#CharacterEmbed\",\n                children: \"CharacterEmbed\"\n              }), \" or \", _jsx(_components.a, {\n                href: \"/api/architectures#MultiHashEmbed\",\n                children: \"MultiHashEmbed\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"encode\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Encode context into the embeddings, using an architecture such as a CNN, BiLSTM or transformer. For example, \", _jsx(_components.a, {\n                href: \"/api/architectures#MaxoutWindowEncoder\",\n                children: \"MaxoutWindowEncoder\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Model[List[Floats2d], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"HashEmbedCNN\",\n        children: \"spacy.HashEmbedCNN.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\npretrained_vectors = null\\nwidth = 96\\ndepth = 4\\nembed_size = 2000\\nwindow_size = 1\\nmaxout_pieces = 3\\nsubword_features = true\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Build spaCy’s “standard” tok2vec layer. This layer is defined by a\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#MultiHashEmbed\",\n          children: \"MultiHashEmbed\"\n        }), \" embedding layer that uses\\nsubword features, and a\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#MaxoutWindowEncoder\",\n          children: \"MaxoutWindowEncoder\"\n        }), \" encoding layer\\nconsisting of a CNN and a layer-normalized maxout activation function.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The width of the input and output. These are required to be the same, so that residual connections can be used. Recommended values are \", _jsx(InlineCode, {\n                children: \"96\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"128\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"300\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"depth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of convolutional layers to use. Recommended values are between \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"8\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"embed_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rows in the hash embedding tables. This can be surprisingly small, due to the use of the hash embeddings. Recommended values are between \", _jsx(InlineCode, {\n                children: \"2000\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"10000\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"window_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tokens on either side to concatenate during the convolutions. The receptive field of the CNN will be \", _jsx(InlineCode, {\n                children: \"depth * (window_size * 2 + 1)\"\n              }), \", so a 4-layer network with a window size of \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" will be sensitive to 20 words at a time. Recommended value is \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"maxout_pieces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of pieces to use in the maxout non-linearity. If \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \", the \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-layers#mish\",\n                children: _jsx(InlineCode, {\n                  children: \"Mish\"\n                })\n              }), \" non-linearity is used instead. Recommended values are \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \"-\", _jsx(InlineCode, {\n                children: \"3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"subword_features\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to also embed subword features, specifically the prefix, suffix and word shape. This is recommended for alphabetic languages like English, but not if single-character tokens are used for a language such as Chinese. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pretrained_vectors\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to also use static vectors. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"Tok2VecListener\",\n        children: \"spacy.Tok2VecListener.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.tok2vec]\\nfactory = \\\"tok2vec\\\"\\n\\n[components.tok2vec.model]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\nwidth = 342\\n\\n[components.tagger]\\nfactory = \\\"tagger\\\"\\n\\n[components.tagger.model]\\n@architectures = \\\"spacy.Tagger.v2\\\"\\n\\n[components.tagger.model.tok2vec]\\n@architectures = \\\"spacy.Tok2VecListener.v1\\\"\\nwidth = ${components.tok2vec.model.width}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"A listener is used as a sublayer within a component such as a\\n\", _jsx(_components.a, {\n          href: \"/api/dependencyparser\",\n          children: _jsx(InlineCode, {\n            children: \"DependencyParser\"\n          })\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"/api/entityrecognizer\",\n          children: _jsx(InlineCode, {\n            children: \"EntityRecognizer\"\n          })\n        }), \"or\\n\", _jsx(_components.a, {\n          href: \"/api/textcategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"TextCategorizer\"\n          })\n        }), \". Usually you’ll have multiple\\nlisteners connecting to a single upstream \", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component\\nthat’s earlier in the pipeline. The listener layers act as \", _jsx(_components.strong, {\n          children: \"proxies\"\n        }), \", passing\\nthe predictions from the \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" component into downstream components, and\\ncommunicating gradients back upstream.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Instead of defining its own \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" instance, a model architecture like\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#tagger\",\n          children: \"Tagger\"\n        }), \" can define a listener as its \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \"\\nargument that connects to the shared \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" component in the pipeline.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Listeners work by caching the \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" output for a given batch of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"s. This\\nmeans that in order for a component to work with the listener, the batch of\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"s passed to the listener must be the same as the batch of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"s passed to\\nthe \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \". As a result, any manipulation of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"s which would affect\\n\", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" output, such as to create special contexts or remove \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"s for which\\nno prediction can be made, must happen inside the model, \", _jsx(_components.strong, {\n          children: \"after\"\n        }), \" the call to\\nthe \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" component.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The width of the vectors produced by the “upstream” \", _jsx(_components.a, {\n                href: \"/api/tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"Tok2Vec\"\n                })\n              }), \" component. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"upstream\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A string to identify the “upstream” \", _jsx(InlineCode, {\n                children: \"Tok2Vec\"\n              }), \" component to communicate with. By default, the upstream name is the wildcard string \", _jsx(InlineCode, {\n                children: \"\\\"*\\\"\"\n              }), \", but you could also specify the name of the \", _jsx(InlineCode, {\n                children: \"Tok2Vec\"\n              }), \" component. You’ll almost never have multiple upstream \", _jsx(InlineCode, {\n                children: \"Tok2Vec\"\n              }), \" components, so the wildcard string will almost always be fine. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"MultiHashEmbed\",\n        children: \"spacy.MultiHashEmbed.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\nwidth = 64\\nattrs = [\\\"NORM\\\", \\\"PREFIX\\\", \\\"SUFFIX\\\", \\\"SHAPE\\\"]\\nrows = [2000, 1000, 1000, 1000]\\ninclude_static_vectors = true\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Construct an embedding layer that separately embeds a number of lexical\\nattributes using hash embedding, concatenates the results, and passes it through\\na feed-forward subnetwork to build a mixed representation. The features used can\\nbe configured with the \", _jsx(InlineCode, {\n          children: \"attrs\"\n        }), \" argument. The suggested attributes are \", _jsx(InlineCode, {\n          children: \"NORM\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"PREFIX\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"SUFFIX\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"SHAPE\"\n        }), \". This lets the model take into account some\\nsubword information, without construction a fully character-based\\nrepresentation. If pretrained vectors are available, they can be included in the\\nrepresentation as well, with the vectors table kept static (i.e. it’s not\\nupdated).\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The output width. Also used as the width of the embedding tables. Recommended values are between \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"300\"\n              }), \". If static vectors are included, a learned linear layer is used to map the vectors to the specified width before concatenating it with the other embedding outputs. A single maxout layer is then used to reduce the concatenated vectors to the final width. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token attributes to embed. A separate embedding table will be constructed for each attribute. \", _jsx(_components.del, {\n                children: \"List[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"rows\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rows for each embedding tables. Can be low, due to the hashing trick. Recommended values are between \", _jsx(InlineCode, {\n                children: \"1000\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"10000\"\n              }), \". The layer needs surprisingly few rows, due to its use of the hashing trick. Generally between 2000 and 10000 rows is sufficient, even for very large vocabularies. A number of rows must be specified for each table, so the \", _jsx(InlineCode, {\n                children: \"rows\"\n              }), \" list must be of the same length as the \", _jsx(InlineCode, {\n                children: \"attrs\"\n              }), \" parameter. \", _jsx(_components.del, {\n                children: \"List[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"include_static_vectors\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to also use static word vectors. Requires a vectors table to be loaded in the \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects’ vocab. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"CharacterEmbed\",\n        children: \"spacy.CharacterEmbed.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.CharacterEmbed.v2\\\"\\nwidth = 128\\nrows = 7000\\nnM = 64\\nnC = 8\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Construct an embedded representation based on character embeddings, using a\\nfeed-forward network. A fixed number of UTF-8 byte characters are used for each\\nword, taken from the beginning and end of the word equally. Padding is used in\\nthe center for words that are too short.\"\n      }), _jsxs(_components.p, {\n        children: [\"For instance, let’s say \", _jsx(InlineCode, {\n          children: \"nC=4\"\n        }), \", and the word is “jumping”. The characters used\\nwill be \", _jsx(InlineCode, {\n          children: \"\\\"jung\\\"\"\n        }), \" (two from the start, two from the end). If we had \", _jsx(InlineCode, {\n          children: \"nC=8\"\n        }), \", the\\ncharacters would be \", _jsx(InlineCode, {\n          children: \"\\\"jumpping\\\"\"\n        }), \": 4 from the start, 4 from the end. This ensures\\nthat the final character is always in the last position, instead of being in an\\narbitrary position depending on the word length.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The characters are embedded in a embedding table with a given number of rows,\\nand the vectors concatenated. A hash-embedded vector of the \", _jsx(InlineCode, {\n          children: \"NORM\"\n        }), \" of the word\\nis also concatenated on, and the result is then passed through a feed-forward\\nnetwork to construct a single vector to represent the information.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The width of the output vector and the \", _jsx(InlineCode, {\n                children: \"NORM\"\n              }), \" hash embedding. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"rows\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of rows in the \", _jsx(InlineCode, {\n                children: \"NORM\"\n              }), \" hash embedding table. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nM\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The dimensionality of the character embeddings. Recommended values are between \", _jsx(InlineCode, {\n                children: \"16\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nC\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of UTF-8 bytes to embed per word. Recommended values are between \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"8\"\n              }), \", although it may depend on the length of words in the language. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"MaxoutWindowEncoder\",\n        children: \"spacy.MaxoutWindowEncoder.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\nwidth = 128\\nwindow_size = 1\\nmaxout_pieces = 3\\ndepth = 4\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Encode context using convolutions with maxout activation, layer normalization\\nand residual connections.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The input and output width. These are required to be the same, to allow residual connections. This value will be determined by the width of the inputs. Recommended values are between \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"300\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"window_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of words to concatenate around each token to construct the convolution. Recommended value is \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"maxout_pieces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of maxout pieces to use. Recommended values are \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"depth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of convolutional layers. Recommended value is \", _jsx(InlineCode, {\n                children: \"4\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Floats2d], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"MishWindowEncoder\",\n        children: \"spacy.MishWindowEncoder.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.MishWindowEncoder.v2\\\"\\nwidth = 64\\nwindow_size = 1\\ndepth = 4\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Encode context using convolutions with\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#mish\",\n          children: _jsx(InlineCode, {\n            children: \"Mish\"\n          })\n        }), \" activation, layer normalization\\nand residual connections.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The input and output width. These are required to be the same, to allow residual connections. This value will be determined by the width of the inputs. Recommended values are between \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"300\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"window_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of words to concatenate around each token to construct the convolution. Recommended value is \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"depth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of convolutional layers. Recommended value is \", _jsx(InlineCode, {\n                children: \"4\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Floats2d], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"TorchBiLSTMEncoder\",\n        children: \"spacy.TorchBiLSTMEncoder.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.TorchBiLSTMEncoder.v1\\\"\\nwidth = 64\\ndepth = 2\\ndropout = 0.0\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Encode context using bidirectional LSTM layers. Requires\\n\", _jsx(_components.a, {\n          href: \"https://pytorch.org\",\n          children: \"PyTorch\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The input and output width. These are required to be the same, to allow residual connections. This value will be determined by the width of the inputs. Recommended values are between \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"300\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"depth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of recurrent layers, for instance \", _jsx(InlineCode, {\n                children: \"depth=2\"\n              }), \" results in stacking two LSTMs together. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dropout\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Creates a Dropout layer on the outputs of each LSTM layer except the last layer. Set to 0.0 to disable this functionality. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Floats2d], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"StaticVectors\",\n        children: \"spacy.StaticVectors.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.StaticVectors.v2\\\"\\nnO = null\\nnM = null\\ndropout = 0.2\\nkey_attr = \\\"ORTH\\\"\\n\\n[model.init_W]\\n@initializers = \\\"glorot_uniform_init.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Embed \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects with their vocab’s vectors table, applying a\\nlearned linear projection to control the dimensionality. Unknown tokens are\\nmapped to a zero vector. See the documentation on\\n\", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers#static-vectors\",\n          children: \"static vectors\"\n        }), \" for details.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The output width of the layer, after the linear projection. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nM\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The width of the static vectors. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dropout\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Optional dropout rate. If set, it’s applied per dimension over the whole batch. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[float]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"init_W\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-initializers\",\n                children: \"initialization function\"\n              }), \". Defaults to \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-initializers#glorot_uniform_init\",\n                children: _jsx(InlineCode, {\n                  children: \"glorot_uniform_init\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Ops, Tuple[int, …]]], FloatsXd]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"ORTH\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Ragged]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"FeatureExtractor\",\n        children: \"spacy.FeatureExtractor.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.FeatureExtractor.v1\\\"\\ncolumns = [\\\"NORM\\\", \\\"PREFIX\\\", \\\"SUFFIX\\\", \\\"SHAPE\\\", \\\"ORTH\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Extract arrays of input features from \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects. Expects a list\\nof feature names to extract, which should refer to token attributes.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"columns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token attributes to extract. \", _jsx(_components.del, {\n                children: \"List[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The created feature extraction layer. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Ints2d]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-transformers\",\n      children: [_jsx(_components.h2, {\n        id: \"transformers\",\n        source: \"github.com/explosion/spacy-transformers/blob/master/spacy_transformers/architectures.py\",\n        children: \"Transformer architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"The following architectures are provided by the package\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-transformers\",\n          children: _jsx(InlineCode, {\n            children: \"spacy-transformers\"\n          })\n        }), \". See the\\n\", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers#transformers\",\n          children: \"usage documentation\"\n        }), \" for how to\\nintegrate the architectures into your training config.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Note that in order to use these architectures in your config, you need to\\ninstall the\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-transformers\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-transformers\"\n            })\n          }), \". See the\\n\", _jsx(_components.a, {\n            href: \"/usage/embeddings-transformers#transformers-installation\",\n            children: \"installation docs\"\n          }), \"\\nfor details and system requirements.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"TransformerModel\",\n        children: \"spacy-transformers.TransformerModel.v3 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy-transformers.TransformerModel.v3\\\"\\nname = \\\"roberta-base\\\"\\ntokenizer_config = {\\\"use_fast\\\": true}\\ntransformer_config = {}\\nmixed_precision = true\\ngrad_scaler_config = {\\\"init_scale\\\": 32768}\\n\\n[model.get_spans]\\n@span_getters = \\\"spacy-transformers.strided_spans.v1\\\"\\nwindow = 128\\nstride = 96\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Load and wrap a transformer model from the\\n\", _jsxs(_components.a, {\n          href: \"https://huggingface.co/transformers\",\n          children: [\"HuggingFace \", _jsx(InlineCode, {\n            children: \"transformers\"\n          })]\n        }), \" library. You\\ncan use any transformer that has pretrained weights and a PyTorch\\nimplementation. The \", _jsx(InlineCode, {\n          children: \"name\"\n        }), \" variable is passed through to the underlying library,\\nso it can be either a string or a path. If it’s a string, the pretrained weights\\nwill be downloaded via the transformers library if they are not already\\navailable locally.\"]\n      }), _jsxs(_components.p, {\n        children: [\"In order to support longer documents, the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TransformerModel\",\n          children: \"TransformerModel\"\n        }), \" layer allows you to pass\\nin a \", _jsx(InlineCode, {\n          children: \"get_spans\"\n        }), \" function that will divide up the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects\\nbefore passing them through the transformer. Your spans are allowed to overlap\\nor exclude tokens. This layer is usually used directly by the\\n\", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component, which allows you to share the\\ntransformer weights across your pipeline. For a layer that’s configured for use\\nin other components, see\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2VecTransformer\",\n          children: \"Tok2VecTransformer\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Any model name that can be loaded by \", _jsx(_components.a, {\n                href: \"https://huggingface.co/transformers/model_doc/auto.html#transformers.AutoModel\",\n                children: _jsx(InlineCode, {\n                  children: \"transformers.AutoModel\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_spans\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that takes a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" object and returns lists of \", _jsx(_components.a, {\n                href: \"/api\",\n                children: _jsx(InlineCode, {\n                  children: \"Span\"\n                })\n              }), \" objects to process by the transformer. \", _jsx(_components.a, {\n                href: \"/api/transformer#span_getters\",\n                children: \"See here\"\n              }), \" for built-in options and examples. \", _jsx(_components.del, {\n                children: \"Callable[[List[Doc]], List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tokenizer_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Tokenizer settings passed to \", _jsx(_components.a, {\n                href: \"https://huggingface.co/transformers/model_doc/auto.html#transformers.AutoTokenizer\",\n                children: _jsx(InlineCode, {\n                  children: \"transformers.AutoTokenizer\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"transformer_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Transformer settings passed to \", _jsx(_components.a, {\n                href: \"https://huggingface.co/transformers/model_doc/auto.html?highlight=autoconfig#transformers.AutoConfig\",\n                children: _jsx(InlineCode, {\n                  children: \"transformers.AutoConfig\"\n                })\n              }), \" \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"mixed_precision\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Replace whitelisted ops by half-precision counterparts. Speeds up training and prediction on GPUs with \", _jsx(_components.a, {\n                href: \"https://developer.nvidia.com/tensor-cores\",\n                children: \"Tensor Cores\"\n              }), \" and reduces GPU memory use. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"grad_scaler_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Configuration to pass to \", _jsx(InlineCode, {\n                children: \"thinc.api.PyTorchGradScaler\"\n              }), \" during training when \", _jsx(InlineCode, {\n                children: \"mixed_precision\"\n              }), \" is enabled. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], FullTransformerBatch]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {}), _jsx(_components.td, {})]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Mixed precision support\",\n        variant: \"warning\",\n        children: _jsx(_components.p, {\n          children: \"Mixed-precision support is currently an experimental feature.\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"Previous versions of spacy-transformers.TransformerModel\",\n        spaced: true,\n        children: [_jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(InlineCode, {\n              children: \"transformer_config\"\n            }), \" argument was added in\\n\", _jsx(InlineCode, {\n              children: \"spacy-transformers.TransformerModel.v2\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(InlineCode, {\n              children: \"mixed_precision\"\n            }), \" and \", _jsx(InlineCode, {\n              children: \"grad_scaler_config\"\n            }), \" arguments were added in\\n\", _jsx(InlineCode, {\n              children: \"spacy-transformers.TransformerModel.v3\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), _jsx(_components.p, {\n          children: \"The other arguments are shared between all versions.\"\n        })]\n      }), _jsx(_components.h3, {\n        id: \"TransformerListener\",\n        children: \"spacy-transformers.TransformerListener.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy-transformers.TransformerListener.v1\\\"\\ngrad_factor = 1.0\\n\\n[model.pooling]\\n@layers = \\\"reduce_mean.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Create a \", _jsx(InlineCode, {\n          children: \"TransformerListener\"\n        }), \" layer, which will connect to a\\n\", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component earlier in the pipeline. The layer\\ntakes a list of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects as input, and produces a list of\\n2-dimensional arrays as output, with each array having one row per token. Most\\nspaCy models expect a sublayer with this signature, making it easy to connect\\nthem to a transformer model via this sublayer. Transformer models usually\\noperate over wordpieces, which usually don’t align one-to-one against spaCy\\ntokens. The layer therefore requires a reduction operation in order to calculate\\na single token vector given zero or more wordpiece vectors.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pooling\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A reduction layer used to calculate the token vectors based on zero or more wordpiece vectors. If in doubt, mean pooling (see \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-layers#reduce_mean\",\n                children: _jsx(InlineCode, {\n                  children: \"reduce_mean\"\n                })\n              }), \") is usually a good choice. \", _jsx(_components.del, {\n                children: \"Model[Ragged, Floats2d]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"grad_factor\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Reweight gradients from the component before passing them upstream. You can set this to \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" to “freeze” the transformer weights with respect to the component, or use it to make some components more significant than others. Leaving it at \", _jsx(InlineCode, {\n                children: \"1.0\"\n              }), \" is usually fine. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"upstream\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A string to identify the “upstream” \", _jsx(InlineCode, {\n                children: \"Transformer\"\n              }), \" component to communicate with. By default, the upstream name is the wildcard string \", _jsx(InlineCode, {\n                children: \"\\\"*\\\"\"\n              }), \", but you could also specify the name of the \", _jsx(InlineCode, {\n                children: \"Transformer\"\n              }), \" component. You’ll almost never have multiple upstream \", _jsx(InlineCode, {\n                children: \"Transformer\"\n              }), \" components, so the wildcard string will almost always be fine. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"Tok2VecTransformer\",\n        children: \"spacy-transformers.Tok2VecTransformer.v3 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy-transformers.Tok2VecTransformer.v3\\\"\\nname = \\\"albert-base-v2\\\"\\ntokenizer_config = {\\\"use_fast\\\": false}\\ntransformer_config = {}\\ngrad_factor = 1.0\\nmixed_precision = true\\ngrad_scaler_config = {\\\"init_scale\\\": 32768}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Use a transformer as a \", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" layer directly. This does\\n\", _jsx(_components.strong, {\n          children: \"not\"\n        }), \" allow multiple components to share the transformer weights and does\\n\", _jsx(_components.strong, {\n          children: \"not\"\n        }), \" allow the transformer to set annotations into the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \"\\nobject, but it’s a \", _jsx(_components.strong, {\n          children: \"simpler solution\"\n        }), \" if you only need the transformer within\\none component.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_spans\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that takes a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" object and returns lists of \", _jsx(_components.a, {\n                href: \"/api\",\n                children: _jsx(InlineCode, {\n                  children: \"Span\"\n                })\n              }), \" objects to process by the transformer. \", _jsx(_components.a, {\n                href: \"/api/transformer#span_getters\",\n                children: \"See here\"\n              }), \" for built-in options and examples. \", _jsx(_components.del, {\n                children: \"Callable[[List[Doc]], List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tokenizer_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Tokenizer settings passed to \", _jsx(_components.a, {\n                href: \"https://huggingface.co/transformers/model_doc/auto.html#transformers.AutoTokenizer\",\n                children: _jsx(InlineCode, {\n                  children: \"transformers.AutoTokenizer\"\n                })\n              }), \". \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"transformer_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Settings to pass to the transformers forward pass. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pooling\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A reduction layer used to calculate the token vectors based on zero or more wordpiece vectors. If in doubt, mean pooling (see \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-layers#reduce_mean\",\n                children: _jsx(InlineCode, {\n                  children: \"reduce_mean\"\n                })\n              }), \") is usually a good choice. \", _jsx(_components.del, {\n                children: \"Model[Ragged, Floats2d]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"grad_factor\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Reweight gradients from the component before passing them upstream. You can set this to \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \" to “freeze” the transformer weights with respect to the component, or use it to make some components more significant than others. Leaving it at \", _jsx(InlineCode, {\n                children: \"1.0\"\n              }), \" is usually fine. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"mixed_precision\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Replace whitelisted ops by half-precision counterparts. Speeds up training and prediction on GPUs with \", _jsx(_components.a, {\n                href: \"https://developer.nvidia.com/tensor-cores\",\n                children: \"Tensor Cores\"\n              }), \" and reduces GPU memory use. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"grad_scaler_config\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Configuration to pass to \", _jsx(InlineCode, {\n                children: \"thinc.api.PyTorchGradScaler\"\n              }), \" during training when \", _jsx(InlineCode, {\n                children: \"mixed_precision\"\n              }), \" is enabled. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Mixed precision support\",\n        variant: \"warning\",\n        children: _jsx(_components.p, {\n          children: \"Mixed-precision support is currently an experimental feature.\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"Previous versions of spacy-transformers.Tok2VecTransformer\",\n        spaced: true,\n        children: [_jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(InlineCode, {\n              children: \"transformer_config\"\n            }), \" argument was added in\\n\", _jsx(InlineCode, {\n              children: \"spacy-transformers.Tok2VecTransformer.v2\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(InlineCode, {\n              children: \"mixed_precision\"\n            }), \" and \", _jsx(InlineCode, {\n              children: \"grad_scaler_config\"\n            }), \" arguments were added in\\n\", _jsx(InlineCode, {\n              children: \"spacy-transformers.Tok2VecTransformer.v3\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), _jsx(_components.p, {\n          children: \"The other arguments are shared between all versions.\"\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pretrain\",\n      children: [_jsx(_components.h2, {\n        id: \"pretrain\",\n        source: \"spacy/ml/models/multi_task.py\",\n        children: \"Pretraining architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"The spacy \", _jsx(InlineCode, {\n          children: \"pretrain\"\n        }), \" command lets you initialize a \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" layer in your\\npipeline with information from raw text. To this end, additional layers are\\nadded to build a network for a temporary task that forces the \", _jsx(InlineCode, {\n          children: \"Tok2Vec\"\n        }), \" layer to\\nlearn something about sentence structure and word cooccurrence statistics. Two\\npretraining objectives are available, both of which are variants of the cloze\\ntask \", _jsx(_components.a, {\n          href: \"https://arxiv.org/abs/1810.04805\",\n          children: \"Devlin et al. (2018)\"\n        }), \" introduced for\\nBERT.\"]\n      }), _jsxs(_components.p, {\n        children: [\"For more information, see the section on\\n\", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers#pretraining\",\n          children: \"pretraining\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"pretrain_vectors\",\n        children: \"spacy.PretrainVectors.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[pretraining]\\ncomponent = \\\"tok2vec\\\"\\n\\n[initialize]\\nvectors = \\\"en_core_web_lg\\\"\\n...\\n\\n[pretraining.objective]\\n@architectures = \\\"spacy.PretrainVectors.v1\\\"\\nmaxout_pieces = 3\\nhidden_size = 300\\nloss = \\\"cosine\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Predict the word’s vector from a static embeddings table as pretraining\\nobjective for a Tok2Vec layer. To use this objective, make sure that the\\n\", _jsx(InlineCode, {\n          children: \"initialize.vectors\"\n        }), \" section in the config refers to a model with static\\nvectors.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"maxout_pieces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of maxout pieces to use. Recommended values are \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Size of the hidden layer of the model. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"loss\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The loss function can be either “cosine” or “L2”. We typically recommend to use “cosine”. ~~~str~~\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A callable function that can create the Model, given the \", _jsx(InlineCode, {\n                children: \"vocab\"\n              }), \" of the pipeline and the \", _jsx(InlineCode, {\n                children: \"tok2vec\"\n              }), \" layer to pretrain. \", _jsx(_components.del, {\n                children: \"Callable[[Vocab, Model], Model]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"pretrain_chars\",\n        children: \"spacy.PretrainCharacters.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[pretraining]\\ncomponent = \\\"tok2vec\\\"\\n...\\n\\n[pretraining.objective]\\n@architectures = \\\"spacy.PretrainCharacters.v1\\\"\\nmaxout_pieces = 3\\nhidden_size = 300\\nn_characters = 4\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Predict some number of leading and trailing UTF-8 bytes as pretraining objective\\nfor a Tok2Vec layer.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"maxout_pieces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of maxout pieces to use. Recommended values are \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Size of the hidden layer of the model. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"n_characters\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The window of characters - e.g. if \", _jsx(InlineCode, {\n                children: \"n_characters = 2\"\n              }), \", the model will try to predict the first two and last two characters of the word. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A callable function that can create the Model, given the \", _jsx(InlineCode, {\n                children: \"vocab\"\n              }), \" of the pipeline and the \", _jsx(InlineCode, {\n                children: \"tok2vec\"\n              }), \" layer to pretrain. \", _jsx(_components.del, {\n                children: \"Callable[[Vocab, Model], Model]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-parser\",\n      children: [_jsx(_components.h2, {\n        id: \"parser\",\n        children: \"Parser & NER architectures \"\n      }), _jsx(_components.h3, {\n        id: \"TransitionBasedParser\",\n        source: \"spacy/ml/models/parser.py\",\n        children: \"spacy.TransitionBasedParser.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.TransitionBasedParser.v2\\\"\\nstate_type = \\\"ner\\\"\\nextra_state_tokens = false\\nhidden_width = 64\\nmaxout_pieces = 2\\nuse_upper = true\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\npretrained_vectors = null\\nwidth = 96\\ndepth = 4\\nembed_size = 2000\\nwindow_size = 1\\nmaxout_pieces = 3\\nsubword_features = true\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Build a transition-based parser model. Can apply to NER or dependency parsing.\\nTransition-based parsing is an approach to structured prediction where the task\\nof predicting the structure is mapped to a series of state transitions. You\\nmight find \", _jsx(_components.a, {\n          href: \"https://explosion.ai/blog/parsing-english-in-python\",\n          children: \"this tutorial\"\n        }), \"\\nhelpful for background information. The neural network state prediction model\\nconsists of either two or three subnetworks:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"tok2vec\"\n          }), \": Map each token into a vector representation. This subnetwork is\\nrun once for each batch.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"lower\"\n          }), \": Construct a feature-specific vector for each \", _jsx(InlineCode, {\n            children: \"(token, feature)\"\n          }), \"\\npair. This is also run once for each batch. Constructing the state\\nrepresentation is then a matter of summing the component features and applying\\nthe non-linearity.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"upper\"\n          }), \" (optional): A feed-forward network that predicts scores from the\\nstate representation. If not present, the output from the lower model is used\\nas action scores directly.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Subnetwork to map tokens into vector representations. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"state_type\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Which task to extract features for. Possible values are “ner” and “parser”. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"extra_state_tokens\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to use an expanded feature set when extracting the state tokens. Slightly slower, but sometimes improves accuracy slightly. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_width\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The width of the hidden layer. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"maxout_pieces\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"How many pieces to use in the state prediction layer. Recommended values are \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"2\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"3\"\n              }), \". If \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \", the maxout non-linearity is replaced with a \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-layers#relu\",\n                children: _jsx(InlineCode, {\n                  children: \"Relu\"\n                })\n              }), \" non-linearity if \", _jsx(InlineCode, {\n                children: \"use_upper\"\n              }), \" is \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", and no non-linearity if \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"use_upper\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to use an additional hidden layer after the state vector in order to predict the action scores. It is recommended to set this to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \" for large pretrained models such as transformers, and \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \" for smaller networks. The upper layer is computed on CPU, which becomes a bottleneck on larger GPU-based models, where it’s also less necessary. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of actions the model will predict between. Usually inferred from data at the beginning of training, or loaded from disk. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Docs], List[List[Floats2d]]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Accordion, {\n        title: \"spacy.TransitionBasedParser.v1 definition\",\n        spaced: true,\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/api/legacy#TransitionBasedParser_v1\",\n            children: \"TransitionBasedParser.v1\"\n          }), \" had the exact\\nsame signature, but the \", _jsx(InlineCode, {\n            children: \"use_upper\"\n          }), \" argument was \", _jsx(InlineCode, {\n            children: \"True\"\n          }), \" by default.\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-tagger\",\n      children: [_jsx(_components.h2, {\n        id: \"tagger\",\n        source: \"spacy/ml/models/tagger.py\",\n        children: \"Tagging architectures \"\n      }), _jsx(_components.h3, {\n        id: \"Tagger\",\n        children: \"spacy.Tagger.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.Tagger.v2\\\"\\nnO = null\\nnormalize = false\\n\\n[model.tok2vec]\\n# ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Build a tagger model, using a provided token-to-vector component. The tagger\\nmodel adds a linear layer with softmax activation to predict scores given the\\ntoken vectors.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Subnetwork to map tokens into vector representations. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of tags to output. Inferred from the data if \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"normalize\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Normalize probabilities during inference. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(Accordion, {\n        title: \"Previous versions of spacy.Tagger\",\n        spaced: true,\n        children: [_jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(InlineCode, {\n              children: \"normalize\"\n            }), \" argument was added in \", _jsx(InlineCode, {\n              children: \"spacy.Tagger.v2\"\n            }), \". \", _jsx(InlineCode, {\n              children: \"spacy.Tagger.v1\"\n            }), \"\\nalways normalizes probabilities during inference.\"]\n          }), \"\\n\"]\n        }), _jsx(_components.p, {\n          children: \"The other arguments are shared between all versions.\"\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-textcat\",\n      children: [_jsx(_components.h2, {\n        id: \"textcat\",\n        source: \"spacy/ml/models/textcat.py\",\n        children: \"Text classification architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"A text classification architecture needs to take a \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" as input,\\nand produce a score for each potential label class. Textcat challenges can be\\nbinary (e.g. sentiment analysis) or involve multiple possible labels.\\nMulti-label challenges can either have mutually exclusive labels (each example\\nhas exactly one label), or multiple labels may be applicable at the same time.\"]\n      }), _jsx(_components.p, {\n        children: \"As the properties of text classification problems can vary widely, we provide\\nseveral different built-in architectures. It is recommended to experiment with\\ndifferent architectures and settings to determine what works best on your\\nspecific data and challenge.\"\n      }), _jsx(Infobox, {\n        title: \"Single-label vs. multi-label classification\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"When the architecture for a text classification challenge contains a setting for\\n\", _jsx(InlineCode, {\n            children: \"exclusive_classes\"\n          }), \", it is important to use the correct value for the correct\\npipeline component. The \", _jsx(InlineCode, {\n            children: \"textcat\"\n          }), \" component should always be used for\\nsingle-label use-cases where \", _jsx(InlineCode, {\n            children: \"exclusive_classes = true\"\n          }), \", while the\\n\", _jsx(InlineCode, {\n            children: \"textcat_multilabel\"\n          }), \" should be used for multi-label settings with\\n\", _jsx(InlineCode, {\n            children: \"exclusive_classes = false\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"TextCatEnsemble\",\n        children: \"spacy.TextCatEnsemble.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.TextCatEnsemble.v2\\\"\\nnO = null\\n\\n[model.linear_model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = true\\nngram_size = 1\\nno_output_layer = false\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\nwidth = 64\\nrows = [2000, 2000, 1000, 1000, 1000, 1000]\\nattrs = [\\\"ORTH\\\", \\\"LOWER\\\", \\\"PREFIX\\\", \\\"SUFFIX\\\", \\\"SHAPE\\\", \\\"ID\\\"]\\ninclude_static_vectors = false\\n\\n[model.tok2vec.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\nwidth = ${model.tok2vec.embed.width}\\nwindow_size = 1\\nmaxout_pieces = 3\\ndepth = 2\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Stacked ensemble of a linear bag-of-words model and a neural network model. The\\nneural network is built upon a Tok2Vec layer and uses attention. The setting for\\nwhether or not this model should cater for multi-label classification, is taken\\nfrom the linear model, where it is stored in \", _jsx(InlineCode, {\n          children: \"model.attrs[\\\"multi_label\\\"]\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"linear_model\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The linear bag-of-words model. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"tok2vec\"\n              }), \" layer to build the neural network upon. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Output dimension, determined by the number of different labels. If not set, the \", _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"TextCategorizer\"\n                })\n              }), \" component will set it when \", _jsx(InlineCode, {\n                children: \"initialize\"\n              }), \" is called. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(Accordion, {\n        title: \"spacy.TextCatEnsemble.v1 definition\",\n        spaced: true,\n        children: [_jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/api/legacy#TextCatEnsemble_v1\",\n            children: \"TextCatEnsemble.v1\"\n          }), \" was functionally similar,\\nbut used an internal \", _jsx(InlineCode, {\n            children: \"tok2vec\"\n          }), \" instead of taking it as argument:\"]\n        }), _jsxs(_components.table, {\n          children: [_jsx(_components.thead, {\n            children: _jsxs(_components.tr, {\n              children: [_jsx(_components.th, {\n                children: \"Name\"\n              }), _jsx(_components.th, {\n                children: \"Description\"\n              })]\n            })\n          }), _jsxs(_components.tbody, {\n            children: [_jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"exclusive_classes\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Whether or not categories are mutually exclusive. \", _jsx(_components.del, {\n                  children: \"bool\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"pretrained_vectors\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Whether or not pretrained vectors will be used in addition to the feature vectors. \", _jsx(_components.del, {\n                  children: \"bool\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"width\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Output dimension of the feature encoding step. \", _jsx(_components.del, {\n                  children: \"int\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"embed_size\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Input dimension of the feature encoding step. \", _jsx(_components.del, {\n                  children: \"int\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"conv_depth\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Depth of the tok2vec layer. \", _jsx(_components.del, {\n                  children: \"int\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"window_size\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"The number of contextual vectors to \", _jsx(_components.a, {\n                  href: \"https://thinc.ai/docs/api-layers#expand_window\",\n                  children: \"concatenate\"\n                }), \" from the left and from the right. \", _jsx(_components.del, {\n                  children: \"int\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"ngram_size\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Determines the maximum length of the n-grams in the BOW model. For instance, \", _jsx(InlineCode, {\n                  children: \"ngram_size=3\"\n                }), \"would give unigram, trigram and bigram features. \", _jsx(_components.del, {\n                  children: \"int\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"dropout\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"The dropout rate. \", _jsx(_components.del, {\n                  children: \"float\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(InlineCode, {\n                  children: \"nO\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"Output dimension, determined by the number of different labels. If not set, the \", _jsx(_components.a, {\n                  href: \"/api/textcategorizer\",\n                  children: _jsx(InlineCode, {\n                    children: \"TextCategorizer\"\n                  })\n                }), \" component will set it when \", _jsx(InlineCode, {\n                  children: \"initialize\"\n                }), \" is called. \", _jsx(_components.del, {\n                  children: \"Optional[int]\"\n                })]\n              })]\n            }), _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: _jsx(_components.strong, {\n                  children: \"CREATES\"\n                })\n              }), _jsxs(_components.td, {\n                children: [\"The model using the architecture. \", _jsx(_components.del, {\n                  children: \"Model[List[Doc], Floats2d]\"\n                })]\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"TextCatCNN\",\n        children: \"spacy.TextCatCNN.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.TextCatCNN.v2\\\"\\nexclusive_classes = false\\nnO = null\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\npretrained_vectors = null\\nwidth = 96\\ndepth = 4\\nembed_size = 2000\\nwindow_size = 1\\nmaxout_pieces = 3\\nsubword_features = true\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"A neural network model where token vectors are calculated using a CNN. The\\nvectors are mean pooled and used as features in a feed-forward network. This\\narchitecture is usually less accurate than the ensemble, but runs faster.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclusive_classes\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether or not categories are mutually exclusive. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"#tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"tok2vec\"\n                })\n              }), \" layer of the model. \", _jsx(_components.del, {\n                children: \"Model\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Output dimension, determined by the number of different labels. If not set, the \", _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"TextCategorizer\"\n                })\n              }), \" component will set it when \", _jsx(InlineCode, {\n                children: \"initialize\"\n              }), \" is called. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Accordion, {\n        title: \"spacy.TextCatCNN.v1 definition\",\n        spaced: true,\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/api/legacy#TextCatCNN_v1\",\n            children: \"TextCatCNN.v1\"\n          }), \" had the exact same signature, but was\\nnot yet resizable. Since v2, new labels can be added to this component, even\\nafter training.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"TextCatBOW\",\n        children: \"spacy.TextCatBOW.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = false\\nngram_size = 1\\nno_output_layer = false\\nnO = null\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"An n-gram “bag-of-words” model. This architecture should run much faster than\\nthe others, but may not be as accurate, especially if texts are short.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclusive_classes\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether or not categories are mutually exclusive. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ngram_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Determines the maximum length of the n-grams in the BOW model. For instance, \", _jsx(InlineCode, {\n                children: \"ngram_size=3\"\n              }), \" would give unigram, trigram and bigram features. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"no_output_layer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether or not to add an output layer to the model (\", _jsx(InlineCode, {\n                children: \"Softmax\"\n              }), \" activation if \", _jsx(InlineCode, {\n                children: \"exclusive_classes\"\n              }), \" is \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", else \", _jsx(InlineCode, {\n                children: \"Logistic\"\n              }), \"). \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Output dimension, determined by the number of different labels. If not set, the \", _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"TextCategorizer\"\n                })\n              }), \" component will set it when \", _jsx(InlineCode, {\n                children: \"initialize\"\n              }), \" is called. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(Accordion, {\n        title: \"spacy.TextCatBOW.v1 definition\",\n        spaced: true,\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/api/legacy#TextCatBOW_v1\",\n            children: \"TextCatBOW.v1\"\n          }), \" had the exact same signature, but was\\nnot yet resizable. Since v2, new labels can be added to this component, even\\nafter training.\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-spancat\",\n      children: [_jsx(_components.h2, {\n        id: \"spancat\",\n        source: \"spacy/ml/models/spancat.py\",\n        children: \"Span classification architectures \"\n      }), _jsx(_components.h3, {\n        id: \"SpanCategorizer\",\n        children: \"spacy.SpanCategorizer.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.SpanCategorizer.v1\\\"\\nscorer = {\\\"@layers\\\": \\\"spacy.LinearLogistic.v1\\\"}\\n\\n[model.reducer]\\n@layers = spacy.mean_max_reducer.v1\\\"\\nhidden_size = 128\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy.Tok2Vec.v1\\\"\\n\\n[model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v1\\\"\\n# ...\\n\\n[model.tok2vec.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v1\\\"\\n# ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Build a span categorizer model to power a\\n\", _jsx(_components.a, {\n          href: \"/api/spancategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"SpanCategorizer\"\n          })\n        }), \" component, given a token-to-vector\\nmodel, a reducer model to map the sequence of vectors for each span down to a\\nsingle vector, and a scorer model to map the vectors to probabilities.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The token-to-vector model. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[Floats2d]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"reducer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The reducer model. \", _jsx(_components.del, {\n                children: \"Model[Ragged, Floats2d]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scorer model. \", _jsx(_components.del, {\n                children: \"Model[Floats2d, Floats2d]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[Tuple[List[Doc], Ragged], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"mean_max_reducer\",\n        children: \"spacy.mean_max_reducer.v1 \"\n      }), _jsx(_components.p, {\n        children: \"Reduce sequences by concatenating their mean and max pooled vectors, and then\\ncombine the concatenated vectors with a hidden layer.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The size of the hidden layer. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-entitylinker\",\n      children: [_jsx(_components.h2, {\n        id: \"entitylinker\",\n        source: \"spacy/ml/models/entity_linker.py\",\n        children: \"Entity linking architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"An \", _jsx(_components.a, {\n          href: \"/api/entitylinker\",\n          children: _jsx(InlineCode, {\n            children: \"EntityLinker\"\n          })\n        }), \" component disambiguates textual mentions\\n(tagged as named entities) to unique identifiers, grounding the named entities\\ninto the “real world”. This requires 3 main components:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"A \", _jsx(_components.a, {\n            href: \"/api/kb\",\n            children: _jsx(InlineCode, {\n              children: \"KnowledgeBase\"\n            })\n          }), \" (KB) holding the unique identifiers, potential\\nsynonyms and prior probabilities.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"A candidate generation step to produce a set of likely identifiers, given a\\ncertain textual mention.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"A machine learning \", _jsx(_components.a, {\n            href: \"https://thinc.ai/docs/api-model\",\n            children: _jsx(InlineCode, {\n              children: \"Model\"\n            })\n          }), \" that picks the\\nmost plausible ID from the set of candidates.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"EntityLinker\",\n        children: \"spacy.EntityLinker.v2 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"spacy.EntityLinker.v2\\\"\\nnO = null\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\npretrained_vectors = null\\nwidth = 96\\ndepth = 2\\nembed_size = 2000\\nwindow_size = 1\\nmaxout_pieces = 3\\nsubword_features = true\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"EntityLinker\"\n        }), \" model architecture is a Thinc \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" with a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/api-layers#linear\",\n          children: _jsx(InlineCode, {\n            children: \"Linear\"\n          })\n        }), \" output layer.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"#tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"tok2vec\"\n                })\n              }), \" layer of the model. \", _jsx(_components.del, {\n                children: \"Model\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nO\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Output dimension, determined by the length of the vectors encoding each entity in the KB. If the \", _jsx(InlineCode, {\n                children: \"nO\"\n              }), \" dimension is not set, the entity linking component will set it when \", _jsx(InlineCode, {\n                children: \"initialize\"\n              }), \" is called. \", _jsx(_components.del, {\n                children: \"Optional[int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"EmptyKB\",\n        children: \"spacy.EmptyKB.v1 \"\n      }), _jsxs(_components.p, {\n        children: [\"A function that creates an empty \", _jsx(InlineCode, {\n          children: \"KnowledgeBase\"\n        }), \" from a \", _jsx(_components.a, {\n          href: \"/api/vocab\",\n          children: _jsx(InlineCode, {\n            children: \"Vocab\"\n          })\n        }), \"\\ninstance. This is the default when a new entity linker component is created.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entity_vector_length\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The length of the vectors encoding each entity in the KB. Defaults to \", _jsx(InlineCode, {\n                children: \"64\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"KBFromFile\",\n        children: \"spacy.KBFromFile.v1 \"\n      }), _jsxs(_components.p, {\n        children: [\"A function that reads an existing \", _jsx(InlineCode, {\n          children: \"KnowledgeBase\"\n        }), \" from file.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"kb_path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The location of the KB that was stored to file. \", _jsx(_components.del, {\n                children: \"Path\"\n              })]\n            })]\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"CandidateGenerator\",\n        children: \"spacy.CandidateGenerator.v1 \"\n      }), _jsxs(_components.p, {\n        children: [\"A function that takes as input a \", _jsx(_components.a, {\n          href: \"/api/kb\",\n          children: _jsx(InlineCode, {\n            children: \"KnowledgeBase\"\n          })\n        }), \" and a\\n\", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" object denoting a named entity, and returns a list of\\nplausible \", _jsx(_components.a, {\n          href: \"/api/kb/#candidate\",\n          children: _jsx(InlineCode, {\n            children: \"Candidate\"\n          })\n        }), \" objects. The default\\n\", _jsx(InlineCode, {\n          children: \"CandidateGenerator\"\n        }), \" uses the text of a mention to find its potential aliases in\\nthe \", _jsx(InlineCode, {\n          children: \"KnowledgeBase\"\n        }), \". Note that this function is case-dependent.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-coref-architectures\",\n      children: [_jsx(_components.h2, {\n        id: \"coref-architectures\",\n        tag: \"experimental\",\n        children: \"Coreference \"\n      }), _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.a, {\n          href: \"/api/coref\",\n          children: _jsx(InlineCode, {\n            children: \"CoreferenceResolver\"\n          })\n        }), \" component identifies tokens that refer to\\nthe same entity. A \", _jsx(_components.a, {\n          href: \"/api/span-resolver\",\n          children: _jsx(InlineCode, {\n            children: \"SpanResolver\"\n          })\n        }), \" component infers spans\\nfrom single tokens. Together these components can be used to reproduce\\ntraditional coreference models. You can also omit the \", _jsx(InlineCode, {\n          children: \"SpanResolver\"\n        }), \" if working\\nwith only token-level clusters is acceptable.\"]\n      }), _jsx(_components.h3, {\n        id: \"Coref\",\n        tag: \"experimental\",\n        children: \"spacy-experimental.Coref.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"\\n[model]\\n@architectures = \\\"spacy-experimental.Coref.v1\\\"\\ndistance_embedding_size = 20\\ndropout = 0.3\\nhidden_size = 1024\\ndepth = 2\\nantecedent_limit = 50\\nantecedent_batch_size = 512\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy-transformers.TransformerListener.v1\\\"\\ngrad_factor = 1.0\\nupstream = \\\"transformer\\\"\\npooling = {\\\"@layers\\\":\\\"reduce_mean.v1\\\"}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Coref\"\n        }), \" model architecture is a Thinc \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"#tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"tok2vec\"\n                })\n              }), \" layer of the model. \", _jsx(_components.del, {\n                children: \"Model\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"distance_embedding_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A representation of the distance between candidates. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"dropout\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The dropout to use internally. Unlike some Thinc models, this has separate dropout for the internal PyTorch layers. \", _jsx(_components.del, {\n                children: \"float\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Size of the main internal layers. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"depth\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Depth of the internal network. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"antecedent_limit\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"How many candidate antecedents to keep after rough scoring. This has a significant effect on memory usage. Typical values would be 50 to 200, or higher for very long documents. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"antecedent_batch_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Internal batch size. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], Floats2d]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"SpanResolver\",\n        tag: \"experimental\",\n        children: \"spacy-experimental.SpanResolver.v1 \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example Config\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"\\n[model]\\n@architectures = \\\"spacy-experimental.SpanResolver.v1\\\"\\nhidden_size = 1024\\ndistance_embedding_size = 64\\nconv_channels = 4\\nwindow_size = 1\\nmax_distance = 128\\nprefix = \\\"coref_head_clusters\\\"\\n\\n[model.tok2vec]\\n@architectures = \\\"spacy-transformers.TransformerListener.v1\\\"\\ngrad_factor = 1.0\\nupstream = \\\"transformer\\\"\\npooling = {\\\"@layers\\\":\\\"reduce_mean.v1\\\"}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"SpanResolver\"\n        }), \" model architecture is a Thinc \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \". Note that\\n\", _jsx(InlineCode, {\n          children: \"MentionClusters\"\n        }), \" is \", _jsx(InlineCode, {\n          children: \"List[List[Tuple[int, int]]]\"\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.a, {\n                href: \"#tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"tok2vec\"\n                })\n              }), \" layer of the model. \", _jsx(_components.del, {\n                children: \"Model\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"hidden_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Size of the main internal layers. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"distance_embedding_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A representation of the distance between two candidates. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"conv_channels\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of channels in the internal CNN. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"window_size\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of neighboring tokens to consider in the internal CNN. \", _jsx(InlineCode, {\n                children: \"1\"\n              }), \" means consider one token on each side. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"max_distance\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The longest possible length of a predicted span. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"prefix\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The prefix that indicates spans to use for input data. \", _jsx(_components.del, {\n                children: \"string\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"CREATES\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The model using the architecture. \", _jsx(_components.del, {\n                children: \"Model[List[Doc], List[MentionClusters]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Model Architectures","teaser":"Pre-defined model architectures included with the core library","source":"spacy/ml/models","menu":[["Tok2Vec","tok2vec-arch"],["Transformers","transformers"],["Pretraining","pretrain"],["Parser & NER","parser"],["Tagging","tagger"],["Text Classification","textcat"],["Span Classification","spancat"],["Entity Linking","entitylinker"],["Coreference","coref-architectures"]]},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}