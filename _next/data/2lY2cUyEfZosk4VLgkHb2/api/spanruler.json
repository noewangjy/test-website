{"pageProps":{"title":"SpanRuler","tag":"class","source":"spacy/pipeline/span_ruler.py","version":3.3,"teaser":"Pipeline component for rule-based span and named entity recognition","api_string_name":"span_ruler","api_trainable":false,"slug":"/api/spanruler","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode, Tag} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The span ruler lets you add spans to \", _jsx(_components.a, {\n          href: \"/api/doc#spans\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.spans\"\n          })\n        }), \" and/or\\n\", _jsx(_components.a, {\n          href: \"/api/doc#ents\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.ents\"\n          })\n        }), \" using token-based rules or exact phrase matches. For\\nusage examples, see the docs on\\n\", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching#spanruler\",\n          children: \"rule-based span matching\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-assigned-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"assigned-attributes\",\n        children: \"Assigned Attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"Matches will be saved to \", _jsx(InlineCode, {\n          children: \"Doc.spans[spans_key]\"\n        }), \" as a\\n\", _jsx(_components.a, {\n          href: \"/api/spangroup\",\n          children: _jsx(InlineCode, {\n            children: \"SpanGroup\"\n          })\n        }), \" and/or to \", _jsx(InlineCode, {\n          children: \"Doc.ents\"\n        }), \", where the annotation is\\nsaved in the \", _jsx(InlineCode, {\n          children: \"Token.ent_type\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token.ent_iob\"\n        }), \" fields.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Location\"\n            }), _jsx(_components.th, {\n              children: \"Value\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Doc.spans[spans_key]\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The annotated spans. \", _jsx(_components.del, {\n                children: \"SpanGroup\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Doc.ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The annotated spans. \", _jsx(_components.del, {\n                children: \"Tuple[Span]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_iob\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"An enum encoding of the IOB part of the named entity tag. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_iob_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The IOB part of the named entity tag. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_type\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label part of the named entity tag (hash). \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"Token.ent_type_\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label part of the named entity tag. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-config\",\n      children: [_jsx(_components.h2, {\n        id: \"config\",\n        children: \"Config and implementation \"\n      }), _jsxs(_components.p, {\n        children: [\"The default config is defined by the pipeline component factory and describes\\nhow the component should be configured. You can override its settings via the\\n\", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" or in your\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\n   \\\"spans_key\\\": \\\"my_spans\\\",\\n   \\\"validate\\\": True,\\n   \\\"overwrite\\\": False,\\n}\\nnlp.add_pipe(\\\"span_ruler\\\", config=config)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spans_key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The spans key to save the spans under. If \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \", no spans are saved. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"ruler\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spans_filter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The optional method to filter spans before they are assigned to doc.spans. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Iterable[Span], Iterable[Span]], List[Span]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"annotate_ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to save spans to doc.ents. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ents_filter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The method to filter spans before they are assigned to doc.ents. Defaults to \", _jsx(InlineCode, {\n                children: \"util.filter_chain_spans\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Iterable[Span], Iterable[Span]], List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Token attribute to match on, passed to the internal \", _jsx(InlineCode, {\n                children: \"PhraseMatcher\"\n              }), \" as \", _jsx(InlineCode, {\n                children: \"attr\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"matcher_fuzzy_compare\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.5\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The fuzzy comparison method, passed on to the internal \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"spacy.matcher.levenshtein.levenshtein_compare\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated, passed to \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"PhraseMatcher\"\n              }), \" as \", _jsx(InlineCode, {\n                children: \"validate\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"overwrite\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to remove any existing spans under \", _jsx(InlineCode, {\n                children: \"Doc.spans[spans key]\"\n              }), \" if \", _jsx(InlineCode, {\n                children: \"spans_key\"\n              }), \" is set, or to remove any ents under \", _jsx(InlineCode, {\n                children: \"Doc.ents\"\n              }), \" if \", _jsx(InlineCode, {\n                children: \"annotate_ents\"\n              }), \" is set. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_spans\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_spans\"\n                })\n              }), \" for \", _jsx(InlineCode, {\n                children: \"Doc.spans[spans_key]\"\n              }), \" with overlapping spans allowed. \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/span_ruler.py\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/span_ruler.py\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"SpanRuler.__init__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the span ruler. If patterns are supplied here, they need to be a list\\nof dictionaries with a \", _jsx(InlineCode, {\n          children: \"\\\"label\\\"\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"\\\"pattern\\\"\"\n        }), \" key. A pattern can either be a\\ntoken pattern (list) or a phrase pattern (string). For example:\\n\", _jsx(InlineCode, {\n          children: \"{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction via add_pipe\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\n\\n# Construction from class\\nfrom spacy.pipeline import SpanRuler\\nruler = SpanRuler(nlp, overwrite=True)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared nlp object to pass the vocab to the matchers and process phrase patterns. \", _jsx(_components.del, {\n                children: \"Language\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Instance name of the current pipeline component. Typically passed in automatically from the factory when the component is added. Used to disable the current span ruler while creating phrase patterns with the nlp object. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spans_key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The spans key to save the spans under. If \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \", no spans are saved. Defaults to \", _jsx(InlineCode, {\n                children: \"\\\"ruler\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"spans_filter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The optional method to filter spans before they are assigned to doc.spans. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable[[Iterable[Span], Iterable[Span]], List[Span]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"annotate_ents\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to save spans to doc.ents. Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ents_filter\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The method to filter spans before they are assigned to doc.ents. Defaults to \", _jsx(InlineCode, {\n                children: \"util.filter_chain_spans\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[Iterable[Span], Iterable[Span]], List[Span]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher_attr\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Token attribute to match on, passed to the internal PhraseMatcher as \", _jsx(InlineCode, {\n                children: \"attr\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Union[int, str]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"matcher_fuzzy_compare\"\n              }), \" \", _jsx(Tag, {\n                variant: \"new\",\n                children: \"3.5\"\n              })]\n            }), _jsxs(_components.td, {\n              children: [\"The fuzzy comparison method, passed on to the internal \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"spacy.matcher.levenshtein.levenshtein_compare\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated, passed to Matcher and PhraseMatcher as \", _jsx(InlineCode, {\n                children: \"validate\"\n              }), \". Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"overwrite\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether to remove any existing spans under \", _jsx(InlineCode, {\n                children: \"Doc.spans[spans key]\"\n              }), \" if \", _jsx(InlineCode, {\n                children: \"spans_key\"\n              }), \" is set, or to remove any ents under \", _jsx(InlineCode, {\n                children: \"Doc.ents\"\n              }), \" if \", _jsx(InlineCode, {\n                children: \"annotate_ents\"\n              }), \" is set. Defaults to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_spans\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_spans\"\n                })\n              }), \" for \", _jsx(InlineCode, {\n                children: \"Doc.spans[spans_key]\"\n              }), \" with overlapping spans allowed. \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-initialize\",\n      children: [_jsx(_components.h2, {\n        id: \"initialize\",\n        tag: \"method\",\n        children: \"SpanRuler.initialize \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the component with data and used before training to load in rules\\nfrom a \", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching/#spanruler-files\",\n          children: \"pattern file\"\n        }), \". This method\\nis typically called by \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Language.initialize\"\n          })\n        }), \" and\\nlets you customize arguments it receives via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize.components]\"\n          })\n        }), \" block in the\\nconfig. Any existing patterns are removed on initialization.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"span_ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nspan_ruler.initialize(lambda: [], nlp=nlp, patterns=patterns)\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[initialize.components.span_ruler]\\n\\n[initialize.components.span_ruler.patterns]\\n@readers = \\\"srsly.read_jsonl.v1\\\"\\npath = \\\"corpus/span_ruler_patterns.jsonl\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that returns gold-standard annotations in the form of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects. Not used by the \", _jsx(InlineCode, {\n                children: \"SpanRuler\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Callable[[], Iterable[Example]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The list of patterns. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Sequence[Dict[str, Union[str, List[Dict[str, Any]]]]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-len\",\n      children: [_jsx(_components.h2, {\n        id: \"len\",\n        tag: \"method\",\n        children: \"SpanRuler.__len__ \"\n      }), _jsx(_components.p, {\n        children: \"The number of all patterns added to the span ruler.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nassert len(ruler) == 0\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\nassert len(ruler) == 1\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The number of patterns. \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-contains\",\n      children: [_jsx(_components.h2, {\n        id: \"contains\",\n        tag: \"method\",\n        children: \"SpanRuler.__contains__ \"\n      }), _jsx(_components.p, {\n        children: \"Whether a label is present in the patterns.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\nassert \\\"ORG\\\" in ruler\\nassert not \\\"PERSON\\\" in ruler\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label to check. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether the span ruler contains the label. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"SpanRuler.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Find matches in the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and add them to \", _jsx(InlineCode, {\n          children: \"doc.spans[span_key]\"\n        }), \" and/or\\n\", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \". Typically, this happens automatically after the component has been\\nadded to the pipeline using \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". If the\\nspan ruler was initialized with \", _jsx(InlineCode, {\n          children: \"overwrite=True\"\n        }), \", existing spans and entities\\nwill be removed.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns([{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"}])\\n\\ndoc = nlp(\\\"A text about Apple.\\\")\\nspans = [(span.text, span.label_) for span in doc.spans[\\\"ruler\\\"]]\\nassert spans == [(\\\"Apple\\\", \\\"ORG\\\")]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object to process, e.g. the \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" with added spans/entities. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add_patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"add_patterns\",\n        tag: \"method\",\n        children: \"SpanRuler.add_patterns \"\n      }), _jsxs(_components.p, {\n        children: [\"Add patterns to the span ruler. A pattern can either be a token pattern (list of\\ndicts) or a phrase pattern (string). For more details, see the usage guide on\\n\", _jsx(_components.a, {\n          href: \"/usage/rule-based-matching\",\n          children: \"rule-based matching\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [\\n    {\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\"},\\n    {\\\"label\\\": \\\"GPE\\\", \\\"pattern\\\": [{\\\"lower\\\": \\\"san\\\"}, {\\\"lower\\\": \\\"francisco\\\"}]}\\n]\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns(patterns)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The patterns to add. \", _jsx(_components.del, {\n                children: \"List[Dict[str, Union[str, List[dict]]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove\",\n      children: [_jsx(_components.h2, {\n        id: \"remove\",\n        tag: \"method\",\n        children: \"SpanRuler.remove \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove patterns by label from the span ruler. A \", _jsx(InlineCode, {\n          children: \"ValueError\"\n        }), \" is raised if the\\nlabel does not exist in any patterns.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\", \\\"id\\\": \\\"apple\\\"}]\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns(patterns)\\nruler.remove(\\\"ORG\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"label\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The label of the pattern rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-remove_by_id\",\n      children: [_jsx(_components.h2, {\n        id: \"remove_by_id\",\n        tag: \"method\",\n        children: \"SpanRuler.remove_by_id \"\n      }), _jsxs(_components.p, {\n        children: [\"Remove patterns by ID from the span ruler. A \", _jsx(InlineCode, {\n          children: \"ValueError\"\n        }), \" is raised if the ID\\ndoes not exist in any patterns.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\", \\\"id\\\": \\\"apple\\\"}]\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns(patterns)\\nruler.remove_by_id(\\\"apple\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"pattern_id\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The ID of the pattern rule. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-clear\",\n      children: [_jsx(_components.h2, {\n        id: \"clear\",\n        tag: \"method\",\n        children: \"SpanRuler.clear \"\n      }), _jsx(_components.p, {\n        children: \"Remove all patterns the span ruler.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"patterns = [{\\\"label\\\": \\\"ORG\\\", \\\"pattern\\\": \\\"Apple\\\", \\\"id\\\": \\\"apple\\\"}]\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.add_patterns(patterns)\\nruler.clear()\\n\"\n          })\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        children: \"SpanRuler.to_disk \"\n      }), _jsx(_components.p, {\n        children: \"Save the span ruler patterns to a directory. The patterns will be saved as\\nnewline-delimited JSON (JSONL).\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.to_disk(\\\"/path/to/span_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory, which will be created if it doesn’t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        children: \"SpanRuler.from_disk \"\n      }), _jsx(_components.p, {\n        children: \"Load the span ruler from a path.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.from_disk(\\\"/path/to/span_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"SpanRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"SpanRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"SpanRuler.to_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Serialize the span ruler to a bytestring.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler_bytes = ruler.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized patterns. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"SpanRuler.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from a bytestring. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler_bytes = ruler.to_bytes()\\nruler = nlp.add_pipe(\\\"span_ruler\\\")\\nruler.from_bytes(ruler_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The bytestring to load. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"SpanRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"SpanRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-labels\",\n      children: [_jsx(_components.h2, {\n        id: \"labels\",\n        tag: \"property\",\n        children: \"SpanRuler.labels \"\n      }), _jsx(_components.p, {\n        children: \"All labels present in the match patterns.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string labels. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-ids\",\n      children: [_jsx(_components.h2, {\n        id: \"ids\",\n        tag: \"property\",\n        children: \"SpanRuler.ids \"\n      }), _jsxs(_components.p, {\n        children: [\"All IDs present in the \", _jsx(InlineCode, {\n          children: \"id\"\n        }), \" property of the match patterns.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The string IDs. \", _jsx(_components.del, {\n                children: \"Tuple[str, …]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"patterns\",\n        tag: \"property\",\n        children: \"SpanRuler.patterns \"\n      }), _jsx(_components.p, {\n        children: \"All patterns that were added to the span ruler.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The original patterns, one dictionary per pattern. \", _jsx(_components.del, {\n                children: \"List[Dict[str, Union[str, dict]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"attributes\",\n        children: \"Attributes \"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"key\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The spans key that spans are saved under. \", _jsx(_components.del, {\n                children: \"Optional[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"matcher\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The underlying matcher used to process token patterns. \", _jsx(_components.del, {\n                children: \"Matcher\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"phrase_matcher\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The underlying phrase matcher used to process phrase patterns. \", _jsx(_components.del, {\n                children: \"PhraseMatcher\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"SpanRuler","tag":"class","source":"spacy/pipeline/span_ruler.py","version":3.3,"teaser":"Pipeline component for rule-based span and named entity recognition","api_string_name":"span_ruler","api_trainable":false},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":"span_ruler","baseClass":null,"trainable":false},"isIndex":false,"next":null},"__N_SSG":true}