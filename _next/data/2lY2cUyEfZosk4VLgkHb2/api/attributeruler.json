{"pageProps":{"title":"AttributeRuler","tag":"class","source":"spacy/pipeline/attributeruler.py","version":3,"teaser":"Pipeline component for rule-based token attribute assignment","api_string_name":"attribute_ruler","api_trainable":false,"slug":"/api/attributeruler","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    em: \"em\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {InlineCode} = _components;\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsxs(_components.p, {\n        children: [\"The attribute ruler lets you set token attributes for tokens identified by\\n\", _jsxs(_components.a, {\n          href: \"/usage/rule-based-matching#matcher\",\n          children: [_jsx(InlineCode, {\n            children: \"Matcher\"\n          }), \" patterns\"]\n        }), \". The attribute ruler is\\ntypically used to handle exceptions for token attributes and to map values\\nbetween attributes such as mapping fine-grained POS tags to coarse-grained POS\\ntags. See the \", _jsx(_components.a, {\n          href: \"/usage/linguistic-features/#mappings-exceptions\",\n          children: \"usage guide\"\n        }), \" for\\nexamples.\"]\n      })\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-config\",\n      children: [_jsx(_components.h2, {\n        id: \"config\",\n        children: \"Config and implementation \"\n      }), _jsxs(_components.p, {\n        children: [\"The default config is defined by the pipeline component factory and describes\\nhow the component should be configured. You can override its settings via the\\n\", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on \", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" or in your\\n\", _jsxs(_components.a, {\n          href: \"/usage/training#config\",\n          children: [_jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" for training\"]\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"config = {\\\"validate\\\": True}\\nnlp.add_pipe(\\\"attribute_ruler\\\", config=config)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Setting\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated (passed to the \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \"). Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          })\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/attributeruler.py\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/pipeline/attributeruler.py\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-init\",\n      children: [_jsx(_components.h2, {\n        id: \"init\",\n        tag: \"method\",\n        children: \"AttributeRuler.__init__ \"\n      }), _jsx(_components.p, {\n        children: \"Initialize the attribute ruler.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Construction via add_pipe\\nruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared vocabulary to pass to the matcher. \", _jsx(_components.del, {\n                children: \"Vocab\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Instance name of the current pipeline component. Typically passed in automatically from the factory when the component is added. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"validate\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Whether patterns should be validated (passed to the \", _jsx(_components.a, {\n                href: \"/api/matcher#init\",\n                children: _jsx(InlineCode, {\n                  children: \"Matcher\"\n                })\n              }), \"). Defaults to \", _jsx(InlineCode, {\n                children: \"False\"\n              }), \". \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"scorer\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The scoring method. Defaults to \", _jsx(_components.a, {\n                href: \"/api/scorer#score_token_attr\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_token_attr\"\n                })\n              }), \" for the attributes \", _jsx(InlineCode, {\n                children: \"\\\"tag\"\n              }), \"â€œ, \", _jsx(InlineCode, {\n                children: \"\\\"pos\\\"\"\n              }), \", \", _jsx(InlineCode, {\n                children: \"\\\"morph\\\"\"\n              }), \" and \", _jsx(InlineCode, {\n                children: \"\\\"lemma\\\"\"\n              }), \" and \", _jsx(_components.a, {\n                href: \"/api/scorer#score_token_attr_per_feat\",\n                children: _jsx(InlineCode, {\n                  children: \"Scorer.score_token_attr_per_feat\"\n                })\n              }), \" for the attribute \", _jsx(InlineCode, {\n                children: \"\\\"morph\\\"\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Callable]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-call\",\n      children: [_jsx(_components.h2, {\n        id: \"call\",\n        tag: \"method\",\n        children: \"AttributeRuler.__call__ \"\n      }), _jsxs(_components.p, {\n        children: [\"Apply the attribute ruler to a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", setting token attributes for tokens\\nmatched by the provided patterns.\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The document to process. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The processed document. \", _jsx(_components.del, {\n                children: \"Doc\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add\",\n      children: [_jsx(_components.h2, {\n        id: \"add\",\n        tag: \"method\",\n        children: \"AttributeRuler.add \"\n      }), _jsxs(_components.p, {\n        children: [\"Add patterns to the attribute ruler. The patterns are a list of \", _jsx(InlineCode, {\n          children: \"Matcher\"\n        }), \"\\npatterns and the attributes are a dict of attributes to set on the matched\\ntoken. If the pattern matches a span of more than one token, the \", _jsx(InlineCode, {\n          children: \"index\"\n        }), \" can be\\nused to set the attributes for the token at that index in the span. The \", _jsx(InlineCode, {\n          children: \"index\"\n        }), \"\\nmay be negative to index from the end of the span.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\npatterns = [[{\\\"TAG\\\": \\\"VB\\\"}]]\\nattrs = {\\\"POS\\\": \\\"VERB\\\"}\\nruler.add(patterns=patterns, attrs=attrs)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \" patterns to add. \", _jsx(_components.del, {\n                children: \"Iterable[List[Dict[Union[int, str], Any]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The attributes to assign to the target token in the matched span. \", _jsx(_components.del, {\n                children: \"Dict[str, Any]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"index\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The index of the token in the matched span to modify. May be negative to index from the end of the span. Defaults to \", _jsx(InlineCode, {\n                children: \"0\"\n              }), \". \", _jsx(_components.del, {\n                children: \"int\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-add_patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"add_patterns\",\n        tag: \"method\",\n        children: \"AttributeRuler.add_patterns \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\npatterns = [\\n  {\\n    \\\"patterns\\\": [[{\\\"TAG\\\": \\\"VB\\\"}]], \\\"attrs\\\": {\\\"POS\\\": \\\"VERB\\\"}\\n  },\\n  {\\n    \\\"patterns\\\": [[{\\\"LOWER\\\": \\\"two\\\"}, {\\\"LOWER\\\": \\\"apples\\\"}]],\\n    \\\"attrs\\\": {\\\"LEMMA\\\": \\\"apple\\\"},\\n    \\\"index\\\": -1\\n  },\\n]\\nruler.add_patterns(patterns)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Add patterns from a list of pattern dicts. Each pattern dict can specify the\\nkeys \", _jsx(InlineCode, {\n          children: \"\\\"patterns\\\"\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"\\\"attrs\\\"\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"\\\"index\\\"\"\n        }), \", which match the arguments of\\n\", _jsx(_components.a, {\n          href: \"/api/attributeruler#add\",\n          children: _jsx(InlineCode, {\n            children: \"AttributeRuler.add\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The patterns to add. \", _jsx(_components.del, {\n                children: \"Iterable[Dict[str, Union[List[dict], dict, int]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-patterns\",\n      children: [_jsx(_components.h2, {\n        id: \"patterns\",\n        tag: \"property\",\n        children: \"AttributeRuler.patterns \"\n      }), _jsxs(_components.p, {\n        children: [\"Get all patterns that have been added to the attribute ruler in the\\n\", _jsx(InlineCode, {\n          children: \"patterns_dict\"\n        }), \" format accepted by\\n\", _jsx(_components.a, {\n          href: \"/api/attributeruler#add_patterns\",\n          children: _jsx(InlineCode, {\n            children: \"AttributeRuler.add_patterns\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The patterns added to the attribute ruler. \", _jsx(_components.del, {\n                children: \"List[Dict[str, Union[List[dict], dict, int]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-initialize\",\n      children: [_jsx(_components.h2, {\n        id: \"initialize\",\n        tag: \"method\",\n        children: \"AttributeRuler.initialize \"\n      }), _jsxs(_components.p, {\n        children: [\"Initialize the component with data and used before training to load in rules\\nfrom a file. This method is typically called by\\n\", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Language.initialize\"\n          })\n        }), \" and lets you customize\\narguments it receives via the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize.components]\"\n          })\n        }), \" block in the\\nconfig.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\nruler.initialize(lambda: [], nlp=nlp, patterns=patterns)\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[initialize.components.attribute_ruler]\\n\\n[initialize.components.attribute_ruler.patterns]\\n@readers = \\\"srsly.read_json.v1\\\"\\npath = \\\"corpus/attribute_ruler_patterns.json\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"get_examples\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Function that returns gold-standard annotations in the form of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects (the training data). Not used by this component. \", _jsx(_components.del, {\n                children: \"Callable[[], Iterable[Example]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Language]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of pattern dicts with the keys as the arguments to \", _jsx(_components.a, {\n                href: \"/api/attributeruler#add\",\n                children: _jsx(InlineCode, {\n                  children: \"AttributeRuler.add\"\n                })\n              }), \" (\", _jsx(InlineCode, {\n                children: \"patterns\"\n              }), \"/\", _jsx(InlineCode, {\n                children: \"attrs\"\n              }), \"/\", _jsx(InlineCode, {\n                children: \"index\"\n              }), \") to add as patterns. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Iterable[Dict[str, Union[List[dict], dict, int]]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tag_map\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The tag map that maps fine-grained tags to coarse-grained tags and morphological features. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, Dict[Union[int, str], Union[int, str]]]]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"morph_rules\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The morph rules that map token text and fine-grained tags to coarse-grained tags, lemmas and morphological features. Defaults to \", _jsx(InlineCode, {\n                children: \"None\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Optional[Dict[str, Dict[str, Dict[Union[int, str], Union[int, str]]]]]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-load_from_tag_map\",\n      children: [_jsx(_components.h2, {\n        id: \"load_from_tag_map\",\n        tag: \"method\",\n        children: \"AttributeRuler.load_from_tag_map \"\n      }), _jsx(_components.p, {\n        children: \"Load attribute ruler patterns from a tag map.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tag_map\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The tag map that maps fine-grained tags to coarse-grained tags and morphological features. \", _jsx(_components.del, {\n                children: \"Dict[str, Dict[Union[int, str], Union[int, str]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-load_from_morph_rules\",\n      children: [_jsx(_components.h2, {\n        id: \"load_from_morph_rules\",\n        tag: \"method\",\n        children: \"AttributeRuler.load_from_morph_rules \"\n      }), _jsx(_components.p, {\n        children: \"Load attribute ruler patterns from morph rules.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsx(_components.tbody, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"morph_rules\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The morph rules that map token text and fine-grained tags to coarse-grained tags, lemmas and morphological features. \", _jsx(_components.del, {\n                children: \"Dict[str, Dict[str, Dict[Union[int, str], Union[int, str]]]]\"\n              })]\n            })]\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"to_disk\",\n        tag: \"method\",\n        children: \"AttributeRuler.to_disk \"\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to disk.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\nruler.to_disk(\\\"/path/to/attribute_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory, which will be created if it doesnâ€™t exist. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_disk\",\n      children: [_jsx(_components.h2, {\n        id: \"from_disk\",\n        tag: \"method\",\n        children: \"AttributeRuler.from_disk \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from disk. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\nruler.from_disk(\\\"/path/to/attribute_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"path\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A path to a directory. Paths may be either strings or \", _jsx(InlineCode, {\n                children: \"Path\"\n              }), \"-like objects. \", _jsx(_components.del, {\n                children: \"Union[str, Path]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The modified \", _jsx(InlineCode, {\n                children: \"AttributeRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"AttributeRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-to_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"to_bytes\",\n        tag: \"method\",\n        children: \"AttributeRuler.to_bytes \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\nruler = ruler.to_bytes()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Serialize the pipe to a bytestring.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The serialized form of the \", _jsx(InlineCode, {\n                children: \"AttributeRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-from_bytes\",\n      children: [_jsx(_components.h2, {\n        id: \"from_bytes\",\n        tag: \"method\",\n        children: \"AttributeRuler.from_bytes \"\n      }), _jsx(_components.p, {\n        children: \"Load the pipe from a bytestring. Modifies the object in place and returns it.\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"ruler_bytes = ruler.to_bytes()\\nruler = nlp.add_pipe(\\\"attribute_ruler\\\")\\nruler.from_bytes(ruler_bytes)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"bytes_data\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The data to load from. \", _jsx(_components.del, {\n                children: \"bytes\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.em, {\n                children: \"keyword-only\"\n              })\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"exclude\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String names of \", _jsx(_components.a, {\n                href: \"#serialization-fields\",\n                children: \"serialization fields\"\n              }), \" to exclude. \", _jsx(_components.del, {\n                children: \"Iterable[str]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"AttributeRuler\"\n              }), \" object. \", _jsx(_components.del, {\n                children: \"AttributeRuler\"\n              })]\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-serialization-fields\",\n      children: [_jsx(_components.h2, {\n        id: \"serialization-fields\",\n        children: \"Serialization fields \"\n      }), _jsxs(_components.p, {\n        children: [\"During serialization, spaCy will export several data fields used to restore\\ndifferent aspects of the object. If needed, you can exclude them from\\nserialization by passing in the string names via the \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" argument.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"data = ruler.to_disk(\\\"/path\\\", exclude=[\\\"vocab\\\"])\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"vocab\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The shared \", _jsx(_components.a, {\n                href: \"/api/vocab\",\n                children: _jsx(InlineCode, {\n                  children: \"Vocab\"\n                })\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"patterns\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Matcher\"\n              }), \" patterns. You usually donâ€™t want to exclude this.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attrs\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The attributes to set. You usually donâ€™t want to exclude this.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"indices\"\n              })\n            }), _jsx(_components.td, {\n              children: \"The token indices. You usually donâ€™t want to exclude this.\"\n            })]\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"AttributeRuler","tag":"class","source":"spacy/pipeline/attributeruler.py","version":3,"teaser":"Pipeline component for rule-based token attribute assignment","api_string_name":"attribute_ruler","api_trainable":false},"scope":{}},"sectionTitle":"API Documentation","theme":"green","section":"api","apiDetails":{"stringName":"attribute_ruler","baseClass":null,"trainable":false},"isIndex":false,"next":null},"__N_SSG":true}