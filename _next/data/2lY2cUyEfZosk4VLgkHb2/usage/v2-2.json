{"pageProps":{"title":"What's New in v2.2","teaser":"New features, backwards incompatibilities and migration guide","menu":[["New Features","features"],["Backwards Incompatibilities","incompat"],["Migrating from v2.1","migrating"]],"slug":"/usage/v2-2","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h3: \"h3\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Infobox, InlineCode, Accordion} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      id: \"section-features\",\n      children: [_jsx(_components.h2, {\n        id: \"features\",\n        hidden: \"true\",\n        children: \"New Features \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy v2.2 features improved statistical models, new pretrained models for\\nNorwegian and Lithuanian, better Dutch NER, as well as a new mechanism for\\nstoring language data that makes the installation about \", _jsx(_components.strong, {\n          children: \"5-10× smaller\"\n        }), \"\\non disk. We’ve also added a new class to efficiently \", _jsx(_components.strong, {\n          children: \"serialize annotations\"\n        }), \",\\nan improved and \", _jsx(_components.strong, {\n          children: \"10× faster\"\n        }), \" phrase matching engine, built-in scoring\\nand \", _jsx(_components.strong, {\n          children: \"CLI training for text classification\"\n        }), \", a new command to analyze and\\n\", _jsx(_components.strong, {\n          children: \"debug training data\"\n        }), \", data augmentation during training and more. For the\\nfull changelog, see the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spaCy/releases/tag/v2.2.0\",\n          children: \"release notes on GitHub\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"For more details and a behind-the-scenes look at the new release,\\n\", _jsx(_components.a, {\n          href: \"https://explosion.ai/blog/spacy-v2-2\",\n          children: \"see our blog post\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"models\",\n        children: \"Better pretrained models and more languages \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            lang: \"bash\",\n            children: \"python -m spacy download nl_core_news_sm\\npython -m spacy download nb_core_news_sm\\npython -m spacy download lt_core_news_sm\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The new version also features new and re-trained models for all languages and\\nresolves a number of data bugs. The \", _jsx(_components.a, {\n          href: \"/models/nl\",\n          children: \"Dutch model\"\n        }), \" has been retrained\\nwith a new and custom-labelled NER corpus using the same extended label scheme\\nas the English models. It should now produce significantly better NER results\\noverall. We’ve also added new core models for \", _jsx(_components.a, {\n          href: \"/models/nb\",\n          children: \"Norwegian\"\n        }), \" (MIT) and\\n\", _jsx(_components.a, {\n          href: \"/models/lt\",\n          children: \"Lithuanian\"\n        }), \" (CC BY-SA).\"]\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Usage:\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/models\",\n            children: \"Models directory\"\n          }), \" **Benchmarks: **\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spaCy/releases/tag/v2.2.0\",\n            children: \"Release notes\"\n          })]\n        })\n      }), _jsx(_components.h3, {\n        id: \"train-textcat-cli\",\n        children: \"Text classification scores and CLI training \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            lang: \"bash\",\n            children: \"$ python -m spacy train en /output /train /dev \\\\\\\\\\n--pipeline textcat --textcat-arch simple_cnn \\\\\\\\\\n--textcat-multilabel\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"When training your models using the \", _jsx(InlineCode, {\n          children: \"spacy train\"\n        }), \" command, you can now also\\ninclude text categories in the JSON-formatted training data. The \", _jsx(InlineCode, {\n          children: \"Scorer\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"nlp.evaluate\"\n        }), \" now report the text classification scores, calculated as the\\nF-score on positive label for binary exclusive tasks, the macro-averaged F-score\\nfor 3+ exclusive labels or the macro-averaged AUC ROC score for multilabel\\nclassification.\"]\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"API:\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/api/cli#train\",\n            children: _jsx(InlineCode, {\n              children: \"spacy train\"\n            })\n          }), \", \", _jsx(_components.a, {\n            href: \"/api/scorer\",\n            children: _jsx(InlineCode, {\n              children: \"Scorer\"\n            })\n          }), \",\\n\", _jsx(_components.a, {\n            href: \"/api/language#evaluate\",\n            children: _jsx(InlineCode, {\n              children: \"Language.evaluate\"\n            })\n          })]\n        })\n      }), _jsx(_components.h3, {\n        children: \"New DocBin class to efficiently serialize Doc collections\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.tokens import DocBin\\ndoc_bin = DocBin(attrs=[\\\"LEMMA\\\", \\\"ENT_IOB\\\", \\\"ENT_TYPE\\\"], store_user_data=True)\\nfor doc in nlp.pipe(texts):\\n    doc_bin.add(doc)\\nbytes_data = doc_bin.to_bytes()\\n# Deserialize later, e.g. in a new process\\nnlp = spacy.blank(\\\"en\\\")\\ndoc_bin = DocBin().from_bytes(bytes_data)\\ndocs = list(doc_bin.get_docs(nlp.vocab))\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"If you’re working with lots of data, you’ll probably need to pass analyses\\nbetween machines, either to use something like \", _jsx(_components.a, {\n          href: \"https://dask.org\",\n          children: \"Dask\"\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"https://spark.apache.org\",\n          children: \"Spark\"\n        }), \", or even just to save out work to disk. Often\\nit’s sufficient to use the \", _jsx(InlineCode, {\n          children: \"Doc.to_array\"\n        }), \" functionality for this, and just\\nserialize the numpy arrays – but other times you want a more general way to save\\nand restore \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The new \", _jsx(InlineCode, {\n          children: \"DocBin\"\n        }), \" class makes it easy to serialize and deserialize a collection\\nof \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects together, and is much more efficient than calling\\n\", _jsx(InlineCode, {\n          children: \"Doc.to_bytes\"\n        }), \" on each individual \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object. You can also control what data\\ngets saved, and you can merge pallets together for easy map/reduce-style\\nprocessing.\"]\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"API:\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/api/docbin\",\n            children: _jsx(InlineCode, {\n              children: \"DocBin\"\n            })\n          }), \" **Usage: **\\n\", _jsx(_components.a, {\n            href: \"/usage/saving-loading#docs\",\n            children: \"Serializing Doc objects\"\n          })]\n        })\n      }), _jsx(_components.h3, {\n        id: \"lookups\",\n        children: \"Serializable lookup tables and smaller installation \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"data = {\\\"foo\\\": \\\"bar\\\"}\\nnlp.vocab.lookups.add_table(\\\"my_dict\\\", data)\\n\\ndef custom_component(doc):\\n   table = doc.vocab.lookups.get_table(\\\"my_dict\\\")\\n   print(table.get(\\\"foo\\\"))  # look something up\\n   return doc\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The new \", _jsx(InlineCode, {\n          children: \"Lookups\"\n        }), \" API lets you add large dictionaries and lookup tables to the\\n\", _jsx(InlineCode, {\n          children: \"Vocab\"\n        }), \" and access them from the tokenizer or custom components and extension\\nattributes. Internally, the tables use Bloom filters for efficient lookup\\nchecks. They’re also fully serializable out-of-the-box. All large data resources\\nlike lemmatization tables have been moved to a separate package,\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-lookups-data\",\n          children: _jsx(InlineCode, {\n            children: \"spacy-lookups-data\"\n          })\n        }), \" that can\\nbe installed alongside the core library. This allowed us to make the spaCy\\ninstallation \", _jsx(_components.strong, {\n          children: \"5-10× smaller on disk\"\n        }), \" (depending on your platform).\\n\", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"Pretrained models\"\n        }), \" now include their data files, so you only need to\\ninstall the lookups if you want to build blank models or use lemmatization with\\nlanguages that don’t yet ship with pretrained models.\"]\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"API:\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/api/lookups\",\n            children: _jsx(InlineCode, {\n              children: \"Lookups\"\n            })\n          }), \",\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-lookups-data\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-lookups-data\"\n            })\n          }), \" **Usage:\\n** \", _jsx(_components.a, {\n            href: \"/usage/adding-languages#lemmatizer\",\n            children: \"Adding languages: Lemmatizer\"\n          })]\n        })\n      }), _jsx(_components.h3, {\n        id: \"debug-data\",\n        children: \"CLI command to debug and validate training data \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            lang: \"bash\",\n            children: \"$ python -m spacy debug-data en train.json dev.json\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The new \", _jsx(InlineCode, {\n          children: \"debug-data\"\n        }), \" command lets you analyze and validate your training and\\ndevelopment data, get useful stats, and find problems like invalid entity\\nannotations, cyclic dependencies, low data labels and more. If you’re training a\\nmodel with \", _jsx(InlineCode, {\n          children: \"spacy train\"\n        }), \" and the results seem surprising or confusing,\\n\", _jsx(InlineCode, {\n          children: \"debug-data\"\n        }), \" may help you track down the problems and improve your training\\ndata.\"]\n      }), _jsx(Accordion, {\n        title: \"Example output\",\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            lang: \"none\",\n            children: \"=========================== Data format validation ===========================\\n✔ Corpus is loadable\\n\\n=============================== Training stats ===============================\\nTraining pipeline: tagger, parser, ner\\nStarting with blank model 'en'\\n18127 training docs\\n2939 evaluation docs\\n⚠ 34 training examples also in evaluation data\\n\\n============================== Vocab & Vectors ==============================\\nℹ 2083156 total words in the data (56962 unique)\\n⚠ 13020 misaligned tokens in the training data\\n⚠ 2423 misaligned tokens in the dev data\\n10 most common words: 'the' (98429), ',' (91756), '.' (87073), 'to' (50058),\\n'of' (49559), 'and' (44416), 'a' (34010), 'in' (31424), 'that' (22792), 'is'\\n(18952)\\nℹ No word vectors present in the model\\n\\n========================== Named Entity Recognition ==========================\\nℹ 18 new labels, 0 existing labels\\n528978 missing values (tokens with '-' label)\\nNew: 'ORG' (23860), 'PERSON' (21395), 'GPE' (21193), 'DATE' (18080), 'CARDINAL'\\n(10490), 'NORP' (9033), 'MONEY' (5164), 'PERCENT' (3761), 'ORDINAL' (2122),\\n'LOC' (2113), 'TIME' (1616), 'WORK_OF_ART' (1229), 'QUANTITY' (1150), 'FAC'\\n(1134), 'EVENT' (974), 'PRODUCT' (935), 'LAW' (444), 'LANGUAGE' (338)\\n✔ Good amount of examples for all labels\\n✔ Examples without occurences available for all labels\\n✔ No entities consisting of or starting/ending with whitespace\\n\\n=========================== Part-of-speech Tagging ===========================\\nℹ 49 labels in data (57 labels in tag map)\\n'NN' (266331), 'IN' (227365), 'DT' (185600), 'NNP' (164404), 'JJ' (119830),\\n'NNS' (110957), '.' (101482), ',' (92476), 'RB' (90090), 'PRP' (90081), 'VB'\\n(74538), 'VBD' (68199), 'CC' (62862), 'VBZ' (50712), 'VBP' (43420), 'VBN'\\n(42193), 'CD' (40326), 'VBG' (34764), 'TO' (31085), 'MD' (25863), 'PRP$'\\n(23335), 'HYPH' (13833), 'POS' (13427), 'UH' (13322), 'WP' (10423), 'WDT'\\n(9850), 'RP' (8230), 'WRB' (8201), ':' (8168), '''' (7392), '``' (6984), 'NNPS'\\n(5817), 'JJR' (5689), '$' (3710), 'EX' (3465), 'JJS' (3118), 'RBR' (2872),\\n'-RRB-' (2825), '-LRB-' (2788), 'PDT' (2078), 'XX' (1316), 'RBS' (1142), 'FW'\\n(794), 'NFP' (557), 'SYM' (440), 'WP$' (294), 'LS' (293), 'ADD' (191), 'AFX'\\n(24)\\n✔ All labels present in tag map for language 'en'\\n\\n============================= Dependency Parsing =============================\\nℹ Found 111703 sentences with an average length of 18.6 words.\\nℹ Found 2251 nonprojective train sentences\\nℹ Found 303 nonprojective dev sentences\\nℹ 47 labels in train data\\nℹ 211 labels in projectivized train data\\n'punct' (236796), 'prep' (188853), 'pobj' (182533), 'det' (172674), 'nsubj'\\n(169481), 'compound' (116142), 'ROOT' (111697), 'amod' (107945), 'dobj' (93540),\\n'aux' (86802), 'advmod' (86197), 'cc' (62679), 'conj' (59575), 'poss' (36449),\\n'ccomp' (36343), 'advcl' (29017), 'mark' (27990), 'nummod' (24582), 'relcl'\\n(21359), 'xcomp' (21081), 'attr' (18347), 'npadvmod' (17740), 'acomp' (17204),\\n'auxpass' (15639), 'appos' (15368), 'neg' (15266), 'nsubjpass' (13922), 'case'\\n(13408), 'acl' (12574), 'pcomp' (10340), 'nmod' (9736), 'intj' (9285), 'prt'\\n(8196), 'quantmod' (7403), 'dep' (4300), 'dative' (4091), 'agent' (3908), 'expl'\\n(3456), 'parataxis' (3099), 'oprd' (2326), 'predet' (1946), 'csubj' (1494),\\n'subtok' (1147), 'preconj' (692), 'meta' (469), 'csubjpass' (64), 'iobj' (1)\\n⚠ Low number of examples for label 'iobj' (1)\\n⚠ Low number of examples for 130 labels in the projectivized dependency\\ntrees used for training. You may want to projectivize labels such as punct\\nbefore training in order to improve parser performance.\\n⚠ Projectivized labels with low numbers of examples: appos||attr: 12\\nadvmod||dobj: 13 prep||ccomp: 12 nsubjpass||ccomp: 15 pcomp||prep: 14\\namod||dobj: 9 attr||xcomp: 14 nmod||nsubj: 17 prep||advcl: 2 prep||prep: 5\\nnsubj||conj: 12 advcl||advmod: 18 ccomp||advmod: 11 ccomp||pcomp: 5 acl||pobj:\\n10 npadvmod||acomp: 7 dobj||pcomp: 14 nsubjpass||pcomp: 1 nmod||pobj: 8\\namod||attr: 6 nmod||dobj: 12 aux||conj: 1 neg||conj: 1 dative||xcomp: 11\\npobj||dative: 3 xcomp||acomp: 19 advcl||pobj: 2 nsubj||advcl: 2 csubj||ccomp: 1\\nadvcl||acl: 1 relcl||nmod: 2 dobj||advcl: 10 advmod||advcl: 3 nmod||nsubjpass: 6\\namod||pobj: 5 cc||neg: 1 attr||ccomp: 16 advcl||xcomp: 3 nmod||attr: 4\\nadvcl||nsubjpass: 5 advcl||ccomp: 4 ccomp||conj: 1 punct||acl: 1 meta||acl: 1\\nparataxis||acl: 1 prep||acl: 1 amod||nsubj: 7 ccomp||ccomp: 3 acomp||xcomp: 5\\ndobj||acl: 5 prep||oprd: 6 advmod||acl: 2 dative||advcl: 1 pobj||agent: 5\\nxcomp||amod: 1 dep||advcl: 1 prep||amod: 8 relcl||compound: 1 advcl||csubj: 3\\nnpadvmod||conj: 2 npadvmod||xcomp: 4 advmod||nsubj: 3 ccomp||amod: 7\\nadvcl||conj: 1 nmod||conj: 2 advmod||nsubjpass: 2 dep||xcomp: 2 appos||ccomp: 1\\nadvmod||dep: 1 advmod||advmod: 5 aux||xcomp: 8 dep||advmod: 1 dative||ccomp: 2\\nprep||dep: 1 conj||conj: 1 dep||ccomp: 4 cc||ROOT: 1 prep||ROOT: 1 nsubj||pcomp:\\n3 advmod||prep: 2 relcl||dative: 1 acl||conj: 1 advcl||attr: 4 prep||npadvmod: 1\\nnsubjpass||xcomp: 1 neg||advmod: 1 xcomp||oprd: 1 advcl||advcl: 1 dobj||dep: 3\\nnsubjpass||parataxis: 1 attr||pcomp: 1 ccomp||parataxis: 1 advmod||attr: 1\\nnmod||oprd: 1 appos||nmod: 2 advmod||relcl: 1 appos||npadvmod: 1 appos||conj: 1\\nprep||expl: 1 nsubjpass||conj: 1 punct||pobj: 1 cc||pobj: 1 conj||pobj: 1\\npunct||conj: 1 ccomp||dep: 1 oprd||xcomp: 3 ccomp||xcomp: 1 ccomp||nsubj: 1\\nnmod||dep: 1 xcomp||ccomp: 1 acomp||advcl: 1 intj||advmod: 1 advmod||acomp: 2\\nrelcl||oprd: 1 advmod||prt: 1 advmod||pobj: 1 appos||nummod: 1 relcl||npadvmod:\\n3 mark||advcl: 1 aux||ccomp: 1 amod||nsubjpass: 1 npadvmod||advmod: 1 conj||dep:\\n1 nummod||pobj: 1 amod||npadvmod: 1 intj||pobj: 1 nummod||npadvmod: 1\\nxcomp||xcomp: 1 aux||dep: 1 advcl||relcl: 1\\n⚠ The following labels were found only in the train data: xcomp||amod,\\nadvcl||relcl, prep||nsubjpass, acl||nsubj, nsubjpass||conj, xcomp||oprd,\\nadvmod||conj, advmod||advmod, iobj, advmod||nsubjpass, dobj||conj, ccomp||amod,\\nmeta||acl, xcomp||xcomp, prep||attr, prep||ccomp, advcl||acomp, acl||dobj,\\nadvcl||advcl, pobj||agent, prep||advcl, nsubjpass||xcomp, prep||dep,\\nacomp||xcomp, aux||ccomp, ccomp||dep, conj||dep, relcl||compound,\\nnsubjpass||ccomp, nmod||dobj, advmod||advcl, advmod||acl, dobj||advcl,\\ndative||xcomp, prep||nsubj, ccomp||ccomp, nsubj||ccomp, xcomp||acomp,\\nprep||acomp, dep||advmod, acl||pobj, appos||dobj, npadvmod||acomp, cc||ROOT,\\nrelcl||nsubj, nmod||pobj, acl||nsubjpass, ccomp||advmod, pcomp||prep,\\namod||dobj, advmod||attr, advcl||csubj, appos||attr, dobj||pcomp, prep||ROOT,\\nrelcl||pobj, advmod||pobj, amod||nsubj, ccomp||xcomp, prep||oprd,\\nnpadvmod||advmod, appos||nummod, advcl||pobj, neg||advmod, acl||attr,\\nappos||nsubjpass, csubj||ccomp, amod||nsubjpass, intj||pobj, dep||advcl,\\ncc||neg, xcomp||ccomp, dative||ccomp, nmod||oprd, pobj||dative, prep||dobj,\\ndep||ccomp, relcl||attr, ccomp||nsubj, advcl||xcomp, nmod||dep, advcl||advmod,\\nccomp||conj, pobj||prep, advmod||acomp, advmod||relcl, attr||pcomp,\\nccomp||parataxis, oprd||xcomp, intj||advmod, nmod||nsubjpass, prep||npadvmod,\\nparataxis||acl, prep||pobj, advcl||dobj, amod||pobj, prep||acl, conj||pobj,\\nadvmod||dep, punct||pobj, ccomp||acomp, acomp||advcl, nummod||npadvmod,\\ndobj||dep, npadvmod||xcomp, advcl||conj, relcl||npadvmod, punct||acl,\\nrelcl||dobj, dobj||xcomp, nsubjpass||parataxis, dative||advcl, relcl||nmod,\\nadvcl||ccomp, appos||npadvmod, ccomp||pcomp, prep||amod, mark||advcl,\\nprep||advmod, prep||xcomp, appos||nsubj, attr||ccomp, advmod||prt, dobj||ccomp,\\naux||conj, advcl||nsubj, conj||conj, advmod||ccomp, advcl||nsubjpass,\\nattr||xcomp, nmod||conj, npadvmod||conj, relcl||dative, prep||expl,\\nnsubjpass||pcomp, advmod||xcomp, advmod||dobj, appos||pobj, nsubj||conj,\\nrelcl||nsubjpass, advcl||attr, appos||ccomp, advmod||prep, prep||conj,\\nnmod||attr, punct||conj, neg||conj, dep||xcomp, aux||xcomp, dobj||acl,\\nnummod||pobj, amod||npadvmod, nsubj||pcomp, advcl||acl, appos||nmod,\\nrelcl||oprd, prep||prep, cc||pobj, nmod||nsubj, amod||attr, aux||dep,\\nappos||conj, advmod||nsubj, nsubj||advcl, acl||conj\\nTo train a parser, your data should include at least 20 instances of each label.\\n⚠ Multiple root labels (ROOT, nsubj, aux, npadvmod, prep) found in\\ntraining data. spaCy's parser uses a single root label ROOT so this distinction\\nwill not be available.\\n\\n================================== Summary ==================================\\n✔ 5 checks passed\\n⚠ 8 warnings\\n\"\n          })\n        })\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"API:\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/api/cli#debug-data\",\n            children: _jsx(InlineCode, {\n              children: \"spacy debug-data\"\n            })\n          })]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-incompat\",\n      children: [_jsx(_components.h2, {\n        id: \"incompat\",\n        children: \"Backwards incompatibilities \"\n      }), _jsx(Infobox, {\n        title: \"Important note on models\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"If you’ve been training \", _jsx(_components.strong, {\n            children: \"your own models\"\n          }), \", you’ll need to \", _jsx(_components.strong, {\n            children: \"retrain\"\n          }), \" them\\nwith the new version. Also don’t forget to upgrade all models to the latest\\nversions. Models for v2.0 or v2.1 aren’t compatible with models for v2.2. To\\ncheck if all of your models are up to date, you can run the\\n\", _jsx(_components.a, {\n            href: \"/api/cli#validate\",\n            children: _jsx(InlineCode, {\n              children: \"spacy validate\"\n            })\n          }), \" command.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Install with lookups data\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            lang: \"bash\",\n            children: \"$ pip install spacy[lookups]\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"You can also install\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-lookups-data\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-lookups-data\"\n            })\n          }), \"\\ndirectly.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"The lemmatization tables have been moved to their own package,\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-lookups-data\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-lookups-data\"\n            })\n          }), \", which\\nis not installed by default. If you’re using pretrained models, \", _jsx(_components.strong, {\n            children: \"nothing\\nchanges\"\n          }), \", because the tables are now included in the model packages. If you\\nwant to use the lemmatizer for other languages that don’t yet have pretrained\\nmodels (e.g. Turkish or Croatian) or start off with a blank model that\\ncontains lookup data (e.g. \", _jsx(InlineCode, {\n            children: \"spacy.blank(\\\"en\\\")\"\n          }), \"), you’ll need to \", _jsx(_components.strong, {\n            children: \"explicitly\\ninstall spaCy plus data\"\n          }), \" via \", _jsx(InlineCode, {\n            children: \"pip install spacy[lookups]\"\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Lemmatization tables (rules, exceptions, index and lookups) are now part of\\nthe \", _jsx(InlineCode, {\n            children: \"Vocab\"\n          }), \" and serialized with it. This means that serialized objects (\", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \",\\npipeline components, vocab) will now include additional data, and models\\nwritten to disk will include additional files.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/lemmatizer\",\n            children: _jsx(InlineCode, {\n              children: \"Lemmatizer\"\n            })\n          }), \" class is now initialized with an instance\\nof \", _jsx(_components.a, {\n            href: \"/api/lookups\",\n            children: _jsx(InlineCode, {\n              children: \"Lookups\"\n            })\n          }), \" containing the rules and tables, instead of dicts\\nas separate arguments. This makes it easier to share data tables and modify\\nthem at runtime. This is mostly internals, but if you’ve been implementing a\\ncustom \", _jsx(InlineCode, {\n            children: \"Lemmatizer\"\n          }), \", you’ll need to update your code.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/models/nl\",\n            children: \"Dutch model\"\n          }), \" has been trained on a new NER corpus (custom\\nlabelled UD instead of WikiNER), so their predictions may be very different\\ncompared to the previous version. The results should be significantly better\\nand more generalizable, though.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/cli#download\",\n            children: _jsx(InlineCode, {\n              children: \"spacy download\"\n            })\n          }), \" command does \", _jsx(_components.strong, {\n            children: \"not\"\n          }), \" set the\\n\", _jsx(InlineCode, {\n            children: \"--no-deps\"\n          }), \" pip argument anymore by default, meaning that model package\\ndependencies (if available) will now be also downloaded and installed. If\\nspaCy (which is also a model dependency) is not installed in the current\\nenvironment, e.g. if a user has built from source, \", _jsx(InlineCode, {\n            children: \"--no-deps\"\n          }), \" is added back\\nautomatically to prevent spaCy from being downloaded and installed again from\\npip.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The built-in\\n\", _jsx(_components.a, {\n            href: \"/api/top-level#biluo_tags_from_offsets\",\n            children: _jsx(InlineCode, {\n              children: \"biluo_tags_from_offsets\"\n            })\n          }), \" converter\\nis now stricter and will raise an error if entities are overlapping (instead\\nof silently skipping them). If your data contains invalid entity annotations,\\nmake sure to clean it and resolve conflicts. You can now also use the new\\n\", _jsx(InlineCode, {\n            children: \"debug-data\"\n          }), \" command to find problems in your data.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Pipeline components can now overwrite IOB tags of tokens that are not yet part\\nof an entity. Once a token has an \", _jsx(InlineCode, {\n            children: \"ent_iob\"\n          }), \" value set, it won’t be reset to an\\n“unset” state and will always have at least \", _jsx(InlineCode, {\n            children: \"O\"\n          }), \" assigned. \", _jsx(InlineCode, {\n            children: \"list(doc.ents)\"\n          }), \" now\\nactually keeps the annotations on the token level consistent, instead of\\nresetting \", _jsx(InlineCode, {\n            children: \"O\"\n          }), \" to an empty string.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The default punctuation in the \", _jsx(_components.a, {\n            href: \"/api/sentencizer\",\n            children: _jsx(InlineCode, {\n              children: \"Sentencizer\"\n            })\n          }), \" has been\\nextended and now includes more characters common in various languages. This\\nalso means that the results it produces may change, depending on your text. If\\nyou want the previous behavior with limited characters, set\\n\", _jsx(InlineCode, {\n            children: \"punct_chars=[\\\".\\\", \\\"!\\\", \\\"?\\\"]\"\n          }), \" on initialization.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/phrasematcher\",\n            children: _jsx(InlineCode, {\n              children: \"PhraseMatcher\"\n            })\n          }), \" algorithm was rewritten from scratch\\nand it’s now 10× faster. The rewrite also resolved a few subtle bugs\\nwith very large terminology lists. So if you were matching large lists, you\\nmay see slightly different results – however, the results should now be fully\\ncorrect. See \", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spaCy/pull/4309\",\n            children: \"this PR\"\n          }), \" for more\\ndetails.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"Serbian\"\n          }), \" language class (introduced in v2.1.8) incorrectly used the\\nlanguage code \", _jsx(InlineCode, {\n            children: \"rs\"\n          }), \" instead of \", _jsx(InlineCode, {\n            children: \"sr\"\n          }), \". This has now been fixed, so \", _jsx(InlineCode, {\n            children: \"Serbian\"\n          }), \" is\\nnow available via \", _jsx(InlineCode, {\n            children: \"spacy.lang.sr\"\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"\\\"sources\\\"\"\n          }), \" in the \", _jsx(InlineCode, {\n            children: \"meta.json\"\n          }), \" have changed from a list of strings to a\\nlist of dicts. This is mostly internals, but if your code used\\n\", _jsx(InlineCode, {\n            children: \"nlp.meta[\\\"sources\\\"]\"\n          }), \", you might have to update it.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"migrating\",\n        children: \"Migrating from spaCy 2.1 \"\n      }), _jsx(_components.h4, {\n        children: \"Lemmatization data and lookup tables\"\n      }), _jsxs(_components.p, {\n        children: [\"If you application needs lemmatization for \", _jsx(_components.a, {\n          href: \"/usage/models#languages\",\n          children: \"languages\"\n        }), \"\\nwith only tokenizers, you now need to install that data explicitly via\\n\", _jsx(InlineCode, {\n          children: \"pip install spacy[lookups]\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"pip install spacy-lookups-data\"\n        }), \". No additional\\nsetup is required – the package just needs to be installed in the same\\nenvironment as spaCy.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"3-4\",\n          children: \"nlp = Turkish()\\ndoc = nlp(\\\"Bu bir cümledir.\\\")\\n# 🚨 This now requires the lookups data to be installed explicitly\\nprint([token.lemma_ for token in doc])\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The same applies to blank models that you want to update and train – for\\ninstance, you might use \", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.blank\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.blank\"\n          })\n        }), \" to create a\\nblank English model and then train your own part-of-speech tagger on top. If you\\ndon’t explicitly install the lookups data, that \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object won’t have any\\nlemmatization rules available. spaCy will now show you a warning when you train\\na new part-of-speech tagger and the vocab has no lookups available.\"]\n      }), _jsx(_components.h4, {\n        children: \"Lemmatizer initialization\"\n      }), _jsxs(_components.p, {\n        children: [\"This is mainly internals and should hopefully not affect your code. But if\\nyou’ve been creating custom \", _jsx(_components.a, {\n          href: \"/api/lemmatizer\",\n          children: _jsx(InlineCode, {\n            children: \"Lemmatizers\"\n          })\n        }), \", you’ll need to\\nupdate how they’re initialized and pass in an instance of\\n\", _jsx(_components.a, {\n          href: \"/api/lookups\",\n          children: _jsx(InlineCode, {\n            children: \"Lookups\"\n          })\n        }), \" with the (optional) tables \", _jsx(InlineCode, {\n          children: \"lemma_index\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"lemma_exc\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"lemma_rules\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"lemma_lookup\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"from spacy.lemmatizer import Lemmatizer\\n+ from spacy.lookups import Lookups\\n\\nlemma_index = {\\\"verb\\\": (\\\"cope\\\", \\\"cop\\\")}\\nlemma_exc = {\\\"verb\\\": {\\\"coping\\\": (\\\"cope\\\",)}}\\nlemma_rules = {\\\"verb\\\": [[\\\"ing\\\", \\\"\\\"]]}\\n- lemmatizer = Lemmatizer(lemma_index, lemma_exc, lemma_rules)\\n+ lookups = Lookups()\\n+ lookups.add_table(\\\"lemma_index\\\", lemma_index)\\n+ lookups.add_table(\\\"lemma_exc\\\", lemma_exc)\\n+ lookups.add_table(\\\"lemma_rules\\\", lemma_rules)\\n+ lemmatizer = Lemmatizer(lookups)\\n\"\n        })\n      }), _jsx(_components.h4, {\n        children: \"Converting entity offsets to BILUO tags\"\n      }), _jsxs(_components.p, {\n        children: [\"If you’ve been using the\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#biluo_tags_from_offsets\",\n          children: _jsx(InlineCode, {\n            children: \"biluo_tags_from_offsets\"\n          })\n        }), \" helper to\\nconvert character offsets into token-based BILUO tags, you may now see an error\\nif the offsets contain overlapping tokens and make it impossible to create a\\nvalid BILUO sequence. This is helpful, because it lets you spot potential\\nproblems in your data that can lead to inconsistent results later on. But it\\nalso means that you need to adjust and clean up the offsets before converting\\nthem:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"doc = nlp(\\\"I live in Berlin Kreuzberg\\\")\\n- entities = [(10, 26, \\\"LOC\\\"), (10, 16, \\\"GPE\\\"), (17, 26, \\\"LOC\\\")]\\n+ entities = [(10, 16, \\\"GPE\\\"), (17, 26, \\\"LOC\\\")]\\ntags = get_biluo_tags_from_offsets(doc, entities)\\n\"\n        })\n      }), _jsx(_components.h4, {\n        children: \"Serbian language data\"\n      }), _jsxs(_components.p, {\n        children: [\"If you’ve been working with \", _jsx(InlineCode, {\n          children: \"Serbian\"\n        }), \" (introduced in v2.1.8), you’ll need to\\nchange the language code from \", _jsx(InlineCode, {\n          children: \"rs\"\n        }), \" to the correct \", _jsx(InlineCode, {\n          children: \"sr\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"- from spacy.lang.rs import Serbian\\n+ from spacy.lang.sr import Serbian\\n\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"What's New in v2.2","teaser":"New features, backwards incompatibilities and migration guide","menu":[["New Features","features"],["Backwards Incompatibilities","incompat"],["Migrating from v2.1","migrating"]]},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false,"next":null},"__N_SSG":true}