{"pageProps":{"title":"Embeddings, Transformers and Transfer Learning","teaser":"Using transformer embeddings like BERT in spaCy","menu":[["Embedding Layers","embedding-layers"],["Transformers","transformers"],["Static Vectors","static-vectors"],["Pretraining","pretraining"]],"next":{"slug":"/usage/training","title":"Training Models"},"slug":"/usage/embeddings-transformers","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*TODO: Once rehearsal is tested, mention it here.*/\n/*TODO: <Project id=\"pipelines/transformers\">*/\n/*The easiest way to get started is to clone a transformers-based project*/\n/*template. Swap in your data, edit the settings and hyperparameters and train,*/\n/*evaluate, package and visualize your model.*/\n/*</Project>*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    em: \"em\",\n    h2: \"h2\",\n    img: \"img\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    del: \"del\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {InlineCode, Accordion, Infobox} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsxs(_components.p, {\n        children: [\"spaCy supports a number of \", _jsx(_components.strong, {\n          children: \"transfer and multi-task learning\"\n        }), \" workflows that\\ncan often help improve your pipeline’s efficiency or accuracy. Transfer learning\\nrefers to techniques such as word vector tables and language model pretraining.\\nThese techniques can be used to import knowledge from raw text into your\\npipeline, so that your models are able to generalize better from your annotated\\nexamples.\"]\n      }), _jsxs(_components.p, {\n        children: [\"You can convert \", _jsx(_components.strong, {\n          children: \"word vectors\"\n        }), \" from popular tools like\\n\", _jsx(_components.a, {\n          href: \"https://fasttext.cc\",\n          children: \"FastText\"\n        }), \" and \", _jsx(_components.a, {\n          href: \"https://radimrehurek.com/gensim\",\n          children: \"Gensim\"\n        }), \",\\nor you can load in any pretrained \", _jsx(_components.strong, {\n          children: \"transformer model\"\n        }), \" if you install\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-transformers\",\n          children: _jsx(InlineCode, {\n            children: \"spacy-transformers\"\n          })\n        }), \". You can\\nalso do your own language model pretraining via the\\n\", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" command. You can even \", _jsx(_components.strong, {\n          children: \"share\"\n        }), \" your\\ntransformer or other contextual embedding model across multiple components,\\nwhich can make long pipelines several times more efficient. To use transfer\\nlearning, you’ll need at least a few annotated examples for what you’re trying\\nto predict. Otherwise, you could try using a “one-shot learning” approach using\\n\", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#vectors-similarity\",\n          children: \"vectors and similarity\"\n        }), \".\"]\n      }), _jsxs(Accordion, {\n        title: \"What’s the difference between word vectors and language models?\",\n        id: \"vectors-vs-language-models\",\n        children: [_jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"#transformers\",\n            children: \"Transformers\"\n          }), \" are large and powerful neural networks that give\\nyou better accuracy, but are harder to deploy in production, as they require a\\nGPU to run effectively. \", _jsx(_components.a, {\n            href: \"#word-vectors\",\n            children: \"Word vectors\"\n          }), \" are a slightly older\\ntechnique that can give your models a smaller improvement in accuracy, and can\\nalso provide some additional capabilities.\"]\n        }), _jsxs(_components.p, {\n          children: [\"The key difference between word-vectors and contextual language models such as\\ntransformers is that word vectors model \", _jsx(_components.strong, {\n            children: \"lexical types\"\n          }), \", rather than \", _jsx(_components.em, {\n            children: \"tokens\"\n          }), \".\\nIf you have a list of terms with no context around them, a transformer model\\nlike BERT can’t really help you. BERT is designed to understand language \", _jsx(_components.strong, {\n            children: \"in\\ncontext\"\n          }), \", which isn’t what you have. A word vectors table will be a much better\\nfit for your task. However, if you do have words in context – whole sentences or\\nparagraphs of running text – word vectors will only provide a very rough\\napproximation of what the text is about.\"]\n        }), _jsxs(_components.p, {\n          children: [\"Word vectors are also very computationally efficient, as they map a word to a\\nvector with a single indexing operation. Word vectors are therefore useful as a\\nway to \", _jsx(_components.strong, {\n            children: \"improve the accuracy\"\n          }), \" of neural network models, especially models that\\nare small or have received little or no pretraining. In spaCy, word vector\\ntables are only used as \", _jsx(_components.strong, {\n            children: \"static features\"\n          }), \". spaCy does not backpropagate\\ngradients to the pretrained word vectors table. The static vectors table is\\nusually used in combination with a smaller table of learned task-specific\\nembeddings.\"]\n        })]\n      }), _jsxs(Accordion, {\n        title: \"When should I add word vectors to my model?\",\n        children: [_jsxs(_components.p, {\n          children: [\"Word vectors are not compatible with most \", _jsx(_components.a, {\n            href: \"#transformers\",\n            children: \"transformer models\"\n          }), \",\\nbut if you’re training another type of NLP network, it’s almost always worth\\nadding word vectors to your model. As well as improving your final accuracy,\\nword vectors often make experiments more consistent, as the accuracy you reach\\nwill be less sensitive to how the network is randomly initialized. High variance\\ndue to random chance can slow down your progress significantly, as you need to\\nrun many experiments to filter the signal from the noise.\"]\n        }), _jsx(_components.p, {\n          children: \"Word vector features need to be enabled prior to training, and the same word\\nvectors table will need to be available at runtime as well. You cannot add word\\nvector features once the model has already been trained, and you usually cannot\\nreplace one word vectors table with another without causing a significant loss\\nof performance.\"\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-embedding-layers\",\n      children: [_jsx(_components.h2, {\n        id: \"embedding-layers\",\n        children: \"Shared embedding layers \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy lets you share a single transformer or other token-to-vector (“tok2vec”)\\nembedding layer between multiple components. You can even update the shared\\nlayer, performing \", _jsx(_components.strong, {\n          children: \"multi-task learning\"\n        }), \". Reusing the tok2vec layer between\\ncomponents can make your pipeline run a lot faster and result in much smaller\\nmodels. However, it can make the pipeline less modular and make it more\\ndifficult to swap components or retrain parts of the pipeline. Multi-task\\nlearning can affect your accuracy (either positively or negatively), and may\\nrequire some retuning of your hyper-parameters.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/tok2vec.svg\",\n        alt: \"Pipeline components using a shared embedding component vs. independent embedding layers\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Shared\"\n            }), _jsx(_components.th, {\n              children: \"Independent\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [\"✅ \", _jsx(_components.strong, {\n                children: \"smaller:\"\n              }), \" models only need to include a single copy of the embeddings\"]\n            }), _jsxs(_components.td, {\n              children: [\"❌ \", _jsx(_components.strong, {\n                children: \"larger:\"\n              }), \" models need to include the embeddings for each component\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [\"✅ \", _jsx(_components.strong, {\n                children: \"faster:\"\n              }), \" embed the documents once for your whole pipeline\"]\n            }), _jsxs(_components.td, {\n              children: [\"❌ \", _jsx(_components.strong, {\n                children: \"slower:\"\n              }), \" rerun the embedding for each component\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsxs(_components.td, {\n              children: [\"❌ \", _jsx(_components.strong, {\n                children: \"less composable:\"\n              }), \" all components require the same embedding component in the pipeline\"]\n            }), _jsxs(_components.td, {\n              children: [\"✅ \", _jsx(_components.strong, {\n                children: \"modular:\"\n              }), \" components can be moved and swapped freely\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"You can share a single transformer or other tok2vec model between multiple\\ncomponents by adding a \", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component near the start of your pipeline. Components\\nlater in the pipeline can “connect” to it by including a \", _jsx(_components.strong, {\n          children: \"listener layer\"\n        }), \" like\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2VecListener\",\n          children: \"Tok2VecListener\"\n        }), \" within their model.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/tok2vec-listener.svg\",\n        alt: \"Pipeline components listening to shared embedding component\"\n      }), _jsxs(_components.p, {\n        children: [\"At the beginning of training, the \", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component will grab\\na reference to the relevant listener layers in the rest of your pipeline. When\\nit processes a batch of documents, it will pass forward its predictions to the\\nlisteners, allowing the listeners to \", _jsx(_components.strong, {\n          children: \"reuse the predictions\"\n        }), \" when they are\\neventually called. A similar mechanism is used to pass gradients from the\\nlisteners back to the model. The \", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component and\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TransformerListener\",\n          children: \"TransformerListener\"\n        }), \" layer do the same\\nthing for transformer models, but the \", _jsx(InlineCode, {\n          children: \"Transformer\"\n        }), \" component will also save the\\ntransformer outputs to the\\n\", _jsx(_components.a, {\n          href: \"/api/transformer#custom_attributes\",\n          children: _jsx(InlineCode, {\n            children: \"Doc._.trf_data\"\n          })\n        }), \" extension attribute,\\ngiving you access to them after the pipeline has finished running.\"]\n      }), _jsx(_components.h3, {\n        id: \"embedding-layers-config\",\n        children: \"Example: Shared vs. independent config \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config system\"\n        }), \" lets you express model configuration\\nfor both shared and independent embedding layers. The shared setup uses a single\\n\", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component with the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2Vec\",\n          children: \"Tok2Vec\"\n        }), \" architecture. All other components, like\\nthe entity recognizer, use a\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2VecListener\",\n          children: \"Tok2VecListener\"\n        }), \" layer as their model’s\\n\", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" argument, which connects to the \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" component model.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"Shared\",\n          highlight: \"1-2,4-5,19-20\",\n          children: \"[components.tok2vec]\\nfactory = \\\"tok2vec\\\"\\n\\n[components.tok2vec.model]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[components.tok2vec.model.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\n\\n[components.tok2vec.model.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\n\\n[components.ner]\\nfactory = \\\"ner\\\"\\n\\n[components.ner.model]\\n@architectures = \\\"spacy.TransitionBasedParser.v1\\\"\\n\\n[components.ner.model.tok2vec]\\n@architectures = \\\"spacy.Tok2VecListener.v1\\\"\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In the independent setup, the entity recognizer component defines its own\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2Vec\",\n          children: \"Tok2Vec\"\n        }), \" instance. Other components will do the\\nsame. This makes them fully independent and doesn’t require an upstream\\n\", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component to be present in the pipeline.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"Independent\",\n          highlight: \"7-8\",\n          children: \"[components.ner]\\nfactory = \\\"ner\\\"\\n\\n[components.ner.model]\\n@architectures = \\\"spacy.TransitionBasedParser.v1\\\"\\n\\n[components.ner.model.tok2vec]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[components.ner.model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\n\\n[components.ner.model.tok2vec.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-transformers\",\n      children: [_jsx(_components.h2, {\n        id: \"transformers\",\n        children: \"Using transformer models \"\n      }), _jsxs(_components.p, {\n        children: [\"Transformers are a family of neural network architectures that compute \", _jsx(_components.strong, {\n          children: \"dense,\\ncontext-sensitive representations\"\n        }), \" for the tokens in your documents. Downstream\\nmodels in your pipeline can then use these representations as input features to\\n\", _jsx(_components.strong, {\n          children: \"improve their predictions\"\n        }), \". You can connect multiple components to a single\\ntransformer model, with any or all of those components giving feedback to the\\ntransformer to fine-tune it to your tasks. spaCy’s transformer support\\ninteroperates with \", _jsx(_components.a, {\n          href: \"https://pytorch.org\",\n          children: \"PyTorch\"\n        }), \" and the\\n\", _jsxs(_components.a, {\n          href: \"https://huggingface.co/transformers/\",\n          children: [\"HuggingFace \", _jsx(InlineCode, {\n            children: \"transformers\"\n          })]\n        }), \" library,\\ngiving you access to thousands of pretrained models for your pipelines. There\\nare many \", _jsx(_components.a, {\n          href: \"http://jalammar.github.io/illustrated-transformer/\",\n          children: \"great guides\"\n        }), \" to\\ntransformer models, but for practical purposes, you can simply think of them as\\ndrop-in replacements that let you achieve \", _jsx(_components.strong, {\n          children: \"higher accuracy\"\n        }), \" in exchange for\\n\", _jsx(_components.strong, {\n          children: \"higher training and runtime costs\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"transformers-installation\",\n        children: \"Setup and installation \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"System requirements\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"We recommend an NVIDIA \", _jsx(_components.strong, {\n            children: \"GPU\"\n          }), \" with at least \", _jsx(_components.strong, {\n            children: \"10GB of memory\"\n          }), \" in order to\\nwork with transformer models. Make sure your GPU drivers are up to date and\\nyou have \", _jsx(_components.strong, {\n            children: \"CUDA v9+\"\n          }), \" installed.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The exact requirements will depend on the transformer model. Training a\\ntransformer-based model without a GPU will be too slow for most practical\\npurposes.\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"Provisioning a new machine will require about \", _jsx(_components.strong, {\n            children: \"5GB\"\n          }), \" of data to be\\ndownloaded: 3GB CUDA runtime, 800MB PyTorch, 400MB CuPy, 500MB weights, 200MB\\nspaCy and dependencies.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Once you have CUDA installed, we recommend installing PyTorch following the\\n\", _jsx(_components.a, {\n          href: \"https://pytorch.org/get-started/locally/\",\n          children: \"PyTorch installation guidelines\"\n        }), \" for\\nyour package manager and CUDA version. If you skip this step, pip will install\\nPyTorch as a dependency below, but it may not find the best version for your\\nsetup.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          title: \"Example: Install PyTorch 1.11.0 for CUDA 11.3 with pip\",\n          children: \"# See: https://pytorch.org/get-started/locally/\\n$ pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0+cu113 -f https://download.pytorch.org/whl/cu113/torch_stable.html\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Next, install spaCy with the extras for your CUDA version and transformers. The\\nCUDA extra (e.g., \", _jsx(InlineCode, {\n          children: \"cuda102\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"cuda113\"\n        }), \") installs the correct version of\\n\", _jsx(_components.a, {\n          href: \"https://docs.cupy.dev/en/stable/install.html#installing-cupy\",\n          children: _jsx(InlineCode, {\n            children: \"cupy\"\n          })\n        }), \", which is\\njust like \", _jsx(InlineCode, {\n          children: \"numpy\"\n        }), \", but for GPU. You may also need to set the \", _jsx(InlineCode, {\n          children: \"CUDA_PATH\"\n        }), \"\\nenvironment variable if your CUDA runtime is installed in a non-standard\\nlocation. Putting it all together, if you had installed CUDA 11.3 in\\n\", _jsx(InlineCode, {\n          children: \"/opt/nvidia/cuda\"\n        }), \", you would run:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          title: \"Installation with CUDA\",\n          children: \"$ export CUDA_PATH=\\\"/opt/nvidia/cuda\\\"\\n$ pip install -U spacy[cuda113,transformers]\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"For \", _jsx(_components.a, {\n          href: \"https://huggingface.co/transformers/\",\n          children: _jsx(InlineCode, {\n            children: \"transformers\"\n          })\n        }), \" v4.0.0+ and models\\nthat require \", _jsx(_components.a, {\n          href: \"https://github.com/google/sentencepiece\",\n          children: _jsx(InlineCode, {\n            children: \"SentencePiece\"\n          })\n        }), \" (e.g.,\\nALBERT, CamemBERT, XLNet, Marian, and T5), install the additional dependencies\\nwith:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          title: \"Install sentencepiece\",\n          children: \"$ pip install transformers[sentencepiece]\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"transformers-runtime\",\n        children: \"Runtime usage \"\n      }), _jsxs(_components.p, {\n        children: [\"Transformer models can be used as \", _jsx(_components.strong, {\n          children: \"drop-in replacements\"\n        }), \" for other types of\\nneural networks, so your spaCy pipeline can include them in a way that’s\\ncompletely invisible to the user. Users will download, load and use the model in\\nthe standard way, like any other spaCy pipeline. Instead of using the\\ntransformers as subnetworks directly, you can also use them via the\\n\", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" pipeline component.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/pipeline_transformer.svg\",\n        alt: \"The processing pipeline with the transformer component\"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Transformer\"\n        }), \" component sets the\\n\", _jsx(_components.a, {\n          href: \"/api/transformer#custom_attributes\",\n          children: _jsx(InlineCode, {\n            children: \"Doc._.trf_data\"\n          })\n        }), \" extension attribute,\\nwhich lets you access the transformers outputs at runtime. The trained\\ntransformer-based \", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"pipelines\"\n        }), \" provided by spaCy end on \", _jsx(InlineCode, {\n          children: \"_trf\"\n        }), \", e.g.\\n\", _jsx(_components.a, {\n          href: \"/models/en#en_core_web_trf\",\n          children: _jsx(InlineCode, {\n            children: \"en_core_web_trf\"\n          })\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy download en_core_web_trf\\n\"\n        })\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Example\",\n          children: \"import spacy\\nfrom thinc.api import set_gpu_allocator, require_gpu\\n\\n# Use the GPU, with memory allocations directed via PyTorch.\\n# This prevents out-of-memory errors that would otherwise occur from competing\\n# memory pools.\\nset_gpu_allocator(\\\"pytorch\\\")\\nrequire_gpu(0)\\n\\nnlp = spacy.load(\\\"en_core_web_trf\\\")\\nfor doc in nlp.pipe([\\\"some text\\\", \\\"some other text\\\"]):\\n    tokvecs = doc._.trf_data.tensors[-1]\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"You can also customize how the \", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component sets\\nannotations onto the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" by specifying a custom\\n\", _jsx(InlineCode, {\n          children: \"set_extra_annotations\"\n        }), \" function. This callback will be called with the raw\\ninput and output data for the whole batch, along with the batch of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \"\\nobjects, allowing you to implement whatever you need. The annotation setter is\\ncalled with a batch of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects and a\\n\", _jsx(_components.a, {\n          href: \"/api/transformer#fulltransformerbatch\",\n          children: _jsx(InlineCode, {\n            children: \"FullTransformerBatch\"\n          })\n        }), \" containing the\\ntransformers data for the batch.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"def custom_annotation_setter(docs, trf_data):\\n    doc_data = list(trf_data.doc_data)\\n    for doc, data in zip(docs, doc_data):\\n        doc._.custom_attr = data\\n\\nnlp = spacy.load(\\\"en_core_web_trf\\\")\\nnlp.get_pipe(\\\"transformer\\\").set_extra_annotations = custom_annotation_setter\\ndoc = nlp(\\\"This is a text\\\")\\nassert isinstance(doc._.custom_attr, TransformerData)\\nprint(doc._.custom_attr.tensors)\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"transformers-training\",\n        children: \"Training usage \"\n      }), _jsxs(_components.p, {\n        children: [\"The recommended workflow for training is to use spaCy’s\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config system\"\n        }), \", usually via the\\n\", _jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \" command. The training config defines all\\ncomponent settings and hyperparameters in one place and lets you describe a tree\\nof objects by referring to creation functions, including functions you register\\nyourself. For details on how to get started with training your own model, check\\nout the \", _jsx(_components.a, {\n          href: \"/usage/training#quickstart\",\n          children: \"training quickstart\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"[components]\"\n        }), \" section in the \", _jsx(_components.a, {\n          href: \"/api/data-formats#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \"\\ndescribes the pipeline components and the settings used to construct them,\\nincluding their model implementation. Here’s a config snippet for the\\n\", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component, along with matching Python code. In\\nthis case, the \", _jsx(InlineCode, {\n          children: \"[components.transformer]\"\n        }), \" block describes the \", _jsx(InlineCode, {\n          children: \"transformer\"\n        }), \"\\ncomponent:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Python equivalent\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy_transformers import Transformer, TransformerModel\\nfrom spacy_transformers.annotation_setters import null_annotation_setter\\nfrom spacy_transformers.span_getters import get_doc_spans\\n\\ntrf = Transformer(\\n    nlp.vocab,\\n    TransformerModel(\\n        \\\"bert-base-cased\\\",\\n        get_spans=get_doc_spans,\\n        tokenizer_config={\\\"use_fast\\\": True},\\n    ),\\n    set_extra_annotations=null_annotation_setter,\\n    max_batch_items=4096,\\n)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg\",\n          excerpt: \"true\",\n          children: \"[components.transformer]\\nfactory = \\\"transformer\\\"\\nmax_batch_items = 4096\\n\\n[components.transformer.model]\\n@architectures = \\\"spacy-transformers.TransformerModel.v3\\\"\\nname = \\\"bert-base-cased\\\"\\ntokenizer_config = {\\\"use_fast\\\": true}\\n\\n[components.transformer.model.get_spans]\\n@span_getters = \\\"spacy-transformers.doc_spans.v1\\\"\\n\\n[components.transformer.set_extra_annotations]\\n@annotation_setters = \\\"spacy-transformers.null_annotation_setter.v1\\\"\\n\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"[components.transformer.model]\"\n        }), \" block describes the \", _jsx(InlineCode, {\n          children: \"model\"\n        }), \" argument passed\\nto the transformer component. It’s a Thinc\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" object that will be passed into the\\ncomponent. Here, it references the function\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TransformerModel\",\n          children: \"spacy-transformers.TransformerModel.v3\"\n        }), \"\\nregistered in the \", _jsxs(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: [_jsx(InlineCode, {\n            children: \"architectures\"\n          }), \" registry\"]\n        }), \". If a key\\nin a block starts with \", _jsx(InlineCode, {\n          children: \"@\"\n        }), \", it’s \", _jsx(_components.strong, {\n          children: \"resolved to a function\"\n        }), \" and all other\\nsettings are passed to the function as arguments. In this case, \", _jsx(InlineCode, {\n          children: \"name\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"tokenizer_config\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"get_spans\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [_jsx(InlineCode, {\n          children: \"get_spans\"\n        }), \" is a function that takes a batch of \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects and returns lists\\nof potentially overlapping \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" objects to process by the transformer. Several\\n\", _jsx(_components.a, {\n          href: \"/api/transformer#span_getters\",\n          children: \"built-in functions\"\n        }), \" are available – for example,\\nto process the whole document or individual sentences. When the config is\\nresolved, the function is created and passed into the model as an argument.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"name\"\n        }), \" value is the name of any \", _jsx(_components.a, {\n          href: \"huggingface-models\",\n          children: \"HuggingFace model\"\n        }), \",\\nwhich will be downloaded automatically the first time it’s used. You can also\\nuse a local file path. For full details, see the\\n\", _jsxs(_components.a, {\n          href: \"/api/architectures#TransformerModel\",\n          children: [_jsx(InlineCode, {\n            children: \"TransformerModel\"\n          }), \" docs\"]\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"A wide variety of PyTorch models are supported, but some might not work. If a\\nmodel doesn’t seem to work feel free to open an\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy/issues\",\n          children: \"issue\"\n        }), \". Additionally note that\\nTransformers loaded in spaCy can only be used for tensors, and pretrained\\ntask-specific heads or text generation features cannot be used as part of the\\n\", _jsx(InlineCode, {\n          children: \"transformer\"\n        }), \" pipeline component.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Remember that the \", _jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \" used for training should contain \", _jsx(_components.strong, {\n            children: \"no missing\\nvalues\"\n          }), \" and requires all settings to be defined. You don’t want any hidden\\ndefaults creeping in and changing your results! spaCy will tell you if settings\\nare missing, and you can run\\n\", _jsx(_components.a, {\n            href: \"/api/cli#init-fill-config\",\n            children: _jsx(InlineCode, {\n              children: \"spacy init fill-config\"\n            })\n          }), \" to automatically fill in\\nall defaults.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"transformers-training-custom-settings\",\n        children: \"Customizing the settings \"\n      }), _jsxs(_components.p, {\n        children: [\"To change any of the settings, you can edit the \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" and re-run the\\ntraining. To change any of the functions, like the span getter, you can replace\\nthe name of the referenced function – e.g.\\n\", _jsx(InlineCode, {\n          children: \"@span_getters = \\\"spacy-transformers.sent_spans.v1\\\"\"\n        }), \" to process sentences. You\\ncan also register your own functions using the\\n\", _jsxs(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: [_jsx(InlineCode, {\n            children: \"span_getters\"\n          }), \" registry\"]\n        }), \". For instance, the following\\ncustom function returns \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \" objects following sentence\\nboundaries, unless a sentence succeeds a certain amount of tokens, in which case\\nsubsentences of at most \", _jsx(InlineCode, {\n          children: \"max_length\"\n        }), \" tokens are returned.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.transformer.model.get_spans]\\n@span_getters = \\\"custom_sent_spans\\\"\\nmax_length = 25\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"code.py\",\n          children: \"import spacy_transformers\\n\\n@spacy_transformers.registry.span_getters(\\\"custom_sent_spans\\\")\\ndef configure_custom_sent_spans(max_length: int):\\n    def get_custom_sent_spans(docs):\\n        spans = []\\n        for doc in docs:\\n            spans.append([])\\n            for sent in doc.sents:\\n                start = 0\\n                end = max_length\\n                while end <= len(sent):\\n                    spans[-1].append(sent[start:end])\\n                    start += max_length\\n                    end += max_length\\n                if start < len(sent):\\n                    spans[-1].append(sent[start:len(sent)])\\n        return spans\\n\\n    return get_custom_sent_spans\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"To resolve the config during training, spaCy needs to know about your custom\\nfunction. You can make it available via the \", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \" argument that can point to\\na Python file. For more details on training with custom code, see the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#custom-functions\",\n          children: \"training documentation\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"python -m spacy train ./config.cfg --code ./code.py\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"training-custom-model\",\n        children: \"Customizing the model implementations \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \" component expects a Thinc\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" object to be passed in as its \", _jsx(InlineCode, {\n          children: \"model\"\n        }), \"\\nargument. You’re not limited to the implementation provided by\\n\", _jsx(InlineCode, {\n          children: \"spacy-transformers\"\n        }), \" – the only requirement is that your registered function\\nmust return an object of type \", _jsx(_components.del, {\n          children: \"Model[List[Doc], FullTransformerBatch]\"\n        }), \": that\\nis, a Thinc model that takes a list of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects, and returns a\\n\", _jsx(_components.a, {\n          href: \"/api/transformer#fulltransformerbatch\",\n          children: _jsx(InlineCode, {\n            children: \"FullTransformerBatch\"\n          })\n        }), \" object with the\\ntransformer data.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The same idea applies to task models that power the \", _jsx(_components.strong, {\n          children: \"downstream components\"\n        }), \".\\nMost of spaCy’s built-in model creation functions support a \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" argument,\\nwhich should be a Thinc layer of type \", _jsx(_components.del, {\n          children: \"Model[List[Doc], List[Floats2d]]\"\n        }), \". This\\nis where we’ll plug in our transformer model, using the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TransformerListener\",\n          children: \"TransformerListener\"\n        }), \" layer, which\\nsneakily delegates to the \", _jsx(InlineCode, {\n          children: \"Transformer\"\n        }), \" pipeline component.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          highlight: \"12\",\n          children: \"[components.ner]\\nfactory = \\\"ner\\\"\\n\\n[nlp.pipeline.ner.model]\\n@architectures = \\\"spacy.TransitionBasedParser.v1\\\"\\nstate_type = \\\"ner\\\"\\nextra_state_tokens = false\\nhidden_width = 128\\nmaxout_pieces = 3\\nuse_upper = false\\n\\n[nlp.pipeline.ner.model.tok2vec]\\n@architectures = \\\"spacy-transformers.TransformerListener.v1\\\"\\ngrad_factor = 1.0\\n\\n[nlp.pipeline.ner.model.tok2vec.pooling]\\n@layers = \\\"reduce_mean.v1\\\"\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/architectures#TransformerListener\",\n          children: \"TransformerListener\"\n        }), \" layer expects\\na \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#reduction-ops\",\n          children: \"pooling layer\"\n        }), \" as the\\nargument \", _jsx(InlineCode, {\n          children: \"pooling\"\n        }), \", which needs to be of type \", _jsx(_components.del, {\n          children: \"Model[Ragged, Floats2d]\"\n        }), \". This\\nlayer determines how the vector for each spaCy token will be computed from the\\nzero or more source rows the token is aligned against. Here we use the\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#reduce_mean\",\n          children: _jsx(InlineCode, {\n            children: \"reduce_mean\"\n          })\n        }), \" layer, which\\naverages the wordpiece rows. We could instead use\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#reduce_max\",\n          children: _jsx(InlineCode, {\n            children: \"reduce_max\"\n          })\n        }), \", or a custom\\nfunction you write yourself.\"]\n      }), _jsxs(_components.p, {\n        children: [\"You can have multiple components all listening to the same transformer model,\\nand all passing gradients back to it. By default, all of the gradients will be\\n\", _jsx(_components.strong, {\n          children: \"equally weighted\"\n        }), \". You can control this with the \", _jsx(InlineCode, {\n          children: \"grad_factor\"\n        }), \" setting, which\\nlets you reweight the gradients from the different listeners. For instance,\\nsetting \", _jsx(InlineCode, {\n          children: \"grad_factor = 0\"\n        }), \" would disable gradients from one of the listeners,\\nwhile \", _jsx(InlineCode, {\n          children: \"grad_factor = 2.0\"\n        }), \" would multiply them by 2. This is similar to having a\\ncustom learning rate for each component. Instead of a constant, you can also\\nprovide a schedule, allowing you to freeze the shared parameters at the start of\\ntraining.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-static-vectors\",\n      children: [_jsx(_components.h2, {\n        id: \"static-vectors\",\n        children: \"Static vectors \"\n      }), _jsxs(_components.p, {\n        children: [\"If your pipeline includes a \", _jsx(_components.strong, {\n          children: \"word vectors table\"\n        }), \", you’ll be able to use the\\n\", _jsx(InlineCode, {\n          children: \".similarity()\"\n        }), \" method on the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \", \", _jsx(_components.a, {\n          href: \"/api/span\",\n          children: _jsx(InlineCode, {\n            children: \"Span\"\n          })\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/lexeme\",\n          children: _jsx(InlineCode, {\n            children: \"Lexeme\"\n          })\n        }), \" objects. You’ll also be able\\nto access the vectors using the \", _jsx(InlineCode, {\n          children: \".vector\"\n        }), \" attribute, or you can look up one or\\nmore vectors directly using the \", _jsx(_components.a, {\n          href: \"/api/vocab\",\n          children: _jsx(InlineCode, {\n            children: \"Vocab\"\n          })\n        }), \" object. Pipelines with\\nword vectors can also \", _jsx(_components.strong, {\n          children: \"use the vectors as features\"\n        }), \" for the statistical\\nmodels, which can \", _jsx(_components.strong, {\n          children: \"improve the accuracy\"\n        }), \" of your components.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Word vectors in spaCy are “static” in the sense that they are not learned\\nparameters of the statistical models, and spaCy itself does not feature any\\nalgorithms for learning word vector tables. You can train a word vectors table\\nusing tools such as \", _jsx(_components.a, {\n          href: \"https://github.com/explosion/floret\",\n          children: \"floret\"\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"https://radimrehurek.com/gensim/\",\n          children: \"Gensim\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://fasttext.cc/\",\n          children: \"FastText\"\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"https://nlp.stanford.edu/projects/glove/\",\n          children: \"GloVe\"\n        }), \", or download existing\\npretrained vectors. The \", _jsx(_components.a, {\n          href: \"/api/cli#init-vectors\",\n          children: _jsx(InlineCode, {\n            children: \"init vectors\"\n          })\n        }), \" command lets you\\nconvert vectors for use with spaCy and will give you a directory you can load or\\nrefer to in your \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"training configs\"\n        }), \".\"]\n      }), _jsx(Infobox, {\n        title: \"Word vectors and similarity\",\n        emoji: \"📖\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on loading word vectors into spaCy, using them for similarity\\nand improving word vector coverage by truncating and pruning the vectors, see\\nthe usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/linguistic-features#vectors-similarity\",\n            children: \"word vectors and similarity\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"word-vectors-models\",\n        children: \"Using word vectors in your models \"\n      }), _jsxs(_components.p, {\n        children: [\"Many neural network models are able to use word vector tables as additional\\nfeatures, which sometimes results in significant improvements in accuracy.\\nspaCy’s built-in embedding layer,\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#MultiHashEmbed\",\n          children: \"MultiHashEmbed\"\n        }), \", can be configured to use\\nword vector tables using the \", _jsx(InlineCode, {\n          children: \"include_static_vectors\"\n        }), \" flag.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          children: \"[tagger.model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\nwidth = 128\\nattrs = [\\\"LOWER\\\",\\\"PREFIX\\\",\\\"SUFFIX\\\",\\\"SHAPE\\\"]\\nrows = [5000,2500,2500,2500]\\ninclude_static_vectors = true\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"How it works\",\n        emoji: \"💡\",\n        children: _jsxs(_components.p, {\n          children: [\"The configuration system will look up the string \", _jsx(InlineCode, {\n            children: \"\\\"spacy.MultiHashEmbed.v2\\\"\"\n          }), \" in\\nthe \", _jsx(InlineCode, {\n            children: \"architectures\"\n          }), \" \", _jsx(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: \"registry\"\n          }), \", and call the returned\\nobject with the rest of the arguments from the block. This will result in a call\\nto the\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy/tree/develop/spacy/ml/models/tok2vec.py\",\n            children: _jsx(InlineCode, {\n              children: \"MultiHashEmbed\"\n            })\n          }), \"\\nfunction, which will return a \", _jsx(_components.a, {\n            href: \"https://thinc.ai\",\n            children: \"Thinc\"\n          }), \" model object with the\\ntype signature \", _jsx(_components.del, {\n            children: \"Model[List[Doc], List[Floats2d]]\"\n          }), \". Because the embedding layer\\ntakes a list of \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects as input, it does not need to store a copy of the\\nvectors table. The vectors will be retrieved from the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects that are\\npassed in, via the \", _jsx(InlineCode, {\n            children: \"doc.vocab.vectors\"\n          }), \" attribute. This part of the process is\\nhandled by the \", _jsx(_components.a, {\n            href: \"/api/architectures#StaticVectors\",\n            children: \"StaticVectors\"\n          }), \" layer.\"]\n        })\n      }), _jsx(_components.h4, {\n        id: \"custom-embedding-layer\",\n        children: \"Creating a custom embedding layer \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/architectures#StaticVectors\",\n          children: \"MultiHashEmbed\"\n        }), \" layer is spaCy’s\\nrecommended strategy for constructing initial word representations for your\\nneural network models, but you can also implement your own. You can register any\\nfunction to a string name, and then reference that function within your config\\n(see the \", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"training docs\"\n        }), \" for more details). To try this out,\\nyou can save the following little example to a new Python file:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from spacy.ml.staticvectors import StaticVectors\\nfrom spacy.util import registry\\n\\nprint(\\\"I was imported!\\\")\\n\\n@registry.architectures(\\\"my_example.MyEmbedding.v1\\\")\\ndef MyEmbedding(output_width: int) -> Model[List[Doc], List[Floats2d]]:\\n    print(\\\"I was called!\\\")\\n    return StaticVectors(nO=output_width)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If you pass the path to your file to the \", _jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \" command\\nusing the \", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \" argument, your file will be imported, which means the\\ndecorator registering the function will be run. Your function is now on equal\\nfooting with any of spaCy’s built-ins, so you can drop it in instead of any\\nother model with the same input and output signature. For instance, you could\\nuse it in the tagger model as follows:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          children: \"[tagger.model.tok2vec.embed]\\n@architectures = \\\"my_example.MyEmbedding.v1\\\"\\noutput_width = 128\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"Now that you have a custom function wired into the network, you can start\\nimplementing the logic you’re interested in. For example, let’s say you want to\\ntry a relatively simple embedding strategy that makes use of static word\\nvectors, but combines them via summation with a smaller table of learned\\nembeddings.\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from thinc.api import add, chain, remap_ids, Embed\\nfrom spacy.ml.staticvectors import StaticVectors\\nfrom spacy.ml.featureextractor import FeatureExtractor\\nfrom spacy.util import registry\\n\\n@registry.architectures(\\\"my_example.MyEmbedding.v1\\\")\\ndef MyCustomVectors(\\n    output_width: int,\\n    vector_width: int,\\n    embed_rows: int,\\n    key2row: Dict[int, int]\\n) -> Model[List[Doc], List[Floats2d]]:\\n    return add(\\n        StaticVectors(nO=output_width),\\n        chain(\\n           FeatureExtractor([\\\"ORTH\\\"]),\\n           remap_ids(key2row),\\n           Embed(nO=output_width, nV=embed_rows)\\n        )\\n    )\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pretraining\",\n      children: [_jsx(_components.h2, {\n        id: \"pretraining\",\n        children: \"Pretraining \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" command lets you initialize your\\nmodels with \", _jsx(_components.strong, {\n          children: \"information from raw text\"\n        }), \". Without pretraining, the models for\\nyour components will usually be initialized randomly. The idea behind\\npretraining is simple: random probably isn’t optimal, so if we have some text to\\nlearn from, we can probably find a way to get the model off to a better start.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Pretraining uses the same \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \" file as the\\nregular training, which helps keep the settings and hyperparameters consistent.\\nThe additional \", _jsx(InlineCode, {\n          children: \"[pretraining]\"\n        }), \" section has several configuration subsections\\nthat are familiar from the training block: the \", _jsx(InlineCode, {\n          children: \"[pretraining.batcher]\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"[pretraining.optimizer]\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"[pretraining.corpus]\"\n        }), \" all work the same way and\\nexpect the same types of objects, although for pretraining your corpus does not\\nneed to have any annotations, so you will often use a different reader, such as\\nthe \", _jsx(_components.a, {\n          href: \"/api/top-level#jsonlcorpus\",\n          children: _jsx(InlineCode, {\n            children: \"JsonlCorpus\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Raw text format\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The raw text can be provided in spaCy’s\\n\", _jsxs(_components.a, {\n            href: \"/api/data-formats#training\",\n            children: [\"binary \", _jsx(InlineCode, {\n              children: \".spacy\"\n            }), \" format\"]\n          }), \" consisting of serialized\\n\", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects or as a JSONL (newline-delimited JSON) with a key \", _jsx(InlineCode, {\n            children: \"\\\"text\\\"\"\n          }), \" per\\nentry. This allows the data to be read in line by line, while also allowing\\nyou to include newlines in the texts.\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            children: \"{\\\"text\\\": \\\"Can I ask where you work now and what you do, and if you enjoy it?\\\"}\\n{\\\"text\\\": \\\"They may just pull out of the Seattle market completely, at least until they have autonomous vehicles.\\\"}\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"You can also use your own custom corpus loader instead.\"\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"You can add a \", _jsx(InlineCode, {\n          children: \"[pretraining]\"\n        }), \" block to your config by setting the\\n\", _jsx(InlineCode, {\n          children: \"--pretraining\"\n        }), \" flag on \", _jsx(_components.a, {\n          href: \"/api/cli#init-config\",\n          children: _jsx(InlineCode, {\n            children: \"init config\"\n          })\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"/api/cli#init-fill-config\",\n          children: _jsx(InlineCode, {\n            children: \"init fill-config\"\n          })\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy init fill-config config.cfg config_pretrain.cfg --pretraining\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"You can then run \", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" with the updated config\\nand pass in optional config overrides, like the path to the raw text file:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          lang: \"bash\",\n          children: \"$ python -m spacy pretrain config_pretrain.cfg ./output --paths.raw_text text.jsonl\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The following defaults are used for the \", _jsx(InlineCode, {\n          children: \"[pretraining]\"\n        }), \" block and merged into\\nyour existing config when you run \", _jsx(_components.a, {\n          href: \"/api/cli#init-config\",\n          children: _jsx(InlineCode, {\n            children: \"init config\"\n          })\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"/api/cli#init-fill-config\",\n          children: _jsx(InlineCode, {\n            children: \"init fill-config\"\n          })\n        }), \" with \", _jsx(InlineCode, {\n          children: \"--pretraining\"\n        }), \". If needed,\\nyou can \", _jsx(_components.a, {\n          href: \"#pretraining-configure\",\n          children: \"configure\"\n        }), \" the settings and hyperparameters or\\nchange the \", _jsx(_components.a, {\n          href: \"#pretraining-objectives\",\n          children: \"objective\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          github: \"https://github.com/explosion/spaCy/tree/master/spacy/default_config_pretraining.cfg\",\n          children: \"https://github.com/explosion/spaCy/tree/master/spacy/default_config_pretraining.cfg\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"pretraining-details\",\n        children: \"How pretraining works \"\n      }), _jsxs(_components.p, {\n        children: [\"The impact of \", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" varies, but it will usually\\nbe worth trying if you’re \", _jsx(_components.strong, {\n          children: \"not using a transformer\"\n        }), \" model and you have\\n\", _jsx(_components.strong, {\n          children: \"relatively little training data\"\n        }), \" (for instance, fewer than 5,000 sentences).\\nA good rule of thumb is that pretraining will generally give you a similar\\naccuracy improvement to using word vectors in your model. If word vectors have\\ngiven you a 10% error reduction, pretraining with spaCy might give you another\\n10%, for a 20% error reduction in total.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" command will take a \", _jsx(_components.strong, {\n          children: \"specific\\nsubnetwork\"\n        }), \" within one of your components, and add additional layers to build a\\nnetwork for a temporary task that forces the model to learn something about\\nsentence structure and word cooccurrence statistics.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Pretraining produces a \", _jsx(_components.strong, {\n          children: \"binary weights file\"\n        }), \" that can be loaded back in at the\\nstart of training, using the configuration option \", _jsx(InlineCode, {\n          children: \"initialize.init_tok2vec\"\n        }), \". The\\nweights file specifies an initial set of weights. Training then proceeds as\\nnormal.\"]\n      }), _jsxs(_components.p, {\n        children: [\"You can only pretrain one subnetwork from your pipeline at a time, and the\\nsubnetwork must be typed \", _jsx(_components.del, {\n          children: \"Model[List[Doc], List[Floats2d]]\"\n        }), \" (i.e. it has to be\\na “tok2vec” layer). The most common workflow is to use the\\n\", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component to create a shared token-to-vector layer for\\nseveral components of your pipeline, and apply pretraining to its whole model.\"]\n      }), _jsx(_components.h4, {\n        id: \"pretraining-configure\",\n        children: \"Configuring the pretraining \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/cli#pretrain\",\n          children: _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          })\n        }), \" command is configured using the\\n\", _jsx(InlineCode, {\n          children: \"[pretraining]\"\n        }), \" section of your \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config file\"\n        }), \". The\\n\", _jsx(InlineCode, {\n          children: \"component\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"layer\"\n        }), \" settings tell spaCy how to \", _jsx(_components.strong, {\n          children: \"find the subnetwork\"\n        }), \" to\\npretrain. The \", _jsx(InlineCode, {\n          children: \"layer\"\n        }), \" setting should be either the empty string (to use the\\nwhole model), or a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#model-state\",\n          children: \"node reference\"\n        }), \". Most of\\nspaCy’s built-in model architectures have a reference named \", _jsx(InlineCode, {\n          children: \"\\\"tok2vec\\\"\"\n        }), \" that\\nwill refer to the right layer.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg\",\n          children: \"# 1. Use the whole model of the \\\"tok2vec\\\" component\\n[pretraining]\\ncomponent = \\\"tok2vec\\\"\\nlayer = \\\"\\\"\\n\\n# 2. Pretrain the \\\"tok2vec\\\" node of the \\\"textcat\\\" component\\n[pretraining]\\ncomponent = \\\"textcat\\\"\\nlayer = \\\"tok2vec\\\"\\n\"\n        })\n      }), _jsx(_components.h4, {\n        id: \"pretraining-training\",\n        children: \"Connecting pretraining to training \"\n      }), _jsxs(_components.p, {\n        children: [\"To benefit from pretraining, your training step needs to know to initialize its\\n\", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" component with the weights learned from the pretraining step. You do\\nthis by setting \", _jsx(InlineCode, {\n          children: \"initialize.init_tok2vec\"\n        }), \" to the filename of the \", _jsx(InlineCode, {\n          children: \".bin\"\n        }), \" file\\nthat you want to use from pretraining.\"]\n      }), _jsxs(_components.p, {\n        children: [\"A pretraining step that runs for 5 epochs with an output path of \", _jsx(InlineCode, {\n          children: \"pretrain/\"\n        }), \", as\\nan example, produces \", _jsx(InlineCode, {\n          children: \"pretrain/model0.bin\"\n        }), \" through \", _jsx(InlineCode, {\n          children: \"pretrain/model4.bin\"\n        }), \". To\\nmake use of the final output, you could fill in this value in your config file:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg\",\n          children: \"\\n[paths]\\ninit_tok2vec = \\\"pretrain/model4.bin\\\"\\n\\n[initialize]\\ninit_tok2vec = ${paths.init_tok2vec}\\n\"\n        })\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"The outputs of \", _jsx(InlineCode, {\n            children: \"spacy pretrain\"\n          }), \" are not the same data format as the pre-packaged\\nstatic word vectors that would go into\\n\", _jsx(_components.a, {\n            href: \"/api/data-formats#config-initialize\",\n            children: _jsx(InlineCode, {\n              children: \"initialize.vectors\"\n            })\n          }), \". The pretraining\\noutput consists of the weights that the \", _jsx(InlineCode, {\n            children: \"tok2vec\"\n          }), \" component should start with in\\nan existing pipeline, so it goes in \", _jsx(InlineCode, {\n            children: \"initialize.init_tok2vec\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h4, {\n        id: \"pretraining-objectives\",\n        children: \"Pretraining objectives \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"Characters objective\",\n            children: \"[pretraining.objective]\\n@architectures = \\\"spacy.PretrainCharacters.v1\\\"\\nmaxout_pieces = 3\\nhidden_size = 300\\nn_characters = 4\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"Vectors objective\",\n            children: \"[pretraining.objective]\\n@architectures = \\\"spacy.PretrainVectors.v1\\\"\\nmaxout_pieces = 3\\nhidden_size = 300\\nloss = \\\"cosine\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Two pretraining objectives are available, both of which are variants of the\\ncloze task \", _jsx(_components.a, {\n          href: \"https://arxiv.org/abs/1810.04805\",\n          children: \"Devlin et al. (2018)\"\n        }), \" introduced\\nfor BERT. The objective can be defined and configured via the\\n\", _jsx(InlineCode, {\n          children: \"[pretraining.objective]\"\n        }), \" config block.\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"/api/architectures#pretrain_chars\",\n              children: _jsx(InlineCode, {\n                children: \"PretrainCharacters\"\n              })\n            }), \": The \", _jsx(InlineCode, {\n              children: \"\\\"characters\\\"\"\n            }), \"\\nobjective asks the model to predict some number of leading and trailing UTF-8\\nbytes for the words. For instance, setting \", _jsx(InlineCode, {\n              children: \"n_characters = 2\"\n            }), \", the model will\\ntry to predict the first two and last two characters of the word.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"/api/architectures#pretrain_vectors\",\n              children: _jsx(InlineCode, {\n                children: \"PretrainVectors\"\n              })\n            }), \": The \", _jsx(InlineCode, {\n              children: \"\\\"vectors\\\"\"\n            }), \"\\nobjective asks the model to predict the word’s vector, from a static\\nembeddings table. This requires a word vectors model to be trained and loaded.\\nThe vectors objective can optimize either a cosine or an L2 loss. We’ve\\ngenerally found cosine loss to perform better.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"These pretraining objectives use a trick that we term \", _jsx(_components.strong, {\n          children: \"language modelling with\\napproximate outputs (LMAO)\"\n        }), \". The motivation for the trick is that predicting an\\nexact word ID introduces a lot of incidental complexity. You need a large output\\nlayer, and even then, the vocabulary is too large, which motivates tokenization\\nschemes that do not align to actual word boundaries. At the end of training, the\\noutput layer will be thrown away regardless: we just want a task that forces the\\nnetwork to model something about word cooccurrence statistics. Predicting\\nleading and trailing characters does that more than adequately, as the exact\\nword sequence could be recovered with high accuracy if the initial and trailing\\ncharacters are predicted accurately. With the vectors objective, the pretraining\\nuses the embedding space learned by an algorithm such as\\n\", _jsx(_components.a, {\n          href: \"https://nlp.stanford.edu/projects/glove/\",\n          children: \"GloVe\"\n        }), \" or\\n\", _jsx(_components.a, {\n          href: \"https://code.google.com/archive/p/word2vec/\",\n          children: \"Word2vec\"\n        }), \", allowing the model to\\nfocus on the contextual modelling we actual care about.\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Embeddings, Transformers and Transfer Learning","teaser":"Using transformer embeddings like BERT in spaCy","menu":[["Embedding Layers","embedding-layers"],["Transformers","transformers"],["Static Vectors","static-vectors"],["Pretraining","pretraining"]],"next":"/usage/training"},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true}