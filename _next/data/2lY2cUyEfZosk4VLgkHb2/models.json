{"pageProps":{"title":"Trained Models & Pipelines","teaser":"Downloadable trained pipelines and weights for spaCy","menu":[["Quickstart","quickstart"],["Conventions","conventions"],["Pipeline Design","design"]],"slug":"/models","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*TODO: include interactive demo*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h3: \"h3\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    ul: \"ul\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {QuickstartModels, InlineCode, Infobox} = _components;\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!QuickstartModels) _missingMdxReference(\"QuickstartModels\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsx(_components.h3, {\n        hidden: \"true\",\n        children: \"Quickstart \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"üìñ Installation and usage\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"For more details on how to use trained pipelines with spaCy, see the\\n\", _jsx(_components.a, {\n            href: \"/usage/models\",\n            children: \"usage guide\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), _jsx(QuickstartModels, {\n        id: \"quickstart\"\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-conventions\",\n      children: [_jsx(_components.h2, {\n        id: \"conventions\",\n        children: \"Package naming conventions \"\n      }), _jsxs(_components.p, {\n        children: [\"In general, spaCy expects all pipeline packages to follow the naming convention\\nof \", _jsx(InlineCode, {\n          children: \"[lang]_[name]\"\n        }), \". For spaCy‚Äôs pipelines, we also chose to divide the name into\\nthree components:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Type:\"\n            }), \" Capabilities (e.g. \", _jsx(InlineCode, {\n              children: \"core\"\n            }), \" for general-purpose pipeline with\\ntagging, parsing, lemmatization and named entity recognition, or \", _jsx(InlineCode, {\n              children: \"dep\"\n            }), \" for\\nonly tagging, parsing and lemmatization).\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Genre:\"\n            }), \" Type of text the pipeline is trained on, e.g. \", _jsx(InlineCode, {\n              children: \"web\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"news\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Size:\"\n            }), \" Package size indicator, \", _jsx(InlineCode, {\n              children: \"sm\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"md\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"lg\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"trf\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [_jsx(InlineCode, {\n              children: \"sm\"\n            }), \" and \", _jsx(InlineCode, {\n              children: \"trf\"\n            }), \" pipelines have no static word vectors.\"]\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"For pipelines with default vectors, \", _jsx(InlineCode, {\n              children: \"md\"\n            }), \" has a reduced word vector table with\\n20k unique vectors for ~500k words and \", _jsx(InlineCode, {\n              children: \"lg\"\n            }), \" has a large word vector table\\nwith ~500k entries.\"]\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"For pipelines with floret vectors, \", _jsx(InlineCode, {\n              children: \"md\"\n            }), \" vector tables have 50k entries and\\n\", _jsx(InlineCode, {\n              children: \"lg\"\n            }), \" vector tables have 200k entries.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"For example, \", _jsx(_components.a, {\n          href: \"/models/en#en_core_web_sm\",\n          children: _jsx(InlineCode, {\n            children: \"en_core_web_sm\"\n          })\n        }), \" is a small English\\npipeline trained on written web text (blogs, news, comments), that includes\\nvocabulary, syntax and entities.\"]\n      }), _jsx(_components.h3, {\n        id: \"model-versioning\",\n        children: \"Package versioning \"\n      }), _jsxs(_components.p, {\n        children: [\"Additionally, the pipeline package versioning reflects both the compatibility\\nwith spaCy, as well as the model version. A package version \", _jsx(InlineCode, {\n          children: \"a.b.c\"\n        }), \" translates\\nto:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"a\"\n          }), \": \", _jsx(_components.strong, {\n            children: \"spaCy major version\"\n          }), \". For example, \", _jsx(InlineCode, {\n            children: \"2\"\n          }), \" for spaCy v2.x.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"b\"\n          }), \": \", _jsx(_components.strong, {\n            children: \"spaCy minor version\"\n          }), \". For example, \", _jsx(InlineCode, {\n            children: \"3\"\n          }), \" for spaCy v2.3.x.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(InlineCode, {\n            children: \"c\"\n          }), \": \", _jsx(_components.strong, {\n            children: \"Model version\"\n          }), \". Different model config: e.g. from being trained on\\ndifferent data, with different parameters, for different numbers of\\niterations, with different vectors, etc.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"For a detailed compatibility overview, see the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/spacy-models/tree/master/compatibility.json\",\n          children: _jsx(InlineCode, {\n            children: \"compatibility.json\"\n          })\n        }), \".\\nThis is also the source of spaCy‚Äôs internal compatibility check, performed when\\nyou run the \", _jsx(_components.a, {\n          href: \"/api/cli#download\",\n          children: _jsx(InlineCode, {\n            children: \"download\"\n          })\n        }), \" command.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-design\",\n      children: [_jsx(_components.h2, {\n        id: \"design\",\n        children: \"Trained pipeline design \"\n      }), _jsx(_components.p, {\n        children: \"The spaCy v3 trained pipelines are designed to be efficient and configurable.\\nFor example, multiple components can share a common ‚Äútoken-to-vector‚Äù model and\\nit‚Äôs easy to swap out or disable the lemmatizer. The pipelines are designed to\\nbe efficient in terms of speed and size and work well when the pipeline is run\\nin full.\"\n      }), _jsxs(_components.p, {\n        children: [\"When modifying a trained pipeline, it‚Äôs important to understand how the\\ncomponents \", _jsx(_components.strong, {\n          children: \"depend on\"\n        }), \" each other. Unlike spaCy v2, where the \", _jsx(InlineCode, {\n          children: \"tagger\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"parser\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" components were all independent, some v3 components depend on\\nearlier components in the pipeline. As a result, disabling or reordering\\ncomponents can affect the annotation quality or lead to warnings and errors.\"]\n      }), _jsx(_components.p, {\n        children: \"Main changes from spaCy v2 models:\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/tok2vec\",\n            children: _jsx(InlineCode, {\n              children: \"Tok2Vec\"\n            })\n          }), \" component may be a separate, shared component. A\\ncomponent like a tagger or parser can\\n\", _jsx(_components.a, {\n            href: \"/api/architectures#Tok2VecListener\",\n            children: \"listen\"\n          }), \" to an earlier \", _jsx(InlineCode, {\n            children: \"tok2vec\"\n          }), \" or\\n\", _jsx(InlineCode, {\n            children: \"transformer\"\n          }), \" rather than having its own separate tok2vec layer.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Rule-based exceptions move from individual components to the\\n\", _jsx(InlineCode, {\n            children: \"attribute_ruler\"\n          }), \". Lemma and POS exceptions move from the tokenizer exceptions\\nto the attribute ruler and the tag map and morph rules move from the tagger to\\nthe attribute ruler.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The lemmatizer tables and processing move from the vocab and tagger to a\\nseparate \", _jsx(InlineCode, {\n            children: \"lemmatizer\"\n          }), \" component.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"design-cnn\",\n        children: \"CNN/CPU pipeline design \"\n      }), _jsx(_components.img, {\n        src: \"/images/pipeline-design.svg\",\n        alt: \"Components and their dependencies in the CNN pipelines\"\n      }), _jsxs(_components.p, {\n        children: [\"In the \", _jsx(InlineCode, {\n          children: \"sm\"\n        }), \"/\", _jsx(InlineCode, {\n          children: \"md\"\n        }), \"/\", _jsx(InlineCode, {\n          children: \"lg\"\n        }), \" models:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"tagger\"\n          }), \", \", _jsx(InlineCode, {\n            children: \"morphologizer\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"parser\"\n          }), \" components listen to the \", _jsx(InlineCode, {\n            children: \"tok2vec\"\n          }), \"\\ncomponent. If the lemmatizer is trainable (v3.3+), \", _jsx(InlineCode, {\n            children: \"lemmatizer\"\n          }), \" also listens\\nto \", _jsx(InlineCode, {\n            children: \"tok2vec\"\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"attribute_ruler\"\n          }), \" maps \", _jsx(InlineCode, {\n            children: \"token.tag\"\n          }), \" to \", _jsx(InlineCode, {\n            children: \"token.pos\"\n          }), \" if there is no\\n\", _jsx(InlineCode, {\n            children: \"morphologizer\"\n          }), \". The \", _jsx(InlineCode, {\n            children: \"attribute_ruler\"\n          }), \" additionally makes sure whitespace is\\ntagged consistently and copies \", _jsx(InlineCode, {\n            children: \"token.pos\"\n          }), \" to \", _jsx(InlineCode, {\n            children: \"token.tag\"\n          }), \" if there is no\\ntagger. For English, the attribute ruler can improve its mapping from\\n\", _jsx(InlineCode, {\n            children: \"token.tag\"\n          }), \" to \", _jsx(InlineCode, {\n            children: \"token.pos\"\n          }), \" if dependency parses from a \", _jsx(InlineCode, {\n            children: \"parser\"\n          }), \" are present,\\nbut the parser is not required.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"lemmatizer\"\n          }), \" component for many languages requires \", _jsx(InlineCode, {\n            children: \"token.pos\"\n          }), \" annotation\\nfrom either \", _jsx(InlineCode, {\n            children: \"tagger\"\n          }), \"+\", _jsx(InlineCode, {\n            children: \"attribute_ruler\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"morphologizer\"\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"ner\"\n          }), \" component is independent with its own internal tok2vec layer.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        children: \"CNN/CPU pipelines with floret vectors\"\n      }), _jsxs(_components.p, {\n        children: [\"The Finnish, Korean and Swedish \", _jsx(InlineCode, {\n          children: \"md\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"lg\"\n        }), \" pipelines use\\n\", _jsx(_components.a, {\n          href: \"/usage/v3-2#vectors\",\n          children: \"floret vectors\"\n        }), \" instead of default vectors. If you‚Äôre\\nrunning a trained pipeline on texts and working with \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects,\\nyou shouldn‚Äôt notice any difference with floret vectors. With floret vectors no\\ntokens are out-of-vocabulary, so \", _jsx(_components.a, {\n          href: \"/api/token#attributes\",\n          children: _jsx(InlineCode, {\n            children: \"Token.is_oov\"\n          })\n        }), \" will\\nreturn \", _jsx(InlineCode, {\n          children: \"False\"\n        }), \" for all tokens.\"]\n      }), _jsx(_components.p, {\n        children: \"If you access vectors directly for similarity comparisons, there are a few\\ndifferences because floret vectors don‚Äôt include a fixed word list like the\\nvector keys for default vectors.\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"If your workflow iterates over the vector keys, you need to use an external\\nword list instead:\"\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"- lexemes = [nlp.vocab[orth] for orth in nlp.vocab.vectors]\\n+ lexemes = [nlp.vocab[word] for word in external_word_list]\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.a, {\n              href: \"/api/vectors#most_similar\",\n              children: _jsx(InlineCode, {\n                children: \"Vectors.most_similar\"\n              })\n            }), \" is not supported because\\nthere‚Äôs no fixed list of vectors to compare your vectors to.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"design-trf\",\n        children: \"Transformer pipeline design \"\n      }), _jsxs(_components.p, {\n        children: [\"In the transformer (\", _jsx(InlineCode, {\n          children: \"trf\"\n        }), \") models, the \", _jsx(InlineCode, {\n          children: \"tagger\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"parser\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" (if present)\\nall listen to the \", _jsx(InlineCode, {\n          children: \"transformer\"\n        }), \" component. The \", _jsx(InlineCode, {\n          children: \"attribute_ruler\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"lemmatizer\"\n        }), \" have the same configuration as in the CNN models.\"]\n      }), _jsx(_components.h3, {\n        id: \"design-modify\",\n        children: \"Modifying the default pipeline \"\n      }), _jsxs(_components.p, {\n        children: [\"For faster processing, you may only want to run a subset of the components in a\\ntrained pipeline. The \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" arguments to\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \" let you control which components are\\nloaded and run. Disabled components are loaded in the background so it‚Äôs\\npossible to reenable them in the same pipeline in the future with\\n\", _jsx(_components.a, {\n          href: \"/api/language/#enable_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.enable_pipe\"\n          })\n        }), \". To skip loading a component\\ncompletely, use \", _jsx(InlineCode, {\n          children: \"exclude\"\n        }), \" instead of \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \".\"]\n      }), _jsx(_components.h4, {\n        children: \"Disable part-of-speech tagging and lemmatization\"\n      }), _jsxs(_components.p, {\n        children: [\"To disable part-of-speech tagging and lemmatization, disable the \", _jsx(InlineCode, {\n          children: \"tagger\"\n        }), \",\\n\", _jsx(InlineCode, {\n          children: \"morphologizer\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"attribute_ruler\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"lemmatizer\"\n        }), \" components.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Note: English doesn't include a morphologizer\\nnlp = spacy.load(\\\"en_core_web_sm\\\", disable=[\\\"tagger\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"])\\nnlp = spacy.load(\\\"en_core_web_trf\\\", disable=[\\\"tagger\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"])\\n\"\n        })\n      }), _jsxs(Infobox, {\n        variant: \"warning\",\n        title: \"Rule-based and POS-lookup lemmatizers require\\nToken.pos\",\n        children: [_jsxs(_components.p, {\n          children: [\"The lemmatizer depends on \", _jsx(InlineCode, {\n            children: \"tagger\"\n          }), \"+\", _jsx(InlineCode, {\n            children: \"attribute_ruler\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"morphologizer\"\n          }), \" for a\\nnumber of languages. If you disable any of these components, you‚Äôll see\\nlemmatizer warnings unless the lemmatizer is also disabled.\"]\n        }), _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"v3.3\"\n          }), \": Catalan, English, French, Russian and Spanish\"]\n        }), _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"v3.0-v3.2\"\n          }), \": Catalan, Dutch, English, French, Greek, Italian, Macedonian,\\nNorwegian, Polish, Russian and Spanish\"]\n        })]\n      }), _jsx(_components.h4, {\n        children: \"Use senter rather than parser for fast sentence segmentation\"\n      }), _jsxs(_components.p, {\n        children: [\"If you need fast sentence segmentation without dependency parses, disable the\\n\", _jsx(InlineCode, {\n          children: \"parser\"\n        }), \" use the \", _jsx(InlineCode, {\n          children: \"senter\"\n        }), \" component instead:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.disable_pipe(\\\"parser\\\")\\nnlp.enable_pipe(\\\"senter\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"senter\"\n        }), \" component is ~10√ó faster than the parser and more accurate\\nthan the rule-based \", _jsx(InlineCode, {\n          children: \"sentencizer\"\n        }), \".\"]\n      }), _jsx(_components.h4, {\n        children: \"Switch from trainable lemmatizer to default lemmatizer\"\n      }), _jsx(_components.p, {\n        children: \"Since v3.3, a number of pipelines use a trainable lemmatizer. You can check\\nwhether the lemmatizer is trainable:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"de_core_web_sm\\\")\\nassert nlp.get_pipe(\\\"lemmatizer\\\").is_trainable\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"If you‚Äôd like to switch to a non-trainable lemmatizer that‚Äôs similar to v3.2 or\\nearlier, you can replace the trainable lemmatizer with the default non-trainable\\nlemmatizer:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Requirements: pip install spacy-lookups-data\\nnlp = spacy.load(\\\"de_core_web_sm\\\")\\n# Remove existing lemmatizer\\nnlp.remove_pipe(\\\"lemmatizer\\\")\\n# Add non-trainable lemmatizer from language defaults\\n# and load lemmatizer tables from spacy-lookups-data\\nnlp.add_pipe(\\\"lemmatizer\\\").initialize()\\n\"\n        })\n      }), _jsx(_components.h4, {\n        children: \"Switch from rule-based to lookup lemmatization\"\n      }), _jsx(_components.p, {\n        children: \"For the Dutch, English, French, Greek, Macedonian, Norwegian and Spanish\\npipelines, you can swap out a trainable or rule-based lemmatizer for a lookup\\nlemmatizer:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Requirements: pip install spacy-lookups-data\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.remove_pipe(\\\"lemmatizer\\\")\\nnlp.add_pipe(\\\"lemmatizer\\\", config={\\\"mode\\\": \\\"lookup\\\"}).initialize()\\n\"\n        })\n      }), _jsx(_components.h4, {\n        children: \"Disable everything except NER\"\n      }), _jsxs(_components.p, {\n        children: [\"For the non-transformer models, the \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" component is independent, so you can\\ndisable everything else:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"en_core_web_sm\\\", disable=[\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"])\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In the transformer models, \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" listens to the \", _jsx(InlineCode, {\n          children: \"transformer\"\n        }), \" component, so you\\ncan disable all components related tagging, parsing, and lemmatization.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"en_core_web_trf\\\", disable=[\\\"tagger\\\", \\\"parser\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"])\\n\"\n        })\n      }), _jsx(_components.h4, {\n        children: \"Move NER to the end of the pipeline\"\n      }), _jsx(Infobox, {\n        title: \"For v3.0.x models only\",\n        variant: \"warning\",\n        children: _jsx(_components.p, {\n          children: \"As of v3.1, the NER component is at the end of the pipeline by default.\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"For access to \", _jsx(InlineCode, {\n          children: \"POS\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"LEMMA\"\n        }), \" features in an \", _jsx(InlineCode, {\n          children: \"entity_ruler\"\n        }), \", move \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" to the\\nend of the pipeline after \", _jsx(InlineCode, {\n          children: \"attribute_ruler\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"lemmatizer\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# load without NER\\nnlp = spacy.load(\\\"en_core_web_sm\\\", exclude=[\\\"ner\\\"])\\n\\n# source NER from the same pipeline package as the last component\\nnlp.add_pipe(\\\"ner\\\", source=spacy.load(\\\"en_core_web_sm\\\"))\\n\\n# insert the entity ruler\\nnlp.add_pipe(\\\"entity_ruler\\\", before=\\\"ner\\\")\\n\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Trained Models & Pipelines","teaser":"Downloadable trained pipelines and weights for spaCy","menu":[["Quickstart","quickstart"],["Conventions","conventions"],["Pipeline Design","design"]]},"scope":{}},"sectionTitle":"Models Documentation","theme":"blue","section":"models","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":true,"next":null},"__N_SSG":true}