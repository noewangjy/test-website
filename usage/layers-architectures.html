<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="shortcut icon" href="/icons/icon-192x192.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=5.0, shrink-to-fit=no, viewport-fit=cover"/><meta name="theme-color" content="#09a3d5"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title>Layers and Model Architectures · spaCy Usage Documentation</title><meta name="description" content="Power spaCy components with custom neural networks"/><meta property="og:title" content="Layers and Model Architectures · spaCy Usage Documentation"/><meta property="og:description" content="Power spaCy components with custom neural networks"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Layers and Model Architectures"/><meta property="og:image" content="https://noewangjy.github.io/test-website//_next/static/media/social_default.96b04585.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://noewangjy.github.io/test-website//_next/static/media/social_default.96b04585.jpg"/><meta name="twitter:creator" content="@spacy_io"/><meta name="twitter:site" content="@spacy_io"/><meta name="twitter:title" content="Layers and Model Architectures · spaCy Usage Documentation"/><meta name="twitter:description" content="Power spaCy components with custom neural networks"/><meta name="docsearch:language" content="en"/><meta name="next-head-count" content="24"/><link rel="preload" href="/_next/static/css/8f0b94edbc18d62d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8f0b94edbc18d62d.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e6995e0e8addcf99.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e6995e0e8addcf99.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script defer="" src="/_next/static/chunks/262.c647d33d06232ef6.js"></script><script defer="" src="/_next/static/chunks/728.cf6ba0da2700fa1b.js"></script><script src="/_next/static/chunks/webpack-8161fc2bb14cec39.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-a0f603ce323043fd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ee1fab0e25bb912e.js" defer=""></script><script src="/_next/static/chunks/94-57434c8b7a6c3878.js" defer=""></script><script src="/_next/static/chunks/128-76b45627a109219b.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...listPathPage%5D-45eea57fe8c2902c.js" defer=""></script><script src="/_next/static/2lY2cUyEfZosk4VLgkHb2/_buildManifest.js" defer=""></script><script src="/_next/static/2lY2cUyEfZosk4VLgkHb2/_ssgManifest.js" defer=""></script></head><body class="theme-blue"><div id="__next"><div class="theme-blue"><nav class="navigation_root__yPL8O"><span class="navigation_has-alert__s0Drf"><a class="link_root__1Me7D link_no-link-layout__RPvod" aria-label="spaCy" href="/"><h1 class="navigation_title__pm49s">spaCy</h1></a> <span class="navigation_alert__ZOXon"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/usage/v3-5"><strong>💥 Out now:</strong> spaCy v3.5</a></span></span><div class="navigation_menu__ZMJxN"><select class="dropdown_root__3uiQq navigation_dropdown__4j4pI"><option value="title" disabled="">Menu</option><option value="/usage" selected="">Usage</option><option value="/models">Models</option><option value="/api">API</option><option value="/universe">Universe</option></select><ul class="navigation_list__DCzqi"><li class="navigation_item__ln1O1 navigation_is-active__RjVJG"><a class="link_root__1Me7D link_no-link-layout__RPvod" tabindex="-1" href="/usage">Usage</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/models">Models</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/api">API</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/universe">Universe</a></li><li class="navigation_item__ln1O1 navigation_github__MpFNv"><span><a href="https://github.com/explosion/spaCy" data-size="large" data-show-count="true" aria-label="Star spaCy on GitHub"></a></span></li></ul><div class="navigation_search__BKZCn"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div><progress class="progress_root__9huWN" value="0" max="100"></progress></nav><menu class="sidebar sidebar_root__s2No7"><h1 hidden="" aria-hidden="true" class="h0 sidebar_active-heading___dkf9">Guides</h1><div class="sidebar_dropdown__vyqjz"><select class="dropdown_root__3uiQq sidebar_dropdown-select__Nwbq9"><option disabled="">Select page...</option><option value="/usage">Get started<!-- --> › <!-- -->Installation</option><option value="/usage/models">Get started<!-- --> › <!-- -->Models &amp; Languages</option><option value="/usage/facts-figures">Get started<!-- --> › <!-- -->Facts &amp; Figures</option><option value="/usage/spacy-101">Get started<!-- --> › <!-- -->spaCy 101</option><option value="/usage/v3">Get started<!-- --> › <!-- -->New in v3.0</option><option value="/usage/v3-1">Get started<!-- --> › <!-- -->New in v3.1</option><option value="/usage/v3-2">Get started<!-- --> › <!-- -->New in v3.2</option><option value="/usage/v3-3">Get started<!-- --> › <!-- -->New in v3.3</option><option value="/usage/v3-4">Get started<!-- --> › <!-- -->New in v3.4</option><option value="/usage/v3-5">Get started<!-- --> › <!-- -->New in v3.5</option><option value="/usage/linguistic-features">Guides<!-- --> › <!-- -->Linguistic Features</option><option value="/usage/rule-based-matching">Guides<!-- --> › <!-- -->Rule-based Matching</option><option value="/usage/processing-pipelines">Guides<!-- --> › <!-- -->Processing Pipelines</option><option value="/usage/embeddings-transformers">Guides<!-- --> › <!-- -->Embeddings &amp; Transformers</option><option value="/usage/training">Guides<!-- --> › <!-- -->Training Models</option><option value="/usage/layers-architectures" selected="">Guides<!-- --> › <!-- -->Layers &amp; Model Architectures</option><option value="/usage/projects">Guides<!-- --> › <!-- -->spaCy Projects</option><option value="/usage/saving-loading">Guides<!-- --> › <!-- -->Saving &amp; Loading</option><option value="/usage/visualizers">Guides<!-- --> › <!-- -->Visualizers</option><option value="https://github.com/explosion/projects">Resources<!-- --> › <!-- -->Project Templates</option><option value="https://v2.spacy.io">Resources<!-- --> › <!-- -->v2.x Documentation</option><option value="https://explosion.ai/custom-solutions">Resources<!-- --> › <!-- -->Custom Solutions</option></select></div><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Get started</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage">Installation</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/models">Models &amp; Languages</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/facts-figures">Facts &amp; Figures</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/spacy-101">spaCy 101</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3">New in v3.0</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-1">New in v3.1</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-2">New in v3.2</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-3">New in v3.3</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-4">New in v3.4</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-5">New in v3.5</a></li></ul><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Guides</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/linguistic-features">Linguistic Features</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/rule-based-matching">Rule-based Matching</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/processing-pipelines">Processing Pipelines</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/embeddings-transformers">Embeddings &amp; Transformers<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/training">Training Models<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP sidebar_is-active__yVTtL is-active" href="/usage/layers-architectures">Layers &amp; Model Architectures<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a><ul class="sidebar_crumbs__NhM2y"><li class="sidebar_crumb__tiiDl sidebar_crumb-active__zq8BI"><a href="#type-sigs">Type Signatures</a></li><li class="sidebar_crumb__tiiDl"><a href="#swap-architectures">Swapping Architectures</a></li><li class="sidebar_crumb__tiiDl"><a href="#frameworks">PyTorch &amp; TensorFlow</a></li><li class="sidebar_crumb__tiiDl"><a href="#thinc">Custom Thinc Models</a></li><li class="sidebar_crumb__tiiDl"><a href="#components">Trainable Components</a></li></ul></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/projects">spaCy Projects<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/saving-loading">Saving &amp; Loading</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/visualizers">Visualizers</a></li></ul><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Resources</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/projects">Project Templates</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="https://v2.spacy.io">v2.x Documentation</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="https://explosion.ai/custom-solutions">Custom Solutions</a></li></ul></menu><main class="main_root__7f6Tj main_with-sidebar__uH1df main_with-asides__ikQT6"><article class="main_content__8zFCH"><header class="title_root__pS2WQ"><h1 id="_title" class="typography_heading__D82WZ typography_h1__b7dt9 title_h1__l3CW1"><span class="heading-text">Layers and Model Architectures<!-- --> </span></h1><div class="heading-teaser title_teaser__QhwCH">Power spaCy components with custom neural networks</div></header><section class="section_root__k1hUl"><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><p>A <strong>model architecture</strong> is a function that wires up a
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Thinc <code class="code_inline-code__Bq7ot">Model</code></a> instance. It describes the
neural network that is run internally as part of a component in a spaCy
pipeline. To define the actual architecture, you can implement your logic in
Thinc directly, or you can use Thinc as a thin wrapper around frameworks such as
PyTorch, TensorFlow and MXNet. Each <code class="code_inline-code__Bq7ot">Model</code> can also be used as a sublayer of a
larger network, allowing you to freely combine implementations from different
frameworks into a single model.</p><p>spaCy’s built-in components require a <code class="code_inline-code__Bq7ot">Model</code> instance to be passed to them via
the config system. To change the model architecture of an existing component,
you just need to <a class="link_root__1Me7D" href="/usage/layers-architectures#swap-architectures"><strong>update the config</strong></a> so that it refers
to a different registered function. Once the component has been created from
this config, you won’t be able to change it anymore. The architecture is like a
recipe for the network, and you can’t change the recipe once the dish has
already been prepared. You have to make a new one.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre></section>
<section id="section-type-sigs" class="section_root__k1hUl"><h2 id="type-sigs" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#type-sigs" class="heading-text typography_permalink__UiIRy">Type signatures <!-- --> </a></h2><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><p>The Thinc <code class="code_inline-code__Bq7ot">Model</code> class is a <strong>generic type</strong> that can specify its input and
output types. Python uses a square-bracket notation for this, so the type
<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">,</span> Dict<span class="code_cli-arg-subtle__IgB5m">]</span></span> says that each batch of inputs to the model will be a
list, and the outputs will be a dictionary. You can be even more specific and
write for instance<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM code_wrap__b41os" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span> Dict<span class="code_cli-arg-subtle__IgB5m">[</span>str<span class="code_cli-arg-subtle__IgB5m">,</span> float<span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">]</span></span> to specify that the
model expects a list of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects as input, and returns a
dictionary mapping of strings to floats. Some of the most common types you’ll
see are: ​</p><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Type</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span></span></td><td class="table_td__rmpJx">A batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects. Most components expect their models to take this as input.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a></span></td><td class="table_td__rmpJx">A two-dimensional <code class="code_inline-code__Bq7ot">numpy</code> or <code class="code_inline-code__Bq7ot">cupy</code> array of floats. Usually 32-bit.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Ints2d</a></span></td><td class="table_td__rmpJx">A two-dimensional <code class="code_inline-code__Bq7ot">numpy</code> or <code class="code_inline-code__Bq7ot">cupy</code> array of integers. Common dtypes include uint64, int32 and int8.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span></td><td class="table_td__rmpJx">A list of two-dimensional arrays, generally with one array per <code class="code_inline-code__Bq7ot">Doc</code> and one row per token.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#ragged">Ragged</a></span></td><td class="table_td__rmpJx">A container to handle variable-length sequence data in an unpadded contiguous array.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#padded">Padded</a></span></td><td class="table_td__rmpJx">A container to handle variable-length sequence data in a padded contiguous array.</td></tr></tbody></table><p>See the <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types">Thinc type reference</a> for details. The
model type signatures help you figure out which model architectures and
components can <strong>fit together</strong>. For instance, the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/textcategorizer"><code class="code_inline-code__Bq7ot">TextCategorizer</code></a> class expects a model typed
<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>, because the model will predict one row of
category probabilities per <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a>. In contrast, the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tagger"><code class="code_inline-code__Bq7ot">Tagger</code></a> class expects a model typed <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM code_wrap__b41os" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span>
List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">]</span></span>, because it needs to predict one row of probabilities per
token.</p><p>There’s no guarantee that two models with the same type signature can be used
interchangeably. There are many other ways they could be incompatible. However,
if the types don’t match, they almost surely <em>won’t</em> be compatible. This little
bit of validation goes a long way, especially if you
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-type-checking">configure your editor</a> or other
tools to highlight these errors early. The config file is also validated at the
beginning of training, to verify that all the types match correctly.</p><section class="accordion"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Tip: Static type checking in your editor</span></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>If you’re using a modern editor like Visual Studio Code, you can
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-type-checking#install">set up <code class="code_inline-code__Bq7ot">mypy</code></a> with the
custom Thinc plugin and get live feedback about mismatched types as you write
code.</p><figure class="gatsby-resp-image-figure"><a class="link_root__1Me7D gatsby-resp-image-link embed_image-link__loaAa link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-type-checking#linting"><img class="embed_image__mSQUH" src="/images/thinc_mypy.jpg" alt="Screenshot of Thinc type checking in VSCode with mypy" width="650" height="auto"/></a></figure></div></div></section></section>
<section id="section-swap-architectures" class="section_root__k1hUl"><h2 id="swap-architectures" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#swap-architectures" class="heading-text typography_permalink__UiIRy">Swapping model architectures <!-- --> </a></h2><p>If no model is specified for the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/textcategorizer"><code class="code_inline-code__Bq7ot">TextCategorizer</code></a>, the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/architectures#TextCatEnsemble"><span class="link_source-text__VDP74">TextCatEnsemble</span></a> architecture is used by
default. This architecture combines a simple bag-of-words model with a neural
network, usually resulting in the most accurate results, but at the cost of
speed. The config file for this model would look something like this:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre><p>spaCy has two additional built-in <code class="code_inline-code__Bq7ot">textcat</code> architectures, and you can easily
use those by swapping out the definition of the textcat’s model. For instance,
to use the simple and fast bag-of-words model
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/architectures#TextCatBOW"><span class="link_source-text__VDP74">TextCatBOW</span></a>, you can change the config to:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini code_wrap__b41os"></code></pre><p>For details on all pre-defined architectures shipped with spaCy and how to
configure them, check out the <a class="link_root__1Me7D link_with-icon__NAVDA" href="/api/architectures"><span class="link_source-text__VDP74">model architectures</span></a>
documentation.</p><h3 id="sublayers" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#sublayers" class="heading-text typography_permalink__UiIRy">Defining sublayers <!-- --> </a></h3><p>Model architecture functions often accept <strong>sublayers as arguments</strong>, so that
you can try <strong>substituting a different layer</strong> into the network. Depending on
how the architecture function is structured, you might be able to define your
network structure entirely through the <a class="link_root__1Me7D" href="/usage/training#config">config system</a>,
using layers that have already been defined. ​</p><p>In most neural network models for NLP, the most important parts of the network
are what we refer to as the
<a class="link_root__1Me7D" href="https://explosion.ai/blog/deep-learning-formula-nlp">embed and encode</a> steps.
These steps together compute dense, context-sensitive representations of the
tokens, and their combination forms a typical
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/architectures#Tok2Vec"><code class="code_inline-code__Bq7ot">Tok2Vec</code></a> layer:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre><p>By defining these sublayers specifically, it becomes straightforward to swap out
a sublayer for another one, for instance changing the first sublayer to a
character embedding with the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/architectures#CharacterEmbed"><span class="link_source-text__VDP74">CharacterEmbed</span></a>
architecture:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre><p>Most of spaCy’s default architectures accept a <code class="code_inline-code__Bq7ot">tok2vec</code> layer as a sublayer
within the larger task-specific neural network. This makes it easy to <strong>switch
between</strong> transformer, CNN, BiLSTM or other feature extraction approaches. The
<a class="link_root__1Me7D" href="/usage/embeddings-transformers#training-custom-model">transformers documentation</a>
section shows an example of swapping out a model’s standard <code class="code_inline-code__Bq7ot">tok2vec</code> layer with
a transformer. And if you want to define your own solution, all you need to do
is register a <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM code_wrap__b41os" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span> List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">]</span></span> architecture function, and
you’ll be able to try it out in any of the spaCy components. ​</p></section>
<section id="section-frameworks" class="section_root__k1hUl"><h2 id="frameworks" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#frameworks" class="heading-text typography_permalink__UiIRy">Wrapping PyTorch, TensorFlow and other frameworks <!-- --> </a></h2><p>Thinc allows you to <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-frameworks">wrap models</a>
written in other machine learning frameworks like PyTorch, TensorFlow and MXNet
using a unified <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model"><code class="code_inline-code__Bq7ot">Model</code></a> API. This makes it
easy to use a model implemented in a different framework to power a component in
your spaCy pipeline. For example, to wrap a PyTorch model as a Thinc <code class="code_inline-code__Bq7ot">Model</code>,
you can use Thinc’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#pytorchwrapper"><code class="code_inline-code__Bq7ot">PyTorchWrapper</code></a>:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>Let’s use PyTorch to define a very simple neural network consisting of two
hidden <code class="code_inline-code__Bq7ot">Linear</code> layers with <code class="code_inline-code__Bq7ot">ReLU</code> activation and dropout, and a
softmax-activated output layer:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">PyTorch model</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>The resulting wrapped <code class="code_inline-code__Bq7ot">Model</code> can be used as a <strong>custom architecture</strong> as such,
or can be a <strong>subcomponent of a larger model</strong>. For instance, we can use Thinc’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#chain"><code class="code_inline-code__Bq7ot">chain</code></a> combinator, which works like
<code class="code_inline-code__Bq7ot">Sequential</code> in PyTorch, to combine the wrapped model with other components in a
larger network. This effectively means that you can easily wrap different
components from different frameworks, and “glue” them together with Thinc:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>In the above example, we have combined our custom PyTorch model with a character
embedding layer defined by spaCy.
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/architectures#CharacterEmbed"><span class="link_source-text__VDP74">CharacterEmbed</span></a> returns a <code class="code_inline-code__Bq7ot">Model</code> that takes
a <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span></span> as input, and outputs a <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>. To make sure that
the wrapped PyTorch model receives valid inputs, we use Thinc’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#with_array"><code class="code_inline-code__Bq7ot">with_array</code></a> helper.</p><p>You could also implement a model that only uses PyTorch for the transformer
layers, and “native” Thinc layers to do fiddly input and output transformations
and add on task-specific “heads”, as efficiency is less of a consideration for
those parts of the network.</p><h3 id="frameworks-usage" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#frameworks-usage" class="heading-text typography_permalink__UiIRy">Using wrapped models <!-- --> </a></h3><p>To use our custom model including the PyTorch subnetwork, all we need to do is
register the architecture using the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#registry"><code class="code_inline-code__Bq7ot">architectures</code> registry</a>. This assigns the
architecture a name so spaCy knows how to find it, and allows passing in
arguments like hyperparameters via the <a class="link_root__1Me7D" href="/usage/training#config">config</a>. The
full example then becomes:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Registering the architecture</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>The model definition can now be used in any existing trainable spaCy component,
by specifying it in the config file. In this configuration, all required
parameters for the various subcomponents of the custom architecture are passed
in as settings via the config.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini code_wrap__b41os"></code></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><p>Remember that it is best not to rely on any (hidden) default values to ensure
that training configs are complete and experiments fully reproducible.</p></aside><p>Note that when using a PyTorch or Tensorflow model, it is recommended to set the
GPU memory allocator accordingly. When <code class="code_inline-code__Bq7ot">gpu_allocator</code> is set to “pytorch” or
“tensorflow” in the training config, cupy will allocate memory via those
respective libraries, preventing OOM errors when there’s available memory
sitting in the other library’s pool.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre></section>
<section id="section-thinc" class="section_root__k1hUl"><h2 id="thinc" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#thinc" class="heading-text typography_permalink__UiIRy">Custom models with Thinc <!-- --> </a></h2><p>Of course it’s also possible to define the <code class="code_inline-code__Bq7ot">Model</code> from the previous section
entirely in Thinc. The Thinc documentation provides details on the
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers">various layers</a> and helper functions
available. Combinators can be used to
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-models#operators">overload operators</a> and a common
usage pattern is to bind <code class="code_inline-code__Bq7ot">chain</code> to <code class="code_inline-code__Bq7ot">&gt;&gt;</code>. The “native” Thinc version of our
simple neural network would then become:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Important note on inputs and outputs</span></h4><p>Note that Thinc layers define the output dimension (<code class="code_inline-code__Bq7ot">nO</code>) as the first argument,
followed (optionally) by the input dimension (<code class="code_inline-code__Bq7ot">nI</code>). This is in contrast to how
the PyTorch layers are defined, where <code class="code_inline-code__Bq7ot">in_features</code> precedes <code class="code_inline-code__Bq7ot">out_features</code>.</p></aside><h3 id="thinc-shape-inference" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#thinc-shape-inference" class="heading-text typography_permalink__UiIRy">Shape inference in Thinc <!-- --> </a></h3><p>It is <strong>not</strong> strictly necessary to define all the input and output dimensions
for each layer, as Thinc can perform
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-models#validation">shape inference</a> between
sequential layers by matching up the output dimensionality of one layer to the
input dimensionality of the next. This means that we can simplify the <code class="code_inline-code__Bq7ot">layers</code>
definition:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Diff<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>Thinc can even go one step further and <strong>deduce the correct input dimension</strong> of
the first layer, and output dimension of the last. To enable this functionality,
you have to call
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model#initialize"><code class="code_inline-code__Bq7ot">Model.initialize</code></a> with an <strong>input
sample</strong> <code class="code_inline-code__Bq7ot">X</code> and an <strong>output sample</strong> <code class="code_inline-code__Bq7ot">Y</code> with the correct dimensions:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Shape inference with initialization</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>The built-in <a class="link_root__1Me7D" href="/usage/processing-pipelines">pipeline components</a> in spaCy ensure
that their internal models are <strong>always initialized</strong> with appropriate sample
data. In this case, <code class="code_inline-code__Bq7ot">X</code> is typically a <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>, while <code class="code_inline-code__Bq7ot">Y</code> is typically a
<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Array1d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span> or <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Array2d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>, depending on the specific task. This
functionality is triggered when <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#initialize"><code class="code_inline-code__Bq7ot">nlp.initialize</code></a> is
called.</p><h3 id="thinc-dropout-norm" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#thinc-dropout-norm" class="heading-text typography_permalink__UiIRy">Dropout and normalization in Thinc <!-- --> </a></h3><p>Many of the available Thinc <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers">layers</a> allow you
to define a <code class="code_inline-code__Bq7ot">dropout</code> argument that will result in “chaining” an additional
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#dropout"><code class="code_inline-code__Bq7ot">Dropout</code></a> layer. Optionally, you can
often specify whether or not you want to add layer normalization, which would
result in an additional
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#layernorm"><code class="code_inline-code__Bq7ot">LayerNorm</code></a> layer. That means that
the following <code class="code_inline-code__Bq7ot">layers</code> definition is equivalent to the previous:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre></section>
<section id="section-components" class="section_root__k1hUl"><h2 id="components" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#components" class="heading-text typography_permalink__UiIRy">Create new trainable components <!-- --> </a></h2><p>In addition to <a class="link_root__1Me7D" href="/usage/layers-architectures#swap-architectures">swapping out</a> layers in existing
components, you can also implement an entirely new,
<a class="link_root__1Me7D" href="/usage/processing-pipelines#trainable-components">trainable</a> pipeline component
from scratch. This can be done by creating a new class inheriting from
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe"><code class="code_inline-code__Bq7ot">TrainablePipe</code></a>, and linking it up to your custom model
implementation.</p><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">💡</span>Trainable component API</span></h4><p>For details on how to implement pipeline components, check out the usage guide
on <a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-component">custom components</a> and the
overview of the <code class="code_inline-code__Bq7ot">TrainablePipe</code> methods used by
<a class="link_root__1Me7D" href="/usage/processing-pipelines#trainable-components">trainable components</a>.</p></aside><h3 id="component-rel" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#component-rel" class="heading-text typography_permalink__UiIRy">Example: Entity relation extraction component <!-- --> </a></h3><p>This section outlines an example use-case of implementing a <strong>novel relation
extraction component</strong> from scratch. We’ll implement a binary relation
extraction method that determines whether or not <strong>two entities</strong> in a document
are related, and if so, what type of relation connects them. We allow multiple
types of relations between two such entities (a multi-label setting). There are
two major steps required:</p><ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Implement a <a class="link_root__1Me7D" href="/usage/layers-architectures#component-rel-model">machine learning model</a> specific to this
task. It will have to extract candidate relation instances from a
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> and predict the corresponding scores for each relation
label.</li>
<li class="list_li__sfx_z">Implement a custom <a class="link_root__1Me7D" href="/usage/layers-architectures#component-rel-pipe">pipeline component</a> - powered by the
machine learning model from step 1 - that translates the predicted scores
into annotations that are stored on the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects as they
pass through the <code class="code_inline-code__Bq7ot">nlp</code> pipeline.</li>
</ol><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">🪐</span>Get started with a project template<!-- -->:<!-- --> <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/projects/tree/v3/tutorials/rel_component"><code class="code_inline-code__Bq7ot">tutorials/rel_component</code></a></span></h4><p>Run this example use-case by using our project template. It includes all the
code to create the ML model and the pipeline component from scratch. It also
contains two config files to train the model: one to run on CPU with a Tok2Vec
layer, and one for the GPU using a transformer. The project applies the
relation extraction component to identify biomolecular interactions in a
sample dataset, but you can easily swap in your own dataset for your
experiments in any other domain.</p><div class="copy_root__9E6qI"><span class="copy_prefix__p_JKI">$</span><textarea readonly="" class="copy_textarea__ATeHi" rows="1" aria-label="Example bash command to start with an end-to-end template">python -m spacy project clone tutorials/rel_component</textarea></div></aside><figure class="embed_root__mluJp embed_responsive__k3do3 embed_ratio16x9__iHV71"><iframe class="embed_iframe__YqdML" title="8HL-Ap5_Axo" src="https://www.youtube-nocookie.com/embed/8HL-Ap5_Axo" frameBorder="0" height="500" allowfullscreen=""></iframe></figure><h4 id="component-rel-model" class="typography_heading__D82WZ typography_h4__CDRaM"><a href="#component-rel-model" class="heading-text typography_permalink__UiIRy">Step 1: Implementing the Model <!-- --> </a></h4><p>We need to implement a <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model"><code class="code_inline-code__Bq7ot">Model</code></a> that takes a
<strong>list of documents</strong> (<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>) as input, and outputs a <strong>two-dimensional
matrix</strong> (<span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a></span>) of predictions:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Model type annotations<!-- --> </span></h4>
<p>The <code class="code_inline-code__Bq7ot">Model</code> class is a generic type that can specify its input and output
types, e.g. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span></span>. Type hints are used for static
type checks and validation. See the section on <a class="link_root__1Me7D" href="/usage/layers-architectures#type-sigs">type signatures</a>
for details.</p>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The model architecture</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>We adapt a <strong>modular approach</strong> to the definition of this relation model, and
define it as chaining two layers together: the first layer that generates an
instance tensor from a given set of documents, and the second layer that
transforms the instance tensor into a final tensor holding the predictions:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The model architecture</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>The <code class="code_inline-code__Bq7ot">classification_layer</code> could be something like a
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#linear">Linear</a> layer followed by a
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#logistic">logistic</a> activation function:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The classification layer</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>The first layer that <strong>creates the instance tensor</strong> can be defined by
implementing a
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-models#weights-layers-forward">custom forward function</a>
with an appropriate backpropagation callback. We also define an
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-models#weights-layers-init">initialization method</a>
that ensures that the layer is properly set up for training.</p><p>We omit some of the implementation details here, and refer to the
<a class="link_root__1Me7D link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/projects/tree/v3/tutorials/rel_component"><span class="link_source-text__VDP74">spaCy project</span></a>
that has the full implementation.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The layer that creates the instance tensor</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>This custom layer uses an <a class="link_root__1Me7D" href="/usage/embeddings-transformers">embedding layer</a> such
as a <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tok2vec"><code class="code_inline-code__Bq7ot">Tok2Vec</code></a> component or a <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/transformer"><code class="code_inline-code__Bq7ot">Transformer</code></a>.
This layer is assumed to be of type <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM code_wrap__b41os" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model">Model</a><span class="code_cli-arg-subtle__IgB5m">[</span>List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" href="/api/doc">Doc</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">,</span> List<span class="code_cli-arg-subtle__IgB5m">[</span><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a><span class="code_cli-arg-subtle__IgB5m">]</span><span class="code_cli-arg-subtle__IgB5m">]</span></span> as it
transforms each <strong>document into a list of tokens</strong>, with each token being
represented by its embedding in the vector space.</p><p>The <code class="code_inline-code__Bq7ot">pooling</code> layer will be applied to summarize the token vectors into <strong>entity
vectors</strong>, as named entities (represented by <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" href="/api/span">Span</a></span> objects) can consist of
one or multiple tokens. For instance, the pooling layer could resort to
calculating the average of all token vectors in an entity. Thinc provides
several
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-layers#reduction-ops">built-in pooling operators</a> for
this purpose.</p><p>Finally, we need a <code class="code_inline-code__Bq7ot">get_instances</code> method that <strong>generates pairs of entities</strong>
that we want to classify as being related or not. As these candidate pairs are
typically formed within one document, this function takes a <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> as
input and outputs a <code class="code_inline-code__Bq7ot">List</code> of <code class="code_inline-code__Bq7ot">Span</code> tuples. For instance, the following
implementation takes any two entities from the same document, as long as they
are within a <strong>maximum distance</strong> (in number of tokens) of each other:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Candidate generation</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>This function is added to the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#registry"><code class="code_inline-code__Bq7ot">@misc</code> registry</a> so we
can refer to it from the config, and easily swap it out for any other candidate
generation function.</p><h4 id="component-rel-attribute" class="typography_heading__D82WZ typography_h4__CDRaM"><a href="#component-rel-attribute" class="heading-text typography_permalink__UiIRy">Intermezzo: define how to store the relations data <!-- --> </a></h4><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example output<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><p>For our new relation extraction component, we will use a custom
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-attributes">extension attribute</a>
<code class="code_inline-code__Bq7ot">doc._.rel</code> in which we store relation data. The attribute refers to a
dictionary, keyed by the <strong>start offsets of each entity</strong> involved in the
candidate relation. The values in the dictionary refer to another dictionary
where relation labels are mapped to values between 0 and 1. We assume anything
above 0.5 to be a <code class="code_inline-code__Bq7ot">True</code> relation. The <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" href="/api/example">Example</a></span> instances that we’ll use as
training data, will include their gold-standard relation annotations in
<code class="code_inline-code__Bq7ot">example.reference._.rel</code>.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Registering the extension attribute</h4><code class="code_code__CILJL language-python language-python"></code></pre><h4 id="component-rel-pipe" class="typography_heading__D82WZ typography_h4__CDRaM"><a href="#component-rel-pipe" class="heading-text typography_permalink__UiIRy">Step 2: Implementing the pipeline component <!-- --> </a></h4><p>To use our new relation extraction model as part of a custom
<a class="link_root__1Me7D" href="/usage/processing-pipelines#trainable-components">trainable component</a>, we
create a subclass of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe"><code class="code_inline-code__Bq7ot">TrainablePipe</code></a> that holds the model.</p><figure class="gatsby-resp-image-figure"><img class="embed_image__mSQUH" src="/images/trainable_component.svg" alt="Illustration of Pipe methods" width="650" height="auto"/></figure><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Pipeline component skeleton</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>Typically, the <strong>constructor</strong> defines the vocab, the Machine Learning model,
and the name of this component. Additionally, this component, just like the
<code class="code_inline-code__Bq7ot">textcat</code> and the <code class="code_inline-code__Bq7ot">tagger</code>, stores an <strong>internal list of labels</strong>. The ML model
will predict scores for each label. We add convenience methods to easily
retrieve and add to them.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The constructor (continued)</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>After creation, the component needs to be
<a class="link_root__1Me7D" href="/usage/training#initialization">initialized</a>. This method can define the
relevant labels in two ways: explicitely by setting the <code class="code_inline-code__Bq7ot">labels</code> argument in the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/data-formats#config-initialize"><code class="code_inline-code__Bq7ot">initialize</code> block</a> of the config, or
implicately by deducing them from the <code class="code_inline-code__Bq7ot">get_examples</code> callback that generates the
full <strong>training data set</strong>, or a representative sample.</p><p>The final number of labels defines the output dimensionality of the network, and
will be used to do
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-models#validation">shape inference</a> throughout the
layers of the neural network. This is triggered by calling
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/api/model#initialize"><code class="code_inline-code__Bq7ot">Model.initialize</code></a>.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The initialize method</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>The <code class="code_inline-code__Bq7ot">initialize</code> method is triggered whenever this component is part of an <code class="code_inline-code__Bq7ot">nlp</code>
pipeline, and <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#initialize"><code class="code_inline-code__Bq7ot">nlp.initialize</code></a> is invoked.
Typically, this happens when the pipeline is set up before training in
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/cli#training"><code class="code_inline-code__Bq7ot">spacy train</code></a>. After initialization, the pipeline component
and its internal model can be trained and used to make predictions.</p><p>During training, the method <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#update"><code class="code_inline-code__Bq7ot">update</code></a> is invoked which
delegates to
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model#begin_update"><code class="code_inline-code__Bq7ot">Model.begin_update</code></a> and a
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#get_loss"><code class="code_inline-code__Bq7ot">get_loss</code></a> function that <strong>calculates the loss</strong> for a
batch of examples, as well as the <strong>gradient</strong> of loss that will be used to
update the weights of the model layers. Thinc provides several
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-loss">loss functions</a> that can be used for the
implementation of the <code class="code_inline-code__Bq7ot">get_loss</code> function.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The update method</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>After training the model, the component can be used to make novel
<strong>predictions</strong>. The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#predict"><code class="code_inline-code__Bq7ot">predict</code></a> method needs to be
implemented for each subclass of <code class="code_inline-code__Bq7ot">TrainablePipe</code>. In our case, we can simply
delegate to the internal model’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model#predict">predict</a> function that takes a batch
of <code class="code_inline-code__Bq7ot">Doc</code> objects and returns a <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-types#types">Floats2d</a></span> array:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The predict method</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>The final method that needs to be implemented, is
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#set_annotations"><code class="code_inline-code__Bq7ot">set_annotations</code></a>. This function takes the
predictions, and modifies the given <code class="code_inline-code__Bq7ot">Doc</code> object in place to store them. For our
relation extraction component, we store the data in the
<a class="link_root__1Me7D" href="/usage/layers-architectures#component-rel-attribute">custom attribute</a><code class="code_inline-code__Bq7ot">doc._.rel</code>.</p><p>To interpret the scores predicted by the relation extraction model correctly, we
need to refer to the model’s <code class="code_inline-code__Bq7ot">get_instances</code> function that defined which pairs
of entities were relevant candidates, so that the predictions can be linked to
those exact entities:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The set_annotations method</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>Under the hood, when the pipe is applied to a document, it delegates to the
<code class="code_inline-code__Bq7ot">predict</code> and <code class="code_inline-code__Bq7ot">set_annotations</code> methods:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The __call__ method</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>There is one more optional method to implement: <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#score"><code class="code_inline-code__Bq7ot">score</code></a>
calculates the performance of your component on a set of examples, and returns
the results as a dictionary:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The score method</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>This is particularly useful for calculating relevant scores on the development
corpus when training the component with <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/cli#training"><code class="code_inline-code__Bq7ot">spacy train</code></a>.</p><p>Once our <code class="code_inline-code__Bq7ot">TrainablePipe</code> subclass is fully implemented, we can
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-factories">register</a> the
component with the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator. This
assigns it a name and lets you create the component with
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a> and via the
<a class="link_root__1Me7D" href="/usage/training#config">config</a>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Registering the pipeline component</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>You can extend the decorator to include information such as the type of
annotations that are required for this component to run, the type of annotations
it produces, and the scores that can be calculated:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Factory annotations</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">🪐</span>Get started with a project template<!-- -->:<!-- --> <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/projects/tree/v3/tutorials/rel_component"><code class="code_inline-code__Bq7ot">tutorials/rel_component</code></a></span></h4><p>Run this example use-case by using our project template. It includes all the
code to create the ML model and the pipeline component from scratch. It
contains two config files to train the model: one to run on CPU with a Tok2Vec
layer, and one for the GPU using a transformer. The project applies the
relation extraction component to identify biomolecular interactions, but you
can easily swap in your own dataset for your experiments in any other domain.</p><div class="copy_root__9E6qI"><span class="copy_prefix__p_JKI">$</span><textarea readonly="" class="copy_textarea__ATeHi" rows="1" aria-label="Example bash command to start with an end-to-end template">python -m spacy project clone tutorials/rel_component</textarea></div></aside></section><div class="grid_root__EfDZl grid_spacing__fhBCv grid_half__xoJZs"><div style="margin-top:var(--spacing-lg)"><a class="link_root__1Me7D button_root__jwipc button_secondary__ukZAk" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/tree/master/website/docs/usage/layers-architectures.mdx">Suggest edits</a></div><a class="link_root__1Me7D readnext_root__JNzwZ link_no-link-layout__RPvod" href="/usage/projects"><span><span class="typography_label__l_oVJ">Read next</span>spaCy Projects</span><span class="readnext_icon__jfRnJ"></span></a></div></article><div class="main_asides__RITE5" style="background-image:url(/_next/static/media/pattern_blue.d167bed5.png"></div><footer class="footer_root__zlkjP"><div class="grid_root__EfDZl footer_content__LaE1F grid_narrow__x_6xS grid_spacing__fhBCv grid_third__edHuB"><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">spaCy</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/usage">Usage</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/models">Models</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/api">API Reference</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://course.spacy.io">Online Course</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/custom-solutions">Custom Solutions</a></li></ul></section><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Community</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/universe">Universe</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/discussions">GitHub Discussions</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/issues">Issue Tracker</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="http://stackoverflow.com/questions/tagged/spacy">Stack Overflow</a></li></ul></section><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Connect</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://twitter.com/spacy_io">Twitter</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy">GitHub</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://youtube.com/c/ExplosionAI">YouTube</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/blog">Blog</a></li></ul></section><section class="footer_full___icln"><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Stay in the loop!</li><li>Receive updates about new releases, tutorials and more.</li><li><form id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" action="//spacy.us12.list-manage.com/subscribe/post?u=83b0498b1e7fa3c91ce68c3f1&amp;amp;id=ecc82e0493" method="post" target="_blank" novalidate=""><div style="position:absolute;left:-5000px" aria-hidden="true"><input type="text" name="b_83b0498b1e7fa3c91ce68c3f1_ecc82e0493" tabindex="-1" value=""/></div><div class="newsletter_root__uh6MU"><input class="newsletter_input___SMSB" id="mce-EMAIL" type="email" name="EMAIL" placeholder="Your email" aria-label="Your email"/><button class="newsletter_button__gKW8E" id="mc-embedded-subscribe" type="submit" name="subscribe">Sign up</button></div></form></li></ul></section></div><div class="footer_content__LaE1F footer_copy__rbjvc"><span>© 2016-<!-- -->2023<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai">Explosion</a></span><a class="link_root__1Me7D footer_logo__BthsJ link_no-link-layout__RPvod" aria-label="Explosion" href="https://explosion.ai"></a><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/legal">Legal / Imprint</a></div></footer></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Layers and Model Architectures","teaser":"Power spaCy components with custom neural networks","menu":[["Type Signatures","type-sigs"],["Swapping Architectures","swap-architectures"],["PyTorch \u0026 TensorFlow","frameworks"],["Custom Thinc Models","thinc"],["Trainable Components","components"]],"next":{"slug":"/usage/projects","title":"spaCy Projects"},"slug":"/usage/layers-architectures","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    pre: \"pre\",\n    code: \"code\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h2: \"h2\",\n    del: \"del\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    em: \"em\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\",\n    img: \"img\"\n  }, _provideComponents(), props.components), {InlineCode, Accordion, Image, Infobox, Project, YouTube} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Image) _missingMdxReference(\"Image\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Project) _missingMdxReference(\"Project\", true);\n  if (!YouTube) _missingMdxReference(\"YouTube\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.section, {\n      children: [_jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from thinc.api import Model, chain\\n\\n@spacy.registry.architectures(\\\"model.v1\\\")\\ndef build_model(width: int, classes: int) -\u003e Model:\\n    tok2vec = build_tok2vec(width)\\n    output_layer = build_output_layer(width, classes)\\n    model = chain(tok2vec, output_layer)\\n    return model\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"model architecture\"\n        }), \" is a function that wires up a\\n\", _jsxs(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: [\"Thinc \", _jsx(InlineCode, {\n            children: \"Model\"\n          })]\n        }), \" instance. It describes the\\nneural network that is run internally as part of a component in a spaCy\\npipeline. To define the actual architecture, you can implement your logic in\\nThinc directly, or you can use Thinc as a thin wrapper around frameworks such as\\nPyTorch, TensorFlow and MXNet. Each \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" can also be used as a sublayer of a\\nlarger network, allowing you to freely combine implementations from different\\nframeworks into a single model.\"]\n      }), _jsxs(_components.p, {\n        children: [\"spaCy’s built-in components require a \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" instance to be passed to them via\\nthe config system. To change the model architecture of an existing component,\\nyou just need to \", _jsx(_components.a, {\n          href: \"#swap-architectures\",\n          children: _jsx(_components.strong, {\n            children: \"update the config\"\n          })\n        }), \" so that it refers\\nto a different registered function. Once the component has been created from\\nthis config, you won’t be able to change it anymore. The architecture is like a\\nrecipe for the network, and you can’t change the recipe once the dish has\\nalready been prepared. You have to make a new one.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[components.tagger]\\nfactory = \\\"tagger\\\"\\n\\n[components.tagger.model]\\n@architectures = \\\"model.v1\\\"\\nwidth = 512\\nclasses = 16\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-type-sigs\",\n      children: [_jsx(_components.h2, {\n        id: \"type-sigs\",\n        children: \"Type signatures \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from typing import List\\nfrom thinc.api import Model, chain\\nfrom thinc.types import Floats2d\\ndef chain_model(\\n    tok2vec: Model[List[Doc], List[Floats2d]],\\n    layer1: Model[List[Floats2d], Floats2d],\\n    layer2: Model[Floats2d, Floats2d]\\n) -\u003e Model[List[Doc], Floats2d]:\\n    model = chain(tok2vec, layer1, layer2)\\n    return model\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"The Thinc \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" class is a \", _jsx(_components.strong, {\n          children: \"generic type\"\n        }), \" that can specify its input and\\noutput types. Python uses a square-bracket notation for this, so the type\\n\", _jsx(_components.del, {\n          children: \"Model[List, Dict]\"\n        }), \" says that each batch of inputs to the model will be a\\nlist, and the outputs will be a dictionary. You can be even more specific and\\nwrite for instance\", _jsx(_components.del, {\n          children: \"Model[List[Doc], Dict[str, float]]\"\n        }), \" to specify that the\\nmodel expects a list of \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" objects as input, and returns a\\ndictionary mapping of strings to floats. Some of the most common types you’ll\\nsee are: ​\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Type\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"List[Doc]\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects. Most components expect their models to take this as input.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"Floats2d\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A two-dimensional \", _jsx(InlineCode, {\n                children: \"numpy\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"cupy\"\n              }), \" array of floats. Usually 32-bit.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"Ints2d\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A two-dimensional \", _jsx(InlineCode, {\n                children: \"numpy\"\n              }), \" or \", _jsx(InlineCode, {\n                children: \"cupy\"\n              }), \" array of integers. Common dtypes include uint64, int32 and int8.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"List[Floats2d]\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"A list of two-dimensional arrays, generally with one array per \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" and one row per token.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"Ragged\"\n              })\n            }), _jsx(_components.td, {\n              children: \"A container to handle variable-length sequence data in an unpadded contiguous array.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.del, {\n                children: \"Padded\"\n              })\n            }), _jsx(_components.td, {\n              children: \"A container to handle variable-length sequence data in a padded contiguous array.\"\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"See the \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-types\",\n          children: \"Thinc type reference\"\n        }), \" for details. The\\nmodel type signatures help you figure out which model architectures and\\ncomponents can \", _jsx(_components.strong, {\n          children: \"fit together\"\n        }), \". For instance, the\\n\", _jsx(_components.a, {\n          href: \"/api/textcategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"TextCategorizer\"\n          })\n        }), \" class expects a model typed\\n\", _jsx(_components.del, {\n          children: \"Model[List[Doc], Floats2d]\"\n        }), \", because the model will predict one row of\\ncategory probabilities per \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \". In contrast, the\\n\", _jsx(_components.a, {\n          href: \"/api/tagger\",\n          children: _jsx(InlineCode, {\n            children: \"Tagger\"\n          })\n        }), \" class expects a model typed \", _jsx(_components.del, {\n          children: \"Model[List[Doc],\\nList[Floats2d]]\"\n        }), \", because it needs to predict one row of probabilities per\\ntoken.\"]\n      }), _jsxs(_components.p, {\n        children: [\"There’s no guarantee that two models with the same type signature can be used\\ninterchangeably. There are many other ways they could be incompatible. However,\\nif the types don’t match, they almost surely \", _jsx(_components.em, {\n          children: \"won’t\"\n        }), \" be compatible. This little\\nbit of validation goes a long way, especially if you\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-type-checking\",\n          children: \"configure your editor\"\n        }), \" or other\\ntools to highlight these errors early. The config file is also validated at the\\nbeginning of training, to verify that all the types match correctly.\"]\n      }), _jsxs(Accordion, {\n        title: \"Tip: Static type checking in your editor\",\n        children: [_jsxs(_components.p, {\n          children: [\"If you’re using a modern editor like Visual Studio Code, you can\\n\", _jsxs(_components.a, {\n            href: \"https://thinc.ai/docs/usage-type-checking#install\",\n            children: [\"set up \", _jsx(InlineCode, {\n              children: \"mypy\"\n            })]\n          }), \" with the\\ncustom Thinc plugin and get live feedback about mismatched types as you write\\ncode.\"]\n        }), _jsx(Image, {\n          src: \"/images/thinc_mypy.jpg\",\n          href: \"https://thinc.ai/docs/usage-type-checking#linting\",\n          alt: \"Screenshot of Thinc type checking in VSCode with mypy\"\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-swap-architectures\",\n      children: [_jsx(_components.h2, {\n        id: \"swap-architectures\",\n        children: \"Swapping model architectures \"\n      }), _jsxs(_components.p, {\n        children: [\"If no model is specified for the \", _jsx(_components.a, {\n          href: \"/api/textcategorizer\",\n          children: _jsx(InlineCode, {\n            children: \"TextCategorizer\"\n          })\n        }), \", the\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TextCatEnsemble\",\n          children: \"TextCatEnsemble\"\n        }), \" architecture is used by\\ndefault. This architecture combines a simple bag-of-words model with a neural\\nnetwork, usually resulting in the most accurate results, but at the cost of\\nspeed. The config file for this model would look something like this:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[components.textcat]\\nfactory = \\\"textcat\\\"\\nlabels = []\\n\\n[components.textcat.model]\\n@architectures = \\\"spacy.TextCatEnsemble.v2\\\"\\nnO = null\\n\\n[components.textcat.model.tok2vec]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[components.textcat.model.tok2vec.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\nwidth = 64\\nrows = [2000, 2000, 1000, 1000, 1000, 1000]\\nattrs = [\\\"ORTH\\\", \\\"LOWER\\\", \\\"PREFIX\\\", \\\"SUFFIX\\\", \\\"SHAPE\\\", \\\"ID\\\"]\\ninclude_static_vectors = false\\n\\n[components.textcat.model.tok2vec.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\nwidth = ${components.textcat.model.tok2vec.embed.width}\\nwindow_size = 1\\nmaxout_pieces = 3\\ndepth = 2\\n\\n[components.textcat.model.linear_model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = true\\nngram_size = 1\\nno_output_layer = false\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"spaCy has two additional built-in \", _jsx(InlineCode, {\n          children: \"textcat\"\n        }), \" architectures, and you can easily\\nuse those by swapping out the definition of the textcat’s model. For instance,\\nto use the simple and fast bag-of-words model\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#TextCatBOW\",\n          children: \"TextCatBOW\"\n        }), \", you can change the config to:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          highlight: \"6-10\",\n          children: \"[components.textcat]\\nfactory = \\\"textcat\\\"\\nlabels = []\\n\\n[components.textcat.model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = true\\nngram_size = 1\\nno_output_layer = false\\nnO = null\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"For details on all pre-defined architectures shipped with spaCy and how to\\nconfigure them, check out the \", _jsx(_components.a, {\n          href: \"/api/architectures\",\n          children: \"model architectures\"\n        }), \"\\ndocumentation.\"]\n      }), _jsx(_components.h3, {\n        id: \"sublayers\",\n        children: \"Defining sublayers \"\n      }), _jsxs(_components.p, {\n        children: [\"Model architecture functions often accept \", _jsx(_components.strong, {\n          children: \"sublayers as arguments\"\n        }), \", so that\\nyou can try \", _jsx(_components.strong, {\n          children: \"substituting a different layer\"\n        }), \" into the network. Depending on\\nhow the architecture function is structured, you might be able to define your\\nnetwork structure entirely through the \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config system\"\n        }), \",\\nusing layers that have already been defined. ​\"]\n      }), _jsxs(_components.p, {\n        children: [\"In most neural network models for NLP, the most important parts of the network\\nare what we refer to as the\\n\", _jsx(_components.a, {\n          href: \"https://explosion.ai/blog/deep-learning-formula-nlp\",\n          children: \"embed and encode\"\n        }), \" steps.\\nThese steps together compute dense, context-sensitive representations of the\\ntokens, and their combination forms a typical\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#Tok2Vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" layer:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[components.tok2vec]\\nfactory = \\\"tok2vec\\\"\\n\\n[components.tok2vec.model]\\n@architectures = \\\"spacy.Tok2Vec.v2\\\"\\n\\n[components.tok2vec.model.embed]\\n@architectures = \\\"spacy.MultiHashEmbed.v2\\\"\\n# ...\\n\\n[components.tok2vec.model.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\n# ...\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"By defining these sublayers specifically, it becomes straightforward to swap out\\na sublayer for another one, for instance changing the first sublayer to a\\ncharacter embedding with the \", _jsx(_components.a, {\n          href: \"/api/architectures#CharacterEmbed\",\n          children: \"CharacterEmbed\"\n        }), \"\\narchitecture:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[components.tok2vec.model.embed]\\n@architectures = \\\"spacy.CharacterEmbed.v2\\\"\\n# ...\\n\\n[components.tok2vec.model.encode]\\n@architectures = \\\"spacy.MaxoutWindowEncoder.v2\\\"\\n# ...\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Most of spaCy’s default architectures accept a \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" layer as a sublayer\\nwithin the larger task-specific neural network. This makes it easy to \", _jsx(_components.strong, {\n          children: \"switch\\nbetween\"\n        }), \" transformer, CNN, BiLSTM or other feature extraction approaches. The\\n\", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers#training-custom-model\",\n          children: \"transformers documentation\"\n        }), \"\\nsection shows an example of swapping out a model’s standard \", _jsx(InlineCode, {\n          children: \"tok2vec\"\n        }), \" layer with\\na transformer. And if you want to define your own solution, all you need to do\\nis register a \", _jsx(_components.del, {\n          children: \"Model[List[Doc], List[Floats2d]]\"\n        }), \" architecture function, and\\nyou’ll be able to try it out in any of the spaCy components. ​\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-frameworks\",\n      children: [_jsx(_components.h2, {\n        id: \"frameworks\",\n        children: \"Wrapping PyTorch, TensorFlow and other frameworks \"\n      }), _jsxs(_components.p, {\n        children: [\"Thinc allows you to \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-frameworks\",\n          children: \"wrap models\"\n        }), \"\\nwritten in other machine learning frameworks like PyTorch, TensorFlow and MXNet\\nusing a unified \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" API. This makes it\\neasy to use a model implemented in a different framework to power a component in\\nyour spaCy pipeline. For example, to wrap a PyTorch model as a Thinc \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \",\\nyou can use Thinc’s\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#pytorchwrapper\",\n          children: _jsx(InlineCode, {\n            children: \"PyTorchWrapper\"\n          })\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from thinc.api import PyTorchWrapper\\n\\nwrapped_pt_model = PyTorchWrapper(torch_model)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Let’s use PyTorch to define a very simple neural network consisting of two\\nhidden \", _jsx(InlineCode, {\n          children: \"Linear\"\n        }), \" layers with \", _jsx(InlineCode, {\n          children: \"ReLU\"\n        }), \" activation and dropout, and a\\nsoftmax-activated output layer:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"PyTorch model\",\n          children: \"from torch import nn\\n\\ntorch_model = nn.Sequential(\\n    nn.Linear(width, hidden_width),\\n    nn.ReLU(),\\n    nn.Dropout2d(dropout),\\n    nn.Linear(hidden_width, nO),\\n    nn.ReLU(),\\n    nn.Dropout2d(dropout),\\n    nn.Softmax(dim=1)\\n)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The resulting wrapped \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" can be used as a \", _jsx(_components.strong, {\n          children: \"custom architecture\"\n        }), \" as such,\\nor can be a \", _jsx(_components.strong, {\n          children: \"subcomponent of a larger model\"\n        }), \". For instance, we can use Thinc’s\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#chain\",\n          children: _jsx(InlineCode, {\n            children: \"chain\"\n          })\n        }), \" combinator, which works like\\n\", _jsx(InlineCode, {\n          children: \"Sequential\"\n        }), \" in PyTorch, to combine the wrapped model with other components in a\\nlarger network. This effectively means that you can easily wrap different\\ncomponents from different frameworks, and “glue” them together with Thinc:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from thinc.api import chain, with_array, PyTorchWrapper\\nfrom spacy.ml import CharacterEmbed\\n\\nwrapped_pt_model = PyTorchWrapper(torch_model)\\nchar_embed = CharacterEmbed(width, embed_size, nM, nC)\\nmodel = chain(char_embed, with_array(wrapped_pt_model))\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In the above example, we have combined our custom PyTorch model with a character\\nembedding layer defined by spaCy.\\n\", _jsx(_components.a, {\n          href: \"/api/architectures#CharacterEmbed\",\n          children: \"CharacterEmbed\"\n        }), \" returns a \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" that takes\\na \", _jsx(_components.del, {\n          children: \"List[Doc]\"\n        }), \" as input, and outputs a \", _jsx(_components.del, {\n          children: \"List[Floats2d]\"\n        }), \". To make sure that\\nthe wrapped PyTorch model receives valid inputs, we use Thinc’s\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#with_array\",\n          children: _jsx(InlineCode, {\n            children: \"with_array\"\n          })\n        }), \" helper.\"]\n      }), _jsx(_components.p, {\n        children: \"You could also implement a model that only uses PyTorch for the transformer\\nlayers, and “native” Thinc layers to do fiddly input and output transformations\\nand add on task-specific “heads”, as efficiency is less of a consideration for\\nthose parts of the network.\"\n      }), _jsx(_components.h3, {\n        id: \"frameworks-usage\",\n        children: \"Using wrapped models \"\n      }), _jsxs(_components.p, {\n        children: [\"To use our custom model including the PyTorch subnetwork, all we need to do is\\nregister the architecture using the\\n\", _jsxs(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: [_jsx(InlineCode, {\n            children: \"architectures\"\n          }), \" registry\"]\n        }), \". This assigns the\\narchitecture a name so spaCy knows how to find it, and allows passing in\\narguments like hyperparameters via the \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config\"\n        }), \". The\\nfull example then becomes:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Registering the architecture\",\n          highlight: \"9\",\n          children: \"from typing import List\\nfrom thinc.types import Floats2d\\nfrom thinc.api import Model, PyTorchWrapper, chain, with_array\\nimport spacy\\nfrom spacy.tokens.doc import Doc\\nfrom spacy.ml import CharacterEmbed\\nfrom torch import nn\\n\\n@spacy.registry.architectures(\\\"CustomTorchModel.v1\\\")\\ndef create_torch_model(\\n    nO: int,\\n    width: int,\\n    hidden_width: int,\\n    embed_size: int,\\n    nM: int,\\n    nC: int,\\n    dropout: float,\\n) -\u003e Model[List[Doc], List[Floats2d]]:\\n    char_embed = CharacterEmbed(width, embed_size, nM, nC)\\n    torch_model = nn.Sequential(\\n        nn.Linear(width, hidden_width),\\n        nn.ReLU(),\\n        nn.Dropout2d(dropout),\\n        nn.Linear(hidden_width, nO),\\n        nn.ReLU(),\\n        nn.Dropout2d(dropout),\\n        nn.Softmax(dim=1)\\n    )\\n    wrapped_pt_model = PyTorchWrapper(torch_model)\\n    model = chain(char_embed, with_array(wrapped_pt_model))\\n    return model\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"The model definition can now be used in any existing trainable spaCy component,\\nby specifying it in the config file. In this configuration, all required\\nparameters for the various subcomponents of the custom architecture are passed\\nin as settings via the config.\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          highlight: \"5-5\",\n          children: \"[components.tagger]\\nfactory = \\\"tagger\\\"\\n\\n[components.tagger.model]\\n@architectures = \\\"CustomTorchModel.v1\\\"\\nnO = 50\\nwidth = 96\\nhidden_width = 48\\nembed_size = 2000\\nnM = 64\\nnC = 8\\ndropout = 0.2\\n\"\n        })\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsx(_components.p, {\n          children: \"Remember that it is best not to rely on any (hidden) default values to ensure\\nthat training configs are complete and experiments fully reproducible.\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Note that when using a PyTorch or Tensorflow model, it is recommended to set the\\nGPU memory allocator accordingly. When \", _jsx(InlineCode, {\n          children: \"gpu_allocator\"\n        }), \" is set to “pytorch” or\\n“tensorflow” in the training config, cupy will allocate memory via those\\nrespective libraries, preventing OOM errors when there’s available memory\\nsitting in the other library’s pool.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-ini\",\n          lang: \"ini\",\n          title: \"config.cfg (excerpt)\",\n          children: \"[training]\\ngpu_allocator = \\\"pytorch\\\"\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-thinc\",\n      children: [_jsx(_components.h2, {\n        id: \"thinc\",\n        children: \"Custom models with Thinc \"\n      }), _jsxs(_components.p, {\n        children: [\"Of course it’s also possible to define the \", _jsx(InlineCode, {\n          children: \"Model\"\n        }), \" from the previous section\\nentirely in Thinc. The Thinc documentation provides details on the\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers\",\n          children: \"various layers\"\n        }), \" and helper functions\\navailable. Combinators can be used to\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#operators\",\n          children: \"overload operators\"\n        }), \" and a common\\nusage pattern is to bind \", _jsx(InlineCode, {\n          children: \"chain\"\n        }), \" to \", _jsx(InlineCode, {\n          children: \"\u003e\u003e\"\n        }), \". The “native” Thinc version of our\\nsimple neural network would then become:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"from thinc.api import chain, with_array, Model, Relu, Dropout, Softmax\\nfrom spacy.ml import CharacterEmbed\\n\\nchar_embed = CharacterEmbed(width, embed_size, nM, nC)\\nwith Model.define_operators({\\\"\u003e\u003e\\\": chain}):\\n    layers = (\\n        Relu(hidden_width, width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Relu(hidden_width, hidden_width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Softmax(nO, hidden_width)\\n    )\\n    model = char_embed \u003e\u003e with_array(layers)\\n\"\n        })\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note on inputs and outputs\",\n        children: _jsxs(_components.p, {\n          children: [\"Note that Thinc layers define the output dimension (\", _jsx(InlineCode, {\n            children: \"nO\"\n          }), \") as the first argument,\\nfollowed (optionally) by the input dimension (\", _jsx(InlineCode, {\n            children: \"nI\"\n          }), \"). This is in contrast to how\\nthe PyTorch layers are defined, where \", _jsx(InlineCode, {\n            children: \"in_features\"\n          }), \" precedes \", _jsx(InlineCode, {\n            children: \"out_features\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"thinc-shape-inference\",\n        children: \"Shape inference in Thinc \"\n      }), _jsxs(_components.p, {\n        children: [\"It is \", _jsx(_components.strong, {\n          children: \"not\"\n        }), \" strictly necessary to define all the input and output dimensions\\nfor each layer, as Thinc can perform\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#validation\",\n          children: \"shape inference\"\n        }), \" between\\nsequential layers by matching up the output dimensionality of one layer to the\\ninput dimensionality of the next. This means that we can simplify the \", _jsx(InlineCode, {\n          children: \"layers\"\n        }), \"\\ndefinition:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Diff\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"layers = (\\n    Relu(hidden_width, width)\\n    \u003e\u003e Dropout(dropout)\\n-   \u003e\u003e Relu(hidden_width, hidden_width)\\n+    \u003e\u003e Relu(hidden_width)\\n    \u003e\u003e Dropout(dropout)\\n-   \u003e\u003e Softmax(nO, hidden_width)\\n+   \u003e\u003e Softmax(nO)\\n)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"with Model.define_operators({\\\"\u003e\u003e\\\": chain}):\\n    layers = (\\n        Relu(hidden_width, width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Relu(hidden_width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Softmax(nO)\\n    )\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Thinc can even go one step further and \", _jsx(_components.strong, {\n          children: \"deduce the correct input dimension\"\n        }), \" of\\nthe first layer, and output dimension of the last. To enable this functionality,\\nyou have to call\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Model.initialize\"\n          })\n        }), \" with an \", _jsx(_components.strong, {\n          children: \"input\\nsample\"\n        }), \" \", _jsx(InlineCode, {\n          children: \"X\"\n        }), \" and an \", _jsx(_components.strong, {\n          children: \"output sample\"\n        }), \" \", _jsx(InlineCode, {\n          children: \"Y\"\n        }), \" with the correct dimensions:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Shape inference with initialization\",\n          highlight: \"3,7,10\",\n          children: \"with Model.define_operators({\\\"\u003e\u003e\\\": chain}):\\n    layers = (\\n        Relu(hidden_width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Relu(hidden_width)\\n        \u003e\u003e Dropout(dropout)\\n        \u003e\u003e Softmax()\\n    )\\n    model = char_embed \u003e\u003e with_array(layers)\\n    model.initialize(X=input_sample, Y=output_sample)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The built-in \", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines\",\n          children: \"pipeline components\"\n        }), \" in spaCy ensure\\nthat their internal models are \", _jsx(_components.strong, {\n          children: \"always initialized\"\n        }), \" with appropriate sample\\ndata. In this case, \", _jsx(InlineCode, {\n          children: \"X\"\n        }), \" is typically a \", _jsx(_components.del, {\n          children: \"List[Doc]\"\n        }), \", while \", _jsx(InlineCode, {\n          children: \"Y\"\n        }), \" is typically a\\n\", _jsx(_components.del, {\n          children: \"List[Array1d]\"\n        }), \" or \", _jsx(_components.del, {\n          children: \"List[Array2d]\"\n        }), \", depending on the specific task. This\\nfunctionality is triggered when \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" is\\ncalled.\"]\n      }), _jsx(_components.h3, {\n        id: \"thinc-dropout-norm\",\n        children: \"Dropout and normalization in Thinc \"\n      }), _jsxs(_components.p, {\n        children: [\"Many of the available Thinc \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers\",\n          children: \"layers\"\n        }), \" allow you\\nto define a \", _jsx(InlineCode, {\n          children: \"dropout\"\n        }), \" argument that will result in “chaining” an additional\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#dropout\",\n          children: _jsx(InlineCode, {\n            children: \"Dropout\"\n          })\n        }), \" layer. Optionally, you can\\noften specify whether or not you want to add layer normalization, which would\\nresult in an additional\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#layernorm\",\n          children: _jsx(InlineCode, {\n            children: \"LayerNorm\"\n          })\n        }), \" layer. That means that\\nthe following \", _jsx(InlineCode, {\n          children: \"layers\"\n        }), \" definition is equivalent to the previous:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"with Model.define_operators({\\\"\u003e\u003e\\\": chain}):\\n    layers = (\\n        Relu(hidden_width, dropout=dropout, normalize=False)\\n        \u003e\u003e Relu(hidden_width, dropout=dropout, normalize=False)\\n        \u003e\u003e Softmax()\\n    )\\n    model = char_embed \u003e\u003e with_array(layers)\\n    model.initialize(X=input_sample, Y=output_sample)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-components\",\n      children: [_jsx(_components.h2, {\n        id: \"components\",\n        children: \"Create new trainable components \"\n      }), _jsxs(_components.p, {\n        children: [\"In addition to \", _jsx(_components.a, {\n          href: \"#swap-architectures\",\n          children: \"swapping out\"\n        }), \" layers in existing\\ncomponents, you can also implement an entirely new,\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#trainable-components\",\n          children: \"trainable\"\n        }), \" pipeline component\\nfrom scratch. This can be done by creating a new class inheriting from\\n\", _jsx(_components.a, {\n          href: \"/api/pipe\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe\"\n          })\n        }), \", and linking it up to your custom model\\nimplementation.\"]\n      }), _jsx(Infobox, {\n        title: \"Trainable component API\",\n        emoji: \"💡\",\n        children: _jsxs(_components.p, {\n          children: [\"For details on how to implement pipeline components, check out the usage guide\\non \", _jsx(_components.a, {\n            href: \"/usage/processing-pipelines#custom-component\",\n            children: \"custom components\"\n          }), \" and the\\noverview of the \", _jsx(InlineCode, {\n            children: \"TrainablePipe\"\n          }), \" methods used by\\n\", _jsx(_components.a, {\n            href: \"/usage/processing-pipelines#trainable-components\",\n            children: \"trainable components\"\n          }), \".\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"component-rel\",\n        children: \"Example: Entity relation extraction component \"\n      }), _jsxs(_components.p, {\n        children: [\"This section outlines an example use-case of implementing a \", _jsx(_components.strong, {\n          children: \"novel relation\\nextraction component\"\n        }), \" from scratch. We’ll implement a binary relation\\nextraction method that determines whether or not \", _jsx(_components.strong, {\n          children: \"two entities\"\n        }), \" in a document\\nare related, and if so, what type of relation connects them. We allow multiple\\ntypes of relations between two such entities (a multi-label setting). There are\\ntwo major steps required:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Implement a \", _jsx(_components.a, {\n            href: \"#component-rel-model\",\n            children: \"machine learning model\"\n          }), \" specific to this\\ntask. It will have to extract candidate relation instances from a\\n\", _jsx(_components.a, {\n            href: \"/api/doc\",\n            children: _jsx(InlineCode, {\n              children: \"Doc\"\n            })\n          }), \" and predict the corresponding scores for each relation\\nlabel.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Implement a custom \", _jsx(_components.a, {\n            href: \"#component-rel-pipe\",\n            children: \"pipeline component\"\n          }), \" - powered by the\\nmachine learning model from step 1 - that translates the predicted scores\\ninto annotations that are stored on the \", _jsx(_components.a, {\n            href: \"/api/doc\",\n            children: _jsx(InlineCode, {\n              children: \"Doc\"\n            })\n          }), \" objects as they\\npass through the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" pipeline.\"]\n        }), \"\\n\"]\n      }), _jsx(Project, {\n        id: \"tutorials/rel_component\",\n        children: _jsx(_components.p, {\n          children: \"Run this example use-case by using our project template. It includes all the\\ncode to create the ML model and the pipeline component from scratch. It also\\ncontains two config files to train the model: one to run on CPU with a Tok2Vec\\nlayer, and one for the GPU using a transformer. The project applies the\\nrelation extraction component to identify biomolecular interactions in a\\nsample dataset, but you can easily swap in your own dataset for your\\nexperiments in any other domain.\"\n        })\n      }), _jsx(YouTube, {\n        id: \"8HL-Ap5_Axo\"\n      }), _jsx(_components.h4, {\n        id: \"component-rel-model\",\n        children: \"Step 1: Implementing the Model \"\n      }), _jsxs(_components.p, {\n        children: [\"We need to implement a \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" that takes a\\n\", _jsx(_components.strong, {\n          children: \"list of documents\"\n        }), \" (\", _jsx(_components.del, {\n          children: \"List[Doc]\"\n        }), \") as input, and outputs a \", _jsx(_components.strong, {\n          children: \"two-dimensional\\nmatrix\"\n        }), \" (\", _jsx(_components.del, {\n          children: \"Floats2d\"\n        }), \") of predictions:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Model type annotations\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"Model\"\n          }), \" class is a generic type that can specify its input and output\\ntypes, e.g. \", _jsx(_components.del, {\n            children: \"Model[List[Doc], Floats2d]\"\n          }), \". Type hints are used for static\\ntype checks and validation. See the section on \", _jsx(_components.a, {\n            href: \"#type-sigs\",\n            children: \"type signatures\"\n          }), \"\\nfor details.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The model architecture\",\n          children: \"@spacy.registry.architectures(\\\"rel_model.v1\\\")\\ndef create_relation_model(...) -\u003e Model[List[Doc], Floats2d]:\\n    model = ...  # 👈 model will go here\\n    return model\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"We adapt a \", _jsx(_components.strong, {\n          children: \"modular approach\"\n        }), \" to the definition of this relation model, and\\ndefine it as chaining two layers together: the first layer that generates an\\ninstance tensor from a given set of documents, and the second layer that\\ntransforms the instance tensor into a final tensor holding the predictions:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model]\\n@architectures = \\\"rel_model.v1\\\"\\n\\n[model.create_instance_tensor]\\n# ...\\n\\n[model.classification_layer]\\n# ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The model architecture\",\n          highlight: \"6\",\n          children: \"@spacy.registry.architectures(\\\"rel_model.v1\\\")\\ndef create_relation_model(\\n    create_instance_tensor: Model[List[Doc], Floats2d],\\n    classification_layer: Model[Floats2d, Floats2d],\\n) -\u003e Model[List[Doc], Floats2d]:\\n    model = chain(create_instance_tensor, classification_layer)\\n    return model\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"classification_layer\"\n        }), \" could be something like a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#linear\",\n          children: \"Linear\"\n        }), \" layer followed by a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#logistic\",\n          children: \"logistic\"\n        }), \" activation function:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model.classification_layer]\\n@architectures = \\\"rel_classification_layer.v1\\\"\\nnI = null\\nnO = null\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The classification layer\",\n          children: \"@spacy.registry.architectures(\\\"rel_classification_layer.v1\\\")\\ndef create_classification_layer(\\n    nO: int = None, nI: int = None\\n) -\u003e Model[Floats2d, Floats2d]:\\n    return chain(Linear(nO=nO, nI=nI), Logistic())\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The first layer that \", _jsx(_components.strong, {\n          children: \"creates the instance tensor\"\n        }), \" can be defined by\\nimplementing a\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#weights-layers-forward\",\n          children: \"custom forward function\"\n        }), \"\\nwith an appropriate backpropagation callback. We also define an\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#weights-layers-init\",\n          children: \"initialization method\"\n        }), \"\\nthat ensures that the layer is properly set up for training.\"]\n      }), _jsxs(_components.p, {\n        children: [\"We omit some of the implementation details here, and refer to the\\n\", _jsx(_components.a, {\n          href: \"https://github.com/explosion/projects/tree/v3/tutorials/rel_component\",\n          children: \"spaCy project\"\n        }), \"\\nthat has the full implementation.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[model.create_instance_tensor]\\n@architectures = \\\"rel_instance_tensor.v1\\\"\\n\\n[model.create_instance_tensor.tok2vec]\\n@architectures = \\\"spacy.HashEmbedCNN.v2\\\"\\n# ...\\n\\n[model.create_instance_tensor.pooling]\\n@layers = \\\"reduce_mean.v1\\\"\\n\\n[model.create_instance_tensor.get_instances]\\n# ...\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The layer that creates the instance tensor\",\n          children: \"@spacy.registry.architectures(\\\"rel_instance_tensor.v1\\\")\\ndef create_tensors(\\n    tok2vec: Model[List[Doc], List[Floats2d]],\\n    pooling: Model[Ragged, Floats2d],\\n    get_instances: Callable[[Doc], List[Tuple[Span, Span]]],\\n) -\u003e Model[List[Doc], Floats2d]:\\n\\n    return Model(\\n        \\\"instance_tensors\\\",\\n        instance_forward,\\n        init=instance_init,\\n        layers=[tok2vec, pooling],\\n        refs={\\\"tok2vec\\\": tok2vec, \\\"pooling\\\": pooling},\\n        attrs={\\\"get_instances\\\": get_instances},\\n    )\\n\\n\\n# The custom forward function\\ndef instance_forward(\\n    model: Model[List[Doc], Floats2d],\\n    docs: List[Doc],\\n    is_train: bool,\\n) -\u003e Tuple[Floats2d, Callable]:\\n    tok2vec = model.get_ref(\\\"tok2vec\\\")\\n    tokvecs, bp_tokvecs = tok2vec(docs, is_train)\\n    get_instances = model.attrs[\\\"get_instances\\\"]\\n    all_instances = [get_instances(doc) for doc in docs]\\n    pooling = model.get_ref(\\\"pooling\\\")\\n    relations = ...\\n\\n    def backprop(d_relations: Floats2d) -\u003e List[Doc]:\\n        d_tokvecs = ...\\n        return bp_tokvecs(d_tokvecs)\\n\\n    return relations, backprop\\n\\n\\n# The custom initialization method\\ndef instance_init(\\n    model: Model,\\n    X: List[Doc] = None,\\n    Y: Floats2d = None,\\n) -\u003e Model:\\n    tok2vec = model.get_ref(\\\"tok2vec\\\")\\n    tok2vec.initialize(X)\\n    return model\\n\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"This custom layer uses an \", _jsx(_components.a, {\n          href: \"/usage/embeddings-transformers\",\n          children: \"embedding layer\"\n        }), \" such\\nas a \", _jsx(_components.a, {\n          href: \"/api/tok2vec\",\n          children: _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          })\n        }), \" component or a \", _jsx(_components.a, {\n          href: \"/api/transformer\",\n          children: _jsx(InlineCode, {\n            children: \"Transformer\"\n          })\n        }), \".\\nThis layer is assumed to be of type \", _jsx(_components.del, {\n          children: \"Model[List[Doc], List[Floats2d]]\"\n        }), \" as it\\ntransforms each \", _jsx(_components.strong, {\n          children: \"document into a list of tokens\"\n        }), \", with each token being\\nrepresented by its embedding in the vector space.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"pooling\"\n        }), \" layer will be applied to summarize the token vectors into \", _jsx(_components.strong, {\n          children: \"entity\\nvectors\"\n        }), \", as named entities (represented by \", _jsx(_components.del, {\n          children: \"Span\"\n        }), \" objects) can consist of\\none or multiple tokens. For instance, the pooling layer could resort to\\ncalculating the average of all token vectors in an entity. Thinc provides\\nseveral\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-layers#reduction-ops\",\n          children: \"built-in pooling operators\"\n        }), \" for\\nthis purpose.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Finally, we need a \", _jsx(InlineCode, {\n          children: \"get_instances\"\n        }), \" method that \", _jsx(_components.strong, {\n          children: \"generates pairs of entities\"\n        }), \"\\nthat we want to classify as being related or not. As these candidate pairs are\\ntypically formed within one document, this function takes a \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" as\\ninput and outputs a \", _jsx(InlineCode, {\n          children: \"List\"\n        }), \" of \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" tuples. For instance, the following\\nimplementation takes any two entities from the same document, as long as they\\nare within a \", _jsx(_components.strong, {\n          children: \"maximum distance\"\n        }), \" (in number of tokens) of each other:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"\\n[model.create_instance_tensor.get_instances]\\n@misc = \\\"rel_instance_generator.v1\\\"\\nmax_length = 100\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Candidate generation\",\n          children: \"@spacy.registry.misc(\\\"rel_instance_generator.v1\\\")\\ndef create_instances(max_length: int) -\u003e Callable[[Doc], List[Tuple[Span, Span]]]:\\n    def get_candidates(doc: \\\"Doc\\\") -\u003e List[Tuple[Span, Span]]:\\n        candidates = []\\n        for ent1 in doc.ents:\\n            for ent2 in doc.ents:\\n                if ent1 != ent2:\\n                    if max_length and abs(ent2.start - ent1.start) \u003c= max_length:\\n                        candidates.append((ent1, ent2))\\n        return candidates\\n    return get_candidates\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"This function is added to the \", _jsxs(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: [_jsx(InlineCode, {\n            children: \"@misc\"\n          }), \" registry\"]\n        }), \" so we\\ncan refer to it from the config, and easily swap it out for any other candidate\\ngeneration function.\"]\n      }), _jsx(_components.h4, {\n        id: \"component-rel-attribute\",\n        children: \"Intermezzo: define how to store the relations data \"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example output\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"Amsterdam is the capital of the Netherlands.\\\")\\nprint(\\\"spans\\\", [(e.start, e.text, e.label_) for e in doc.ents])\\nfor value, rel_dict in doc._.rel.items():\\n    print(f\\\"{value}: {rel_dict}\\\")\\n\\n# spans [(0, 'Amsterdam', 'LOC'), (6, 'Netherlands', 'LOC')]\\n# (0, 6): {'CAPITAL_OF': 0.89, 'LOCATED_IN': 0.75, 'UNRELATED': 0.002}\\n# (6, 0): {'CAPITAL_OF': 0.01, 'LOCATED_IN': 0.13, 'UNRELATED': 0.017}\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"For our new relation extraction component, we will use a custom\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-attributes\",\n          children: \"extension attribute\"\n        }), \"\\n\", _jsx(InlineCode, {\n          children: \"doc._.rel\"\n        }), \" in which we store relation data. The attribute refers to a\\ndictionary, keyed by the \", _jsx(_components.strong, {\n          children: \"start offsets of each entity\"\n        }), \" involved in the\\ncandidate relation. The values in the dictionary refer to another dictionary\\nwhere relation labels are mapped to values between 0 and 1. We assume anything\\nabove 0.5 to be a \", _jsx(InlineCode, {\n          children: \"True\"\n        }), \" relation. The \", _jsx(_components.del, {\n          children: \"Example\"\n        }), \" instances that we’ll use as\\ntraining data, will include their gold-standard relation annotations in\\n\", _jsx(InlineCode, {\n          children: \"example.reference._.rel\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Registering the extension attribute\",\n          children: \"from spacy.tokens import Doc\\nDoc.set_extension(\\\"rel\\\", default={})\\n\"\n        })\n      }), _jsx(_components.h4, {\n        id: \"component-rel-pipe\",\n        children: \"Step 2: Implementing the pipeline component \"\n      }), _jsxs(_components.p, {\n        children: [\"To use our new relation extraction model as part of a custom\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#trainable-components\",\n          children: \"trainable component\"\n        }), \", we\\ncreate a subclass of \", _jsx(_components.a, {\n          href: \"/api/pipe\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe\"\n          })\n        }), \" that holds the model.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/trainable_component.svg\",\n        alt: \"Illustration of Pipe methods\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Pipeline component skeleton\",\n          children: \"from spacy.pipeline import TrainablePipe\\n\\nclass RelationExtractor(TrainablePipe):\\n     def __init__(self, vocab, model, name=\\\"rel\\\"):\\n        \\\"\\\"\\\"Create a component instance.\\\"\\\"\\\"\\n        self.model = model\\n        self.vocab = vocab\\n        self.name = name\\n\\n    def update(self, examples, drop=0.0, sgd=None, losses=None):\\n        \\\"\\\"\\\"Learn from a batch of Example objects.\\\"\\\"\\\"\\n        ...\\n\\n    def predict(self, docs):\\n        \\\"\\\"\\\"Apply the model to a batch of Doc objects.\\\"\\\"\\\"\\n        ...\\n\\n    def set_annotations(self, docs, predictions):\\n        \\\"\\\"\\\"Modify a batch of Doc objects using the predictions.\\\"\\\"\\\"\\n         ...\\n\\n    def initialize(self, get_examples, nlp=None, labels=None):\\n        \\\"\\\"\\\"Initialize the model before training.\\\"\\\"\\\"\\n        ...\\n\\n    def add_label(self, label):\\n        \\\"\\\"\\\"Add a label to the component.\\\"\\\"\\\"\\n        ...\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Typically, the \", _jsx(_components.strong, {\n          children: \"constructor\"\n        }), \" defines the vocab, the Machine Learning model,\\nand the name of this component. Additionally, this component, just like the\\n\", _jsx(InlineCode, {\n          children: \"textcat\"\n        }), \" and the \", _jsx(InlineCode, {\n          children: \"tagger\"\n        }), \", stores an \", _jsx(_components.strong, {\n          children: \"internal list of labels\"\n        }), \". The ML model\\nwill predict scores for each label. We add convenience methods to easily\\nretrieve and add to them.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The constructor (continued)\",\n          children: \"    def __init__(self, vocab, model, name=\\\"rel\\\"):\\n        \\\"\\\"\\\"Create a component instance.\\\"\\\"\\\"\\n        # ...\\n        self.cfg = {\\\"labels\\\": []}\\n\\n    @property\\n    def labels(self) -\u003e Tuple[str, ...]:\\n        \\\"\\\"\\\"Returns the labels currently added to the component.\\\"\\\"\\\"\\n        return tuple(self.cfg[\\\"labels\\\"])\\n\\n    def add_label(self, label: str):\\n        \\\"\\\"\\\"Add a new label to the pipe.\\\"\\\"\\\"\\n        self.cfg[\\\"labels\\\"] = list(self.labels) + [label]\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"After creation, the component needs to be\\n\", _jsx(_components.a, {\n          href: \"/usage/training#initialization\",\n          children: \"initialized\"\n        }), \". This method can define the\\nrelevant labels in two ways: explicitely by setting the \", _jsx(InlineCode, {\n          children: \"labels\"\n        }), \" argument in the\\n\", _jsxs(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: [_jsx(InlineCode, {\n            children: \"initialize\"\n          }), \" block\"]\n        }), \" of the config, or\\nimplicately by deducing them from the \", _jsx(InlineCode, {\n          children: \"get_examples\"\n        }), \" callback that generates the\\nfull \", _jsx(_components.strong, {\n          children: \"training data set\"\n        }), \", or a representative sample.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The final number of labels defines the output dimensionality of the network, and\\nwill be used to do\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-models#validation\",\n          children: \"shape inference\"\n        }), \" throughout the\\nlayers of the neural network. This is triggered by calling\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/api/model#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"Model.initialize\"\n          })\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The initialize method\",\n          highlight: \"12,15,18,22\",\n          children: \"from itertools import islice\\n\\ndef initialize(\\n    self,\\n    get_examples: Callable[[], Iterable[Example]],\\n    *,\\n    nlp: Language = None,\\n    labels: Optional[List[str]] = None,\\n):\\n    if labels is not None:\\n        for label in labels:\\n            self.add_label(label)\\n    else:\\n        for example in get_examples():\\n            relations = example.reference._.rel\\n            for indices, label_dict in relations.items():\\n                for label in label_dict.keys():\\n                    self.add_label(label)\\n    subbatch = list(islice(get_examples(), 10))\\n    doc_sample = [eg.reference for eg in subbatch]\\n    label_sample = self._examples_to_truth(subbatch)\\n    self.model.initialize(X=doc_sample, Y=label_sample)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"initialize\"\n        }), \" method is triggered whenever this component is part of an \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\npipeline, and \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" is invoked.\\nTypically, this happens when the pipeline is set up before training in\\n\", _jsx(_components.a, {\n          href: \"/api/cli#training\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \". After initialization, the pipeline component\\nand its internal model can be trained and used to make predictions.\"]\n      }), _jsxs(_components.p, {\n        children: [\"During training, the method \", _jsx(_components.a, {\n          href: \"/api/pipe#update\",\n          children: _jsx(InlineCode, {\n            children: \"update\"\n          })\n        }), \" is invoked which\\ndelegates to\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model#begin_update\",\n          children: _jsx(InlineCode, {\n            children: \"Model.begin_update\"\n          })\n        }), \" and a\\n\", _jsx(_components.a, {\n          href: \"/api/pipe#get_loss\",\n          children: _jsx(InlineCode, {\n            children: \"get_loss\"\n          })\n        }), \" function that \", _jsx(_components.strong, {\n          children: \"calculates the loss\"\n        }), \" for a\\nbatch of examples, as well as the \", _jsx(_components.strong, {\n          children: \"gradient\"\n        }), \" of loss that will be used to\\nupdate the weights of the model layers. Thinc provides several\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-loss\",\n          children: \"loss functions\"\n        }), \" that can be used for the\\nimplementation of the \", _jsx(InlineCode, {\n          children: \"get_loss\"\n        }), \" function.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The update method\",\n          highlight: \"12-14\",\n          children: \"def update(\\n    self,\\n    examples: Iterable[Example],\\n    *,\\n    drop: float = 0.0,\\n    sgd: Optional[Optimizer] = None,\\n    losses: Optional[Dict[str, float]] = None,\\n) -\u003e Dict[str, float]:\\n    # ...\\n    docs = [eg.predicted for eg in examples]\\n    predictions, backprop = self.model.begin_update(docs)\\n    loss, gradient = self.get_loss(examples, predictions)\\n    backprop(gradient)\\n    losses[self.name] += loss\\n    # ...\\n    return losses\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"After training the model, the component can be used to make novel\\n\", _jsx(_components.strong, {\n          children: \"predictions\"\n        }), \". The \", _jsx(_components.a, {\n          href: \"/api/pipe#predict\",\n          children: _jsx(InlineCode, {\n            children: \"predict\"\n          })\n        }), \" method needs to be\\nimplemented for each subclass of \", _jsx(InlineCode, {\n          children: \"TrainablePipe\"\n        }), \". In our case, we can simply\\ndelegate to the internal model’s\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model#predict\",\n          children: \"predict\"\n        }), \" function that takes a batch\\nof \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects and returns a \", _jsx(_components.del, {\n          children: \"Floats2d\"\n        }), \" array:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The predict method\",\n          children: \"def predict(self, docs: Iterable[Doc]) -\u003e Floats2d:\\n    predictions = self.model.predict(docs)\\n    return self.model.ops.asarray(predictions)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The final method that needs to be implemented, is\\n\", _jsx(_components.a, {\n          href: \"/api/pipe#set_annotations\",\n          children: _jsx(InlineCode, {\n            children: \"set_annotations\"\n          })\n        }), \". This function takes the\\npredictions, and modifies the given \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object in place to store them. For our\\nrelation extraction component, we store the data in the\\n\", _jsx(_components.a, {\n          href: \"#component-rel-attribute\",\n          children: \"custom attribute\"\n        }), _jsx(InlineCode, {\n          children: \"doc._.rel\"\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"To interpret the scores predicted by the relation extraction model correctly, we\\nneed to refer to the model’s \", _jsx(InlineCode, {\n          children: \"get_instances\"\n        }), \" function that defined which pairs\\nof entities were relevant candidates, so that the predictions can be linked to\\nthose exact entities:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The set_annotations method\",\n          highlight: \"5-6,10\",\n          children: \"def set_annotations(self, docs: Iterable[Doc], predictions: Floats2d):\\n    c = 0\\n    get_instances = self.model.attrs[\\\"get_instances\\\"]\\n    for doc in docs:\\n        for (e1, e2) in get_instances(doc):\\n            offset = (e1.start, e2.start)\\n            if offset not in doc._.rel:\\n                doc._.rel[offset] = {}\\n            for j, label in enumerate(self.labels):\\n                doc._.rel[offset][label] = predictions[c, j]\\n            c += 1\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Under the hood, when the pipe is applied to a document, it delegates to the\\n\", _jsx(InlineCode, {\n          children: \"predict\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"set_annotations\"\n        }), \" methods:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The __call__ method\",\n          children: \"def __call__(self, doc: Doc):\\n    predictions = self.predict([doc])\\n    self.set_annotations([doc], predictions)\\n    return doc\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"There is one more optional method to implement: \", _jsx(_components.a, {\n          href: \"/api/pipe#score\",\n          children: _jsx(InlineCode, {\n            children: \"score\"\n          })\n        }), \"\\ncalculates the performance of your component on a set of examples, and returns\\nthe results as a dictionary:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The score method\",\n          children: \"def score(self, examples: Iterable[Example]) -\u003e Dict[str, Any]:\\n    prf = PRFScore()\\n    for example in examples:\\n        ...\\n\\n    return {\\n        \\\"rel_micro_p\\\": prf.precision,\\n        \\\"rel_micro_r\\\": prf.recall,\\n        \\\"rel_micro_f\\\": prf.fscore,\\n    }\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"This is particularly useful for calculating relevant scores on the development\\ncorpus when training the component with \", _jsx(_components.a, {\n          href: \"/api/cli#training\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"Once our \", _jsx(InlineCode, {\n          children: \"TrainablePipe\"\n        }), \" subclass is fully implemented, we can\\n\", _jsx(_components.a, {\n          href: \"/usage/processing-pipelines#custom-components-factories\",\n          children: \"register\"\n        }), \" the\\ncomponent with the \", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \" decorator. This\\nassigns it a name and lets you create the component with\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" and via the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"config\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.relation_extractor]\\nfactory = \\\"relation_extractor\\\"\\n\\n[components.relation_extractor.model]\\n@architectures = \\\"rel_model.v1\\\"\\n# ...\\n\\n[training.score_weights]\\nrel_micro_p = 0.0\\nrel_micro_r = 0.0\\nrel_micro_f = 1.0\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Registering the pipeline component\",\n          children: \"from spacy.language import Language\\n\\n@Language.factory(\\\"relation_extractor\\\")\\ndef make_relation_extractor(nlp, name, model):\\n    return RelationExtractor(nlp.vocab, model, name)\\n\"\n        })\n      }), _jsx(_components.p, {\n        children: \"You can extend the decorator to include information such as the type of\\nannotations that are required for this component to run, the type of annotations\\nit produces, and the scores that can be calculated:\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Factory annotations\",\n          highlight: \"5-11\",\n          children: \"from spacy.language import Language\\n\\n@Language.factory(\\n    \\\"relation_extractor\\\",\\n    requires=[\\\"doc.ents\\\", \\\"token.ent_iob\\\", \\\"token.ent_type\\\"],\\n    assigns=[\\\"doc._.rel\\\"],\\n    default_score_weights={\\n        \\\"rel_micro_p\\\": None,\\n        \\\"rel_micro_r\\\": None,\\n        \\\"rel_micro_f\\\": None,\\n    },\\n)\\ndef make_relation_extractor(nlp, name, model):\\n    return RelationExtractor(nlp.vocab, model, name)\\n\"\n        })\n      }), _jsx(Project, {\n        id: \"tutorials/rel_component\",\n        children: _jsx(_components.p, {\n          children: \"Run this example use-case by using our project template. It includes all the\\ncode to create the ML model and the pipeline component from scratch. It\\ncontains two config files to train the model: one to run on CPU with a Tok2Vec\\nlayer, and one for the GPU using a transformer. The project applies the\\nrelation extraction component to identify biomolecular interactions, but you\\ncan easily swap in your own dataset for your experiments in any other domain.\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Layers and Model Architectures","teaser":"Power spaCy components with custom neural networks","menu":[["Type Signatures","type-sigs"],["Swapping Architectures","swap-architectures"],["PyTorch \u0026 TensorFlow","frameworks"],["Custom Thinc Models","thinc"],["Trainable Components","components"]],"next":"/usage/projects"},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true},"page":"/[...listPathPage]","query":{"listPathPage":["usage","layers-architectures"]},"buildId":"2lY2cUyEfZosk4VLgkHb2","isFallback":false,"dynamicIds":[728],"gsp":true,"scriptLoader":[]}</script></body></html>