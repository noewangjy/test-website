<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="shortcut icon" href="/icons/icon-192x192.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=5.0, shrink-to-fit=no, viewport-fit=cover"/><meta name="theme-color" content="#09a3d5"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title>Language Processing Pipelines · spaCy Usage Documentation</title><meta name="description" content="spaCy is a free open-source library for Natural Language Processing in Python. It features NER, POS tagging, dependency parsing, word vectors and more."/><meta property="og:title" content="Language Processing Pipelines · spaCy Usage Documentation"/><meta property="og:description" content="spaCy is a free open-source library for Natural Language Processing in Python. It features NER, POS tagging, dependency parsing, word vectors and more."/><meta property="og:type" content="website"/><meta property="og:site_name" content="Language Processing Pipelines"/><meta property="og:image" content="https://noewangjy.github.io/test-website//_next/static/media/social_default.96b04585.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://noewangjy.github.io/test-website//_next/static/media/social_default.96b04585.jpg"/><meta name="twitter:creator" content="@spacy_io"/><meta name="twitter:site" content="@spacy_io"/><meta name="twitter:title" content="Language Processing Pipelines · spaCy Usage Documentation"/><meta name="twitter:description" content="spaCy is a free open-source library for Natural Language Processing in Python. It features NER, POS tagging, dependency parsing, word vectors and more."/><meta name="docsearch:language" content="en"/><meta name="next-head-count" content="24"/><link rel="preload" href="/_next/static/css/8f0b94edbc18d62d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8f0b94edbc18d62d.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e6995e0e8addcf99.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e6995e0e8addcf99.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script defer="" src="/_next/static/chunks/262.c647d33d06232ef6.js"></script><script defer="" src="/_next/static/chunks/728.cf6ba0da2700fa1b.js"></script><script defer="" src="/_next/static/chunks/4ad82c5e.9f71e347f3d5ee0a.js"></script><script defer="" src="/_next/static/chunks/fec483df.e5c4c2e1905c02db.js"></script><script defer="" src="/_next/static/chunks/d9c63220.b8e7d78d95edcd53.js"></script><script defer="" src="/_next/static/chunks/876.15142163f03ee62c.js"></script><script defer="" src="/_next/static/chunks/661.267b5ccf1a1d90d0.js"></script><script defer="" src="/_next/static/chunks/492.0a716e87ad804aae.js"></script><script src="/_next/static/chunks/webpack-8161fc2bb14cec39.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-a0f603ce323043fd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ee1fab0e25bb912e.js" defer=""></script><script src="/_next/static/chunks/94-57434c8b7a6c3878.js" defer=""></script><script src="/_next/static/chunks/128-76b45627a109219b.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...listPathPage%5D-45eea57fe8c2902c.js" defer=""></script><script src="/_next/static/2lY2cUyEfZosk4VLgkHb2/_buildManifest.js" defer=""></script><script src="/_next/static/2lY2cUyEfZosk4VLgkHb2/_ssgManifest.js" defer=""></script></head><body class="theme-blue"><div id="__next"><div class="theme-blue"><nav class="navigation_root__yPL8O"><span class="navigation_has-alert__s0Drf"><a class="link_root__1Me7D link_no-link-layout__RPvod" aria-label="spaCy" href="/"><h1 class="navigation_title__pm49s">spaCy</h1></a> <span class="navigation_alert__ZOXon"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/usage/v3-5"><strong>💥 Out now:</strong> spaCy v3.5</a></span></span><div class="navigation_menu__ZMJxN"><select class="dropdown_root__3uiQq navigation_dropdown__4j4pI"><option value="title" disabled="">Menu</option><option value="/usage" selected="">Usage</option><option value="/models">Models</option><option value="/api">API</option><option value="/universe">Universe</option></select><ul class="navigation_list__DCzqi"><li class="navigation_item__ln1O1 navigation_is-active__RjVJG"><a class="link_root__1Me7D link_no-link-layout__RPvod" tabindex="-1" href="/usage">Usage</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/models">Models</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/api">API</a></li><li class="navigation_item__ln1O1"><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/universe">Universe</a></li><li class="navigation_item__ln1O1 navigation_github__MpFNv"><span><a href="https://github.com/explosion/spaCy" data-size="large" data-show-count="true" aria-label="Star spaCy on GitHub"></a></span></li></ul><div class="navigation_search__BKZCn"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div><progress class="progress_root__9huWN" value="0" max="100"></progress></nav><menu class="sidebar sidebar_root__s2No7"><h1 hidden="" aria-hidden="true" class="h0 sidebar_active-heading___dkf9">Guides</h1><div class="sidebar_dropdown__vyqjz"><select class="dropdown_root__3uiQq sidebar_dropdown-select__Nwbq9"><option disabled="">Select page...</option><option value="/usage">Get started<!-- --> › <!-- -->Installation</option><option value="/usage/models">Get started<!-- --> › <!-- -->Models &amp; Languages</option><option value="/usage/facts-figures">Get started<!-- --> › <!-- -->Facts &amp; Figures</option><option value="/usage/spacy-101">Get started<!-- --> › <!-- -->spaCy 101</option><option value="/usage/v3">Get started<!-- --> › <!-- -->New in v3.0</option><option value="/usage/v3-1">Get started<!-- --> › <!-- -->New in v3.1</option><option value="/usage/v3-2">Get started<!-- --> › <!-- -->New in v3.2</option><option value="/usage/v3-3">Get started<!-- --> › <!-- -->New in v3.3</option><option value="/usage/v3-4">Get started<!-- --> › <!-- -->New in v3.4</option><option value="/usage/v3-5">Get started<!-- --> › <!-- -->New in v3.5</option><option value="/usage/linguistic-features">Guides<!-- --> › <!-- -->Linguistic Features</option><option value="/usage/rule-based-matching">Guides<!-- --> › <!-- -->Rule-based Matching</option><option value="/usage/processing-pipelines" selected="">Guides<!-- --> › <!-- -->Processing Pipelines</option><option value="/usage/embeddings-transformers">Guides<!-- --> › <!-- -->Embeddings &amp; Transformers</option><option value="/usage/training">Guides<!-- --> › <!-- -->Training Models</option><option value="/usage/layers-architectures">Guides<!-- --> › <!-- -->Layers &amp; Model Architectures</option><option value="/usage/projects">Guides<!-- --> › <!-- -->spaCy Projects</option><option value="/usage/saving-loading">Guides<!-- --> › <!-- -->Saving &amp; Loading</option><option value="/usage/visualizers">Guides<!-- --> › <!-- -->Visualizers</option><option value="https://github.com/explosion/projects">Resources<!-- --> › <!-- -->Project Templates</option><option value="https://v2.spacy.io">Resources<!-- --> › <!-- -->v2.x Documentation</option><option value="https://explosion.ai/custom-solutions">Resources<!-- --> › <!-- -->Custom Solutions</option></select></div><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Get started</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage">Installation</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/models">Models &amp; Languages</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/facts-figures">Facts &amp; Figures</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/spacy-101">spaCy 101</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3">New in v3.0</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-1">New in v3.1</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-2">New in v3.2</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-3">New in v3.3</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-4">New in v3.4</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/v3-5">New in v3.5</a></li></ul><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Guides</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/linguistic-features">Linguistic Features</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/rule-based-matching">Rule-based Matching</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP sidebar_is-active__yVTtL is-active" href="/usage/processing-pipelines">Processing Pipelines</a><ul class="sidebar_crumbs__NhM2y"><li class="sidebar_crumb__tiiDl sidebar_crumb-active__zq8BI"><a href="#processing">Processing Text</a></li><li class="sidebar_crumb__tiiDl"><a href="#pipelines">Pipelines &amp; Components</a></li><li class="sidebar_crumb__tiiDl"><a href="#custom-components">Custom Components</a></li><li class="sidebar_crumb__tiiDl"><a href="#component-data">Component Data</a></li><li class="sidebar_crumb__tiiDl"><a href="#type-hints">Type Hints &amp; Validation</a></li><li class="sidebar_crumb__tiiDl"><a href="#trainable-components">Trainable Components</a></li><li class="sidebar_crumb__tiiDl"><a href="#custom-components-attributes">Extension Attributes</a></li><li class="sidebar_crumb__tiiDl"><a href="#plugins">Plugins &amp; Wrappers</a></li></ul></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/embeddings-transformers">Embeddings &amp; Transformers<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/training">Training Models<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/layers-architectures">Layers &amp; Model Architectures<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/projects">spaCy Projects<span class="tag_root__NTSnK tag_spaced__Q9amH">new</span></a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/saving-loading">Saving &amp; Loading</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="/usage/visualizers">Visualizers</a></li></ul><ul class="sidebar_section__DArOO"><li class="sidebar_label__V3K28">Resources</li><li><a class="link_root__1Me7D sidebar_link__sKXFP" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/projects">Project Templates</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="https://v2.spacy.io">v2.x Documentation</a></li><li><a class="link_root__1Me7D sidebar_link__sKXFP" href="https://explosion.ai/custom-solutions">Custom Solutions</a></li></ul></menu><main class="main_root__7f6Tj main_with-sidebar__uH1df main_with-asides__ikQT6"><article class="main_content__8zFCH"><header class="title_root__pS2WQ"><h1 id="_title" class="typography_heading__D82WZ typography_h1__b7dt9 title_h1__l3CW1"><span class="heading-text">Language Processing Pipelines<!-- --> </span></h1></header><section class="section_root__k1hUl"><p>When you call <code class="code_inline-code__Bq7ot">nlp</code> on a text, spaCy first tokenizes the text to produce a <code class="code_inline-code__Bq7ot">Doc</code>
object. The <code class="code_inline-code__Bq7ot">Doc</code> is then processed in several different steps – this is also
referred to as the <strong>processing pipeline</strong>. The pipeline used by the
<a class="link_root__1Me7D" href="/models">trained pipelines</a> typically include a tagger, a lemmatizer, a parser
and an entity recognizer. Each pipeline component returns the processed <code class="code_inline-code__Bq7ot">Doc</code>,
which is then passed on to the next component.</p>
<figure class="gatsby-resp-image-figure"><img class="embed_image__mSQUH" src="/images/pipeline.svg" alt="The processing pipeline" width="650" height="auto"/></figure>
<aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<ul class="list_ul__fe_HF">
<li class="list_li__sfx_z"><strong>Name</strong>: ID of the pipeline component.</li>
<li class="list_li__sfx_z"><strong>Component:</strong> spaCy’s implementation of the component.</li>
<li class="list_li__sfx_z"><strong>Creates:</strong> Objects, attributes and properties modified and set by the
component.</li>
</ul>
</div></div></aside>
<table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Name</th><th class="table_th__QJ9F8">Component</th><th class="table_th__QJ9F8">Creates</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>tokenizer</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tokenizer"><code class="code_inline-code__Bq7ot">Tokenizer</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Doc</code></td><td class="table_td__rmpJx">Segment text into tokens.</td></tr><tr class="table_tr__K_tkF table_divider__DRQHe"><td class="table_td__rmpJx"><em>processing pipeline</em></td><td class="table_td__rmpJx"></td><td class="table_td__rmpJx"></td><td class="table_td__rmpJx"></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>tagger</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tagger"><code class="code_inline-code__Bq7ot">Tagger</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Token.tag</code></td><td class="table_td__rmpJx">Assign part-of-speech tags.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>parser</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/dependencyparser"><code class="code_inline-code__Bq7ot">DependencyParser</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Token.head</code>, <code class="code_inline-code__Bq7ot">Token.dep</code>, <code class="code_inline-code__Bq7ot">Doc.sents</code>, <code class="code_inline-code__Bq7ot">Doc.noun_chunks</code></td><td class="table_td__rmpJx">Assign dependency labels.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>ner</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entityrecognizer"><code class="code_inline-code__Bq7ot">EntityRecognizer</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Doc.ents</code>, <code class="code_inline-code__Bq7ot">Token.ent_iob</code>, <code class="code_inline-code__Bq7ot">Token.ent_type</code></td><td class="table_td__rmpJx">Detect and label named entities.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>lemmatizer</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/lemmatizer"><code class="code_inline-code__Bq7ot">Lemmatizer</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Token.lemma</code></td><td class="table_td__rmpJx">Assign base forms.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>textcat</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/textcategorizer"><code class="code_inline-code__Bq7ot">TextCategorizer</code></a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Doc.cats</code></td><td class="table_td__rmpJx">Assign document labels.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><strong>custom</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components">custom components</a></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">Doc._.xxx</code>, <code class="code_inline-code__Bq7ot">Token._.xxx</code>, <code class="code_inline-code__Bq7ot">Span._.xxx</code></td><td class="table_td__rmpJx">Assign custom attributes, methods or properties.</td></tr></tbody></table>
<p>The capabilities of a processing pipeline always depend on the components, their
models and how they were trained. For example, a pipeline for named entity
recognition needs to include a trained named entity recognizer component with a
statistical model and weights that enable it to <strong>make predictions</strong> of entity
labels. This is why each pipeline specifies its components and their settings in
the <a class="link_root__1Me7D" href="/usage/training#config">config</a>:</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
<section class="accordion" id="pipeline-components-order"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Does the order of pipeline components matter?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#pipeline-components-order">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>The statistical components like the tagger or parser are typically independent
and don’t share any data between each other. For example, the named entity
recognizer doesn’t use any features set by the tagger and parser, and so on.
This means that you can swap them, or remove single components from the pipeline
without affecting the others. However, components may share a “token-to-vector”
component like <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tok2vec"><code class="code_inline-code__Bq7ot">Tok2Vec</code></a> or <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/transformer"><code class="code_inline-code__Bq7ot">Transformer</code></a>.
You can read more about this in the docs on
<a class="link_root__1Me7D" href="/usage/embeddings-transformers#embedding-layers">embedding layers</a>.</p><p>Custom components may also depend on annotations set by other components. For
example, a custom lemmatizer may need the part-of-speech tags assigned, so it’ll
only work if it’s added after the tagger. The parser will respect pre-defined
sentence boundaries, so if a previous component in the pipeline sets them, its
dependency predictions may be different. Similarly, it matters if you add the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entityruler"><code class="code_inline-code__Bq7ot">EntityRuler</code></a> before or after the statistical entity
recognizer: if it’s added before, the entity recognizer will take the existing
entities into account when making predictions. The
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entitylinker"><code class="code_inline-code__Bq7ot">EntityLinker</code></a>, which resolves named entities to knowledge
base IDs, should be preceded by a pipeline component that recognizes entities
such as the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entityrecognizer"><code class="code_inline-code__Bq7ot">EntityRecognizer</code></a>.</p></div></div></section>
<section class="accordion" id="pipeline-components-tokenizer"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Why is the tokenizer special?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#pipeline-components-tokenizer">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>The tokenizer is a “special” component and isn’t part of the regular pipeline.
It also doesn’t show up in <code class="code_inline-code__Bq7ot">nlp.pipe_names</code>. The reason is that there can only
really be one tokenizer, and while all other pipeline components take a <code class="code_inline-code__Bq7ot">Doc</code>
and return it, the tokenizer takes a <strong>string of text</strong> and turns it into a
<code class="code_inline-code__Bq7ot">Doc</code>. You can still customize the tokenizer, though. <code class="code_inline-code__Bq7ot">nlp.tokenizer</code> is
writable, so you can either create your own
<a class="link_root__1Me7D" href="/usage/linguistic-features#native-tokenizers"><code class="code_inline-code__Bq7ot">Tokenizer</code> class from scratch</a>,
or even replace it with an
<a class="link_root__1Me7D" href="/usage/linguistic-features#custom-tokenizer">entirely custom function</a>.</p></div></div></section>
<hr class="section_hr__07Hes"/></section>
<section id="section-processing" class="section_root__k1hUl"><h2 id="processing" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#processing" class="heading-text typography_permalink__UiIRy">Processing text <!-- --> </a></h2><p>When you call <code class="code_inline-code__Bq7ot">nlp</code> on a text, spaCy will <strong>tokenize</strong> it and then <strong>call each
component</strong> on the <code class="code_inline-code__Bq7ot">Doc</code>, in order. It then returns the processed <code class="code_inline-code__Bq7ot">Doc</code> that you
can work with.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>When processing large volumes of text, the statistical models are usually more
efficient if you let them work on batches of texts. spaCy’s
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a> method takes an iterable of texts and yields
processed <code class="code_inline-code__Bq7ot">Doc</code> objects. The batching is done internally.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">💡</span>Tips for efficient processing</span></h4><ul class="list_ul__fe_HF">
<li class="list_li__sfx_z">Process the texts <strong>as a stream</strong> using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a> and
buffer them in batches, instead of one-by-one. This is usually much more
efficient.</li>
<li class="list_li__sfx_z">Only apply the <strong>pipeline components you need</strong>. Getting predictions from the
model that you don’t actually need adds up and becomes very inefficient at
scale. To prevent this, use the <code class="code_inline-code__Bq7ot">disable</code> keyword argument to disable
components you don’t need – either when loading a pipeline, or during
processing with <code class="code_inline-code__Bq7ot">nlp.pipe</code>. See the section on
<a class="link_root__1Me7D" href="/usage/processing-pipelines#disabling">disabling pipeline components</a> for more details and examples.</li>
</ul></aside><p>In this example, we’re using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a> to process a
(potentially very large) iterable of texts as a stream. Because we’re only
accessing the named entities in <code class="code_inline-code__Bq7ot">doc.ents</code> (set by the <code class="code_inline-code__Bq7ot">ner</code> component), we’ll
disable all other components during processing. <code class="code_inline-code__Bq7ot">nlp.pipe</code> yields <code class="code_inline-code__Bq7ot">Doc</code> objects,
so we can iterate over them and access the named entity predictions:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Also disable the <code class="code_inline-code__Bq7ot">&quot;ner&quot;</code> component. You’ll see that the <code class="code_inline-code__Bq7ot">doc.ents</code> are now
empty, because the entity recognizer didn’t run.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Important note</span></h4><p>When using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a>, keep in mind that it returns a
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://realpython.com/introduction-to-python-generators/">generator</a> that
yields <code class="code_inline-code__Bq7ot">Doc</code> objects – not a list. So if you want to use it like a list, you’ll
have to call <code class="code_inline-code__Bq7ot">list()</code> on it first:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre></aside><p>You can use the <code class="code_inline-code__Bq7ot">as_tuples</code> option to pass additional context along with each
doc when using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a>. If <code class="code_inline-code__Bq7ot">as_tuples</code> is <code class="code_inline-code__Bq7ot">True</code>, then
the input should be a sequence of <code class="code_inline-code__Bq7ot">(text, context)</code> tuples and the output will
be a sequence of <code class="code_inline-code__Bq7ot">(doc, context)</code> tuples. For example, you can pass metadata in
the context and save it in a <a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-attributes">custom attribute</a>:</p><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><h3 id="multiprocessing" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#multiprocessing" class="heading-text typography_permalink__UiIRy">Multiprocessing <!-- --> </a></h3><p>spaCy includes built-in support for multiprocessing with
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a> using the <code class="code_inline-code__Bq7ot">n_process</code> option:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>Depending on your platform, starting many processes with multiprocessing can add
a lot of overhead. In particular, the default start method <code class="code_inline-code__Bq7ot">spawn</code> used in
macOS/OS X (as of Python 3.8) and in Windows can be slow for larger models
because the model data is copied in memory for each new process. See the
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods">Python docs on multiprocessing</a>
for further details.</p><p>For shorter tasks and in particular with <code class="code_inline-code__Bq7ot">spawn</code>, it can be faster to use a
smaller number of processes with a larger batch size. The optimal <code class="code_inline-code__Bq7ot">batch_size</code>
setting will depend on the pipeline components, the length of your documents,
the number of processes and how much memory is available.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Multiprocessing on GPU</span></h4><p>Multiprocessing is not generally recommended on GPU because RAM is too limited.
If you want to try it out, be aware that it is only possible using <code class="code_inline-code__Bq7ot">spawn</code> due
to limitations in CUDA.</p></aside><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Multiprocessing with transformer models</span></h4><p>In Linux, transformer models may hang or deadlock with multiprocessing due to an
<a class="link_root__1Me7D link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/pytorch/pytorch/issues/17199"><span class="link_source-text__VDP74">issue in PyTorch</span></a>. One
suggested workaround is to use <code class="code_inline-code__Bq7ot">spawn</code> instead of <code class="code_inline-code__Bq7ot">fork</code> and another is to limit
the number of threads before loading any models using
<code class="code_inline-code__Bq7ot">torch.set_num_threads(1)</code>.</p></aside></section>
<section id="section-pipelines" class="section_root__k1hUl"><h2 id="pipelines" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#pipelines" class="heading-text typography_permalink__UiIRy">Pipelines and built-in components <!-- --> </a></h2><p>spaCy makes it very easy to create your own pipelines consisting of reusable
components – this includes spaCy’s default tagger, parser and entity recognizer,
but also your own custom processing functions. A pipeline component can be added
to an already existing <code class="code_inline-code__Bq7ot">nlp</code> object, specified when initializing a
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language"><code class="code_inline-code__Bq7ot">Language</code></a> class, or defined within a
<a class="link_root__1Me7D" href="/usage/saving-loading#models">pipeline package</a>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg (excerpt)<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><p>When you load a pipeline, spaCy first consults the
<a class="link_root__1Me7D" href="/usage/saving-loading#models"><code class="code_inline-code__Bq7ot">meta.json</code></a> and
<a class="link_root__1Me7D" href="/usage/training#config"><code class="code_inline-code__Bq7ot">config.cfg</code></a>. The config tells spaCy what language
class to use, which components are in the pipeline, and how those components
should be created. spaCy will then do the following:</p><ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Load the <strong>language class and data</strong> for the given ID via
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#util.get_lang_class"><code class="code_inline-code__Bq7ot">get_lang_class</code></a> and initialize it. The
<code class="code_inline-code__Bq7ot">Language</code> class contains the shared vocabulary, tokenization rules and the
language-specific settings.</li>
<li class="list_li__sfx_z">Iterate over the <strong>pipeline names</strong> and look up each component name in the
<code class="code_inline-code__Bq7ot">[components]</code> block. The <code class="code_inline-code__Bq7ot">factory</code> tells spaCy which
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-factories">component factory</a> to use for adding the
component with <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">add_pipe</code></a>. The settings are passed
into the factory.</li>
<li class="list_li__sfx_z">Make the <strong>model data</strong> available to the <code class="code_inline-code__Bq7ot">Language</code> class by calling
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#from_disk"><code class="code_inline-code__Bq7ot">from_disk</code></a> with the path to the data directory.</li>
</ol><p>So when you call this…</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>… the pipeline’s <code class="code_inline-code__Bq7ot">config.cfg</code> tells spaCy to use the language <code class="code_inline-code__Bq7ot">&quot;en&quot;</code> and the
pipeline
<code class="code_inline-code__Bq7ot code_wrap__b41os">[&quot;tok2vec&quot;, &quot;tagger&quot;, &quot;parser&quot;, &quot;ner&quot;, &quot;attribute_ruler&quot;, &quot;lemmatizer&quot;]</code>. spaCy
will then initialize <code class="code_inline-code__Bq7ot">spacy.lang.en.English</code>, and create each pipeline component
and add it to the processing pipeline. It’ll then load in the model data from
the data directory and return the modified <code class="code_inline-code__Bq7ot">Language</code> class for you to use as
the <code class="code_inline-code__Bq7ot">nlp</code> object.</p><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Changed in v3.0</span></h4><p>spaCy v3.0 introduces a <code class="code_inline-code__Bq7ot">config.cfg</code>, which includes more detailed settings for
the pipeline, its components and the <a class="link_root__1Me7D" href="/usage/training#config">training process</a>.
You can export the config of your current <code class="code_inline-code__Bq7ot">nlp</code> object by calling
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#config"><code class="code_inline-code__Bq7ot">nlp.config.to_disk</code></a>.</p></aside><p>Fundamentally, a <a class="link_root__1Me7D" href="/models">spaCy pipeline package</a> consists of three components:
<strong>the weights</strong>, i.e. binary data loaded in from a directory, a <strong>pipeline</strong> of
functions called in order, and <strong>language data</strong> like the tokenization rules and
language-specific settings. For example, a Spanish NER pipeline requires
different weights, language data and components than an English parsing and
tagging pipeline. This is also why the pipeline state is always held by the
<code class="code_inline-code__Bq7ot">Language</code> class. <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#spacy.load"><code class="code_inline-code__Bq7ot">spacy.load</code></a> puts this all
together and returns an instance of <code class="code_inline-code__Bq7ot">Language</code> with a pipeline set and access to
the binary data:</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">spacy.load under the hood</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>When you call <code class="code_inline-code__Bq7ot">nlp</code> on a text, spaCy will <strong>tokenize</strong> it and then <strong>call each
component</strong> on the <code class="code_inline-code__Bq7ot">Doc</code>, in order. Since the model data is loaded, the
components can access it to assign annotations to the <code class="code_inline-code__Bq7ot">Doc</code> object, and
subsequently to the <code class="code_inline-code__Bq7ot">Token</code> and <code class="code_inline-code__Bq7ot">Span</code> which are only views of the <code class="code_inline-code__Bq7ot">Doc</code>, and
don’t own any data themselves. All components return the modified document,
which is then processed by the next component in the pipeline.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">The pipeline under the hood</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>The current processing pipeline is available as <code class="code_inline-code__Bq7ot">nlp.pipeline</code>, which returns a
list of <code class="code_inline-code__Bq7ot">(name, component)</code> tuples, or <code class="code_inline-code__Bq7ot">nlp.pipe_names</code>, which only returns a
list of human-readable component names.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><h3 id="built-in" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#built-in" class="heading-text typography_permalink__UiIRy">Built-in pipeline components <!-- --> </a></h3><p>spaCy ships with several built-in pipeline components that are registered with
string names. This means that you can initialize them by calling
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a> with their names and spaCy will know
how to create them. See the <a class="link_root__1Me7D link_with-icon__NAVDA" href="/api"><span class="link_source-text__VDP74">API documentation</span></a> for a full list of
available pipeline components and component functions.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Usage<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">String name</th><th class="table_th__QJ9F8">Component</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">tagger</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tagger"><code class="code_inline-code__Bq7ot">Tagger</code></a></td><td class="table_td__rmpJx">Assign part-of-speech-tags.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">parser</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/dependencyparser"><code class="code_inline-code__Bq7ot">DependencyParser</code></a></td><td class="table_td__rmpJx">Assign dependency labels.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">ner</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entityrecognizer"><code class="code_inline-code__Bq7ot">EntityRecognizer</code></a></td><td class="table_td__rmpJx">Assign named entities.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">entity_linker</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entitylinker"><code class="code_inline-code__Bq7ot">EntityLinker</code></a></td><td class="table_td__rmpJx">Assign knowledge base IDs to named entities. Should be added after the entity recognizer.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">entity_ruler</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/entityruler"><code class="code_inline-code__Bq7ot">EntityRuler</code></a></td><td class="table_td__rmpJx">Assign named entities based on pattern rules and dictionaries.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">textcat</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/textcategorizer"><code class="code_inline-code__Bq7ot">TextCategorizer</code></a></td><td class="table_td__rmpJx">Assign text categories: exactly one category is predicted per document.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">textcat_multilabel</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/textcategorizer"><code class="code_inline-code__Bq7ot">MultiLabel_TextCategorizer</code></a></td><td class="table_td__rmpJx">Assign text categories in a multi-label setting: zero, one or more labels per document.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">lemmatizer</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/lemmatizer"><code class="code_inline-code__Bq7ot">Lemmatizer</code></a></td><td class="table_td__rmpJx">Assign base forms to words using rules and lookups.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">trainable_lemmatizer</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/edittreelemmatizer"><code class="code_inline-code__Bq7ot">EditTreeLemmatizer</code></a></td><td class="table_td__rmpJx">Assign base forms to words.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">morphologizer</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/morphologizer"><code class="code_inline-code__Bq7ot">Morphologizer</code></a></td><td class="table_td__rmpJx">Assign morphological features and coarse-grained POS tags.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">attribute_ruler</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/attributeruler"><code class="code_inline-code__Bq7ot">AttributeRuler</code></a></td><td class="table_td__rmpJx">Assign token attribute mappings and rule-based exceptions.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">senter</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/sentencerecognizer"><code class="code_inline-code__Bq7ot">SentenceRecognizer</code></a></td><td class="table_td__rmpJx">Assign sentence boundaries.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">sentencizer</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/sentencizer"><code class="code_inline-code__Bq7ot">Sentencizer</code></a></td><td class="table_td__rmpJx">Add rule-based sentence segmentation without the dependency parse.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">tok2vec</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/tok2vec"><code class="code_inline-code__Bq7ot">Tok2Vec</code></a></td><td class="table_td__rmpJx">Assign token-to-vector embeddings.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">transformer</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/transformer"><code class="code_inline-code__Bq7ot">Transformer</code></a></td><td class="table_td__rmpJx">Assign the tokens and outputs of a transformer model.</td></tr></tbody></table><h3 id="disabling" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#disabling" class="heading-text typography_permalink__UiIRy">Disabling, excluding and modifying components <!-- --> </a></h3><p>If you don’t need a particular component of the pipeline – for example, the
tagger or the parser, you can <strong>disable or exclude</strong> it. This can sometimes make
a big difference and improve loading and inference speed. There are two
different mechanisms you can use:</p><ol class="list_ol__aclSa">
<li class="list_li__sfx_z"><strong>Disable:</strong> The component and its data will be loaded with the pipeline, but
it will be disabled by default and not run as part of the processing
pipeline. To run it, you can explicitly enable it by calling
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#enable_pipe"><code class="code_inline-code__Bq7ot">nlp.enable_pipe</code></a>. When you save out the <code class="code_inline-code__Bq7ot">nlp</code>
object, the disabled component will be included but disabled by default.</li>
<li class="list_li__sfx_z"><strong>Exclude:</strong> Don’t load the component and its data with the pipeline. Once
the pipeline is loaded, there will be no reference to the excluded component.</li>
</ol><p>Disabled and excluded component names can be provided to
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#spacy.load"><code class="code_inline-code__Bq7ot">spacy.load</code></a> as a list.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">💡 Optional pipeline components<!-- --> </span></h4>
<p>The <code class="code_inline-code__Bq7ot">disable</code> mechanism makes it easy to distribute pipeline packages with
optional components that you can enable or disable at runtime. For instance,
your pipeline may include a statistical <em>and</em> a rule-based component for
sentence segmentation, and you can choose which one to run depending on your
use case.</p>
<p>For example, spaCy’s <a class="link_root__1Me7D" href="/models">trained pipelines</a> like
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/models/en#en_core_web_sm"><code class="code_inline-code__Bq7ot">en_core_web_sm</code></a> contain both a <code class="code_inline-code__Bq7ot">parser</code> and
<code class="code_inline-code__Bq7ot">senter</code> that perform sentence segmentation, but the <code class="code_inline-code__Bq7ot">senter</code> is disabled by
default.</p>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>In addition to <code class="code_inline-code__Bq7ot">disable</code>, <code class="code_inline-code__Bq7ot">spacy.load()</code> also accepts <code class="code_inline-code__Bq7ot">enable</code>. If <code class="code_inline-code__Bq7ot">enable</code> is
set, all components except for those in <code class="code_inline-code__Bq7ot">enable</code> are disabled. If <code class="code_inline-code__Bq7ot">enable</code> and
<code class="code_inline-code__Bq7ot">disable</code> conflict (i.e. the same component is included in both), an error is
raised.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Changed in v3.0</span></h4><p>As of v3.0, the <code class="code_inline-code__Bq7ot">disable</code> keyword argument specifies components to load but
disable, instead of components to not load at all. Those components can now be
specified separately using the new <code class="code_inline-code__Bq7ot">exclude</code> keyword argument.</p></aside><p>As a shortcut, you can use the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#select_pipes"><code class="code_inline-code__Bq7ot">nlp.select_pipes</code></a>
context manager to temporarily disable certain components for a given block. At
the end of the <code class="code_inline-code__Bq7ot">with</code> block, the disabled pipeline components will be restored
automatically. Alternatively, <code class="code_inline-code__Bq7ot">select_pipes</code> returns an object that lets you
call its <code class="code_inline-code__Bq7ot">restore()</code> method to restore the disabled components when needed. This
can be useful if you want to prevent unnecessary code indentation of large
blocks.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Disable for block</h4><code class="code_code__CILJL language-python language-python"></code></pre><p>If you want to disable all pipes except for one or a few, you can use the
<code class="code_inline-code__Bq7ot">enable</code> keyword. Just like the <code class="code_inline-code__Bq7ot">disable</code> keyword, it takes a list of pipe
names, or a string defining just one pipe.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#pipe"><code class="code_inline-code__Bq7ot">nlp.pipe</code></a> method also supports a <code class="code_inline-code__Bq7ot">disable</code> keyword
argument if you only want to disable components during processing:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>Finally, you can also use the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#remove_pipe"><code class="code_inline-code__Bq7ot">remove_pipe</code></a> method
to remove pipeline components from an existing pipeline, the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#rename_pipe"><code class="code_inline-code__Bq7ot">rename_pipe</code></a> method to rename them, or the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#replace_pipe"><code class="code_inline-code__Bq7ot">replace_pipe</code></a> method to replace them with a
custom component entirely (more details on this in the section on
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components">custom components</a>).</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>The <code class="code_inline-code__Bq7ot">Language</code> object exposes different <a class="link_root__1Me7D link_with-icon__NAVDA" href="/api/language#attributes"><span class="link_source-text__VDP74">attributes</span></a>
that let you inspect all available components and the components that currently
run as part of the pipeline.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Name</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp.pipeline</code></td><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">(name, component)</code> tuples of the processing pipeline, in order.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp.pipe_names</code></td><td class="table_td__rmpJx">Pipeline component names, in order.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp.components</code></td><td class="table_td__rmpJx">All <code class="code_inline-code__Bq7ot">(name, component)</code> tuples, including disabled components.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp.component_names</code></td><td class="table_td__rmpJx">All component names, including disabled components.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp.disabled</code></td><td class="table_td__rmpJx">Names of components that are currently disabled.</td></tr></tbody></table><h3 id="sourced-components" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#sourced-components" class="heading-text typography_permalink__UiIRy">Sourcing components from existing pipelines <!-- --> </a><span class="tag_root__NTSnK tag_spaced__Q9amH" data-tooltip="This feature is new and was introduced in spaCy v3.0">v<!-- -->3.0</span></h3><p>Pipeline components that are independent can also be reused across pipelines.
Instead of adding a new blank component, you can also copy an existing component
from a trained pipeline by setting the <code class="code_inline-code__Bq7ot">source</code> argument on
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a>. The first argument will then be
interpreted as the name of the component in the source pipeline – for instance,
<code class="code_inline-code__Bq7ot">&quot;ner&quot;</code>. This is especially useful for
<a class="link_root__1Me7D" href="/usage/training#config-components">training a pipeline</a> because it lets you mix
and match components and create fully custom pipeline packages with updated
trained components and new components trained on your data.</p><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Important note for trained components</span></h4><p>When reusing components across pipelines, keep in mind that the <strong>vocabulary</strong>,
<strong>vectors</strong> and model settings <strong>must match</strong>. If a trained pipeline includes
<a class="link_root__1Me7D" href="/usage/linguistic-features#vectors-similarity">word vectors</a> and the component
uses them as features, the pipeline you copy it to needs to have the <em>same</em>
vectors available – otherwise, it won’t be able to make the same predictions.</p></aside><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">In training config<!-- --> </span></h4>
<p>Instead of providing a <code class="code_inline-code__Bq7ot">factory</code>, component blocks in the training
<a class="link_root__1Me7D" href="/usage/training#config">config</a> can also define a <code class="code_inline-code__Bq7ot">source</code>. The string needs
to be a loadable spaCy pipeline package or path.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
<p>By default, sourced components will be updated with your data during training.
If you want to preserve the component as-is, you can “freeze” it if the
pipeline is not using a shared <code class="code_inline-code__Bq7ot">Tok2Vec</code> layer:</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><h3 id="analysis" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#analysis" class="heading-text typography_permalink__UiIRy">Analyzing pipeline components <!-- --> </a><span class="tag_root__NTSnK tag_spaced__Q9amH" data-tooltip="This feature is new and was introduced in spaCy v3.0">v<!-- -->3.0</span></h3><p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#analyze_pipes"><code class="code_inline-code__Bq7ot">nlp.analyze_pipes</code></a> method analyzes the
components in the current pipeline and outputs information about them like the
attributes they set on the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> and <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token"><code class="code_inline-code__Bq7ot">Token</code></a>, whether
they retokenize the <code class="code_inline-code__Bq7ot">Doc</code> and which scores they produce during training. It will
also show warnings if components require values that aren’t set by previous
component – for instance, if the entity linker is used but no component that
runs before it sets named entities. Setting <code class="code_inline-code__Bq7ot">pretty=True</code> will pretty-print a
table instead of only returning the structured data.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Add the components <code class="code_inline-code__Bq7ot">&quot;ner&quot;</code> and <code class="code_inline-code__Bq7ot">&quot;sentencizer&quot;</code> <em>before</em> the
<code class="code_inline-code__Bq7ot">&quot;entity_linker&quot;</code>. The analysis should now show no problems, because
requirements are met.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><section class="accordion"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Example output</span></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Structured</h4><code class="code_code__CILJL language-json language-json"></code></pre><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Pretty</h4><code class="code_code__CILJL language-none"></code></pre></div></div></section><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Important note</span></h4><p>The pipeline analysis is static and does <strong>not actually run the components</strong>.
This means that it relies on the information provided by the components
themselves. If a custom component declares that it assigns an attribute but it
doesn’t, the pipeline analysis won’t catch that.</p></aside></section>
<section id="section-custom-components" class="section_root__k1hUl"><h2 id="custom-components" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#custom-components" class="heading-text typography_permalink__UiIRy">Creating custom pipeline components <!-- --> </a></h2><p>A pipeline component is a function that receives a <code class="code_inline-code__Bq7ot">Doc</code> object, modifies it and
returns it – for example, by using the current weights to make a prediction and
set some annotation on the document. By adding a component to the pipeline,
you’ll get access to the <code class="code_inline-code__Bq7ot">Doc</code> at any point <strong>during processing</strong> – instead of
only being able to modify it afterwards.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Argument</th><th class="table_th__QJ9F8">Type</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">doc</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a></td><td class="table_td__rmpJx">The <code class="code_inline-code__Bq7ot">Doc</code> object processed by the previous component.</td></tr><tr class="table_tr__K_tkF table_footer__gJRIy table-footer"><td class="table_td__rmpJx"><strong>RETURNS</strong></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a></td><td class="table_td__rmpJx">The <code class="code_inline-code__Bq7ot">Doc</code> object processed by this pipeline component.</td></tr></tbody></table><p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#component"><code class="code_inline-code__Bq7ot">@Language.component</code></a> decorator lets you turn a
simple function into a pipeline component. It takes at least one argument, the
<strong>name</strong> of the component factory. You can use this name to add an instance of
your component to the pipeline. It can also be listed in your pipeline config,
so you can save, load and train pipelines using your component.</p><p>Custom components can be added to the pipeline using the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">add_pipe</code></a> method. Optionally, you can either specify
a component to add it <strong>before or after</strong>, tell spaCy to add it <strong>first or
last</strong> in the pipeline, or define a <strong>custom name</strong>. If no name is set and no
<code class="code_inline-code__Bq7ot">name</code> attribute is present on your component, the function name is used.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Argument</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">last</code></td><td class="table_td__rmpJx">If set to <code class="code_inline-code__Bq7ot">True</code>, component is added <strong>last</strong> in the pipeline (default). <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">bool</span></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">first</code></td><td class="table_td__rmpJx">If set to <code class="code_inline-code__Bq7ot">True</code>, component is added <strong>first</strong> in the pipeline. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">bool</span></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">before</code></td><td class="table_td__rmpJx">String name or index to add the new component <strong>before</strong>. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">Union<span class="code_cli-arg-subtle__IgB5m">[</span>str<span class="code_cli-arg-subtle__IgB5m">,</span> int<span class="code_cli-arg-subtle__IgB5m">]</span></span></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">after</code></td><td class="table_td__rmpJx">String name or index to add the new component <strong>after</strong>. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">Union<span class="code_cli-arg-subtle__IgB5m">[</span>str<span class="code_cli-arg-subtle__IgB5m">,</span> int<span class="code_cli-arg-subtle__IgB5m">]</span></span></td></tr></tbody></table><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Changed in v3.0</span></h4><p>As of v3.0, components need to be registered using the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#component"><code class="code_inline-code__Bq7ot">@Language.component</code></a> or
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator so spaCy knows that a
function is a component. <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a> now takes the
<strong>string name</strong> of the component factory instead of the component function. This
doesn’t only save you lines of code, it also allows spaCy to validate and track
your custom components, and make sure they can be saved and loaded.</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre></aside><h3 id="custom-components-simple" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#custom-components-simple" class="heading-text typography_permalink__UiIRy">Examples: Simple stateless pipeline components <!-- --> </a></h3><p>The following component receives the <code class="code_inline-code__Bq7ot">Doc</code> in the pipeline and prints some
information about it: the number of tokens, the part-of-speech tags of the
tokens and a conditional message based on the document length. The
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#component"><code class="code_inline-code__Bq7ot">@Language.component</code></a> decorator lets you register the
component under the name <code class="code_inline-code__Bq7ot">&quot;info_component&quot;</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Add the component first in the pipeline by setting <code class="code_inline-code__Bq7ot">first=True</code>. You’ll see
that the part-of-speech tags are empty, because the component now runs
before the tagger and the tags aren’t available yet.</li>
<li class="list_li__sfx_z">Change the component <code class="code_inline-code__Bq7ot">name</code> or remove the <code class="code_inline-code__Bq7ot">name</code> argument. You should see
this change reflected in <code class="code_inline-code__Bq7ot">nlp.pipe_names</code>.</li>
<li class="list_li__sfx_z">Print <code class="code_inline-code__Bq7ot">nlp.pipeline</code>. You’ll see a list of tuples describing the component
name and the function that’s called on the <code class="code_inline-code__Bq7ot">Doc</code> object in the pipeline.</li>
<li class="list_li__sfx_z">Change the first argument to <code class="code_inline-code__Bq7ot">@Language.component</code>, the name, to something
else. spaCy should now complain that it doesn’t know a component of the
name <code class="code_inline-code__Bq7ot">&quot;info_component&quot;</code>.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><p>Here’s another example of a pipeline component that implements custom logic to
improve the sentence boundaries set by the dependency parser. The custom logic
should therefore be applied <strong>after</strong> tokenization, but <em>before</em> the dependency
parsing – this way, the parser can also take advantage of the sentence
boundaries.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Print <code class="code_inline-code__Bq7ot">[token.dep_ for token in doc]</code> with and without the custom pipeline
component. You’ll see that the predicted dependency parse changes to match
the sentence boundaries.</li>
<li class="list_li__sfx_z">Remove the <code class="code_inline-code__Bq7ot">else</code> block. All other tokens will now have <code class="code_inline-code__Bq7ot">is_sent_start</code> set
to <code class="code_inline-code__Bq7ot">None</code> (missing value), the parser will assign sentence boundaries in
between.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><h3 id="custom-components-factories" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#custom-components-factories" class="heading-text typography_permalink__UiIRy">Component factories and stateful components <!-- --> </a></h3><p>Component factories are callables that take settings and return a <strong>pipeline
component function</strong>. This is useful if your component is stateful and if you
need to customize their creation, or if you need access to the current <code class="code_inline-code__Bq7ot">nlp</code>
object or the shared vocab. Component factories can be registered using the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator and they need at least
<strong>two named arguments</strong> that are filled in automatically when the component is
added to the pipeline:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Argument</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">nlp</code></td><td class="table_td__rmpJx">The current <code class="code_inline-code__Bq7ot">nlp</code> object. Can be used to access the shared vocab. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation"><a class="link_root__1Me7D" href="/api/language">Language</a></span></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">name</code></td><td class="table_td__rmpJx">The <strong>instance name</strong> of the component in the pipeline. This lets you identify different instances of the same component. <span class="type-annotation language-python code_inline-code__Bq7ot code_type-annotation__6N9RM" role="code" aria-label="Type annotation">str</span></td></tr></tbody></table><p>All other settings can be passed in by the user via the <code class="code_inline-code__Bq7ot">config</code> argument on
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a>. The
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator also lets you define a
<code class="code_inline-code__Bq7ot">default_config</code> that’s used as a fallback.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">With config</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><section class="accordion" id="factories-decorator-component"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">How is @Language.factory different from @Language.component?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#factories-decorator-component">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#component"><code class="code_inline-code__Bq7ot">@Language.component</code></a> decorator is essentially a
<strong>shortcut</strong> for stateless pipeline components that don’t need any settings.
This means you don’t have to always write a function that returns your function
if there’s no state to be passed through – spaCy can just take care of this for
you. The following two code examples are equivalent:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre></div></div></section><section class="accordion" id="factories-class-decorator"><div class="accordion_root__pPltq accordion_spaced__Ebyjn"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Can I add the @Language.factory decorator to a class?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#factories-class-decorator">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>Yes, the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator can be added to
a function or a class. If it’s added to a class, it expects the <code class="code_inline-code__Bq7ot">__init__</code>
method to take the arguments <code class="code_inline-code__Bq7ot">nlp</code> and <code class="code_inline-code__Bq7ot">name</code>, and will populate all other
arguments from the config. That said, it’s often cleaner and more intuitive to
make your factory a separate function. That’s also how spaCy does it internally.</p></div></div></section><h3 id="factories-language" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#factories-language" class="heading-text typography_permalink__UiIRy">Language-specific factories <!-- --> </a><span class="tag_root__NTSnK tag_spaced__Q9amH" data-tooltip="This feature is new and was introduced in spaCy v3.0">v<!-- -->3.0</span></h3><p>There are many use cases where you might want your pipeline components to be
language-specific. Sometimes this requires entirely different implementation per
language, sometimes the only difference is in the settings or data. spaCy allows
you to register factories of the <strong>same name</strong> on both the <code class="code_inline-code__Bq7ot">Language</code> base
class, as well as its <strong>subclasses</strong> like <code class="code_inline-code__Bq7ot">English</code> or <code class="code_inline-code__Bq7ot">German</code>. Factories are
resolved starting with the specific subclass. If the subclass doesn’t define a
component of that name, spaCy will check the <code class="code_inline-code__Bq7ot">Language</code> base class.</p><p>Here’s an example of a pipeline component that overwrites the normalized form of
a token, the <code class="code_inline-code__Bq7ot">Token.norm_</code> with an entry from a language-specific lookup table.
It’s registered twice under the name <code class="code_inline-code__Bq7ot">&quot;token_normalizer&quot;</code> – once using
<code class="code_inline-code__Bq7ot">@English.factory</code> and once using <code class="code_inline-code__Bq7ot">@German.factory</code>:</p><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span>Implementation details</span></h4><p>Under the hood, language-specific factories are added to the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#registry"><code class="code_inline-code__Bq7ot">factories</code> registry</a> prefixed with the language code,
e.g. <code class="code_inline-code__Bq7ot">&quot;en.token_normalizer&quot;</code>. When resolving the factory in
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a>, spaCy first checks for a
language-specific version of the factory using <code class="code_inline-code__Bq7ot">nlp.lang</code> and if none is
available, falls back to looking up the regular factory name.</p></aside><h3 id="example-stateful-components" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#example-stateful-components" class="heading-text typography_permalink__UiIRy">Example: Stateful component with settings <!-- --> </a></h3><p>This example shows a <strong>stateful</strong> pipeline component for handling acronyms:
based on a dictionary, it will detect acronyms and their expanded forms in both
directions and add them to a list as the custom <code class="code_inline-code__Bq7ot">doc._.acronyms</code>
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-attributes">extension attribute</a>. Under the hood, it uses
the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/phrasematcher"><code class="code_inline-code__Bq7ot">PhraseMatcher</code></a> to find instances of the phrases.</p><p>The factory function takes three arguments: the shared <code class="code_inline-code__Bq7ot">nlp</code> object and
component instance <code class="code_inline-code__Bq7ot">name</code>, which are passed in automatically by spaCy, and a
<code class="code_inline-code__Bq7ot">case_sensitive</code> config setting that makes the matching and acronym detection
case-sensitive.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Change the <code class="code_inline-code__Bq7ot">config</code> passed to <code class="code_inline-code__Bq7ot">nlp.add_pipe</code> and set <code class="code_inline-code__Bq7ot">&quot;case_sensitive&quot;</code> to
<code class="code_inline-code__Bq7ot">True</code>. You should see that the expanded acronym for “LOL” isn’t detected
anymore.</li>
<li class="list_li__sfx_z">Add some more terms to the <code class="code_inline-code__Bq7ot">DICTIONARY</code> and update the processed text so
they’re detected.</li>
<li class="list_li__sfx_z">Add a <code class="code_inline-code__Bq7ot">name</code> argument to <code class="code_inline-code__Bq7ot">nlp.add_pipe</code> to change the component name. Print
<code class="code_inline-code__Bq7ot">nlp.pipe_names</code> to see the change reflected in the pipeline.</li>
<li class="list_li__sfx_z">Print the config of the current <code class="code_inline-code__Bq7ot">nlp</code> object with
<code class="code_inline-code__Bq7ot">print(nlp.config.to_str())</code> and inspect the <code class="code_inline-code__Bq7ot">[components]</code> block. You
should see an entry for the acronyms component, referencing the factory
<code class="code_inline-code__Bq7ot">acronyms</code> and the config settings.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre></section>
<section id="section-component-data" class="section_root__k1hUl"><h2 id="component-data" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#component-data" class="heading-text typography_permalink__UiIRy">Initializing and serializing component data <!-- --> </a></h2><p>Many stateful components depend on <strong>data resources</strong> like dictionaries and
lookup tables that should ideally be <strong>configurable</strong>. For example, it makes
sense to make the <code class="code_inline-code__Bq7ot">DICTIONARY</code> in the above example an argument of the
registered function, so the <code class="code_inline-code__Bq7ot">AcronymComponent</code> can be re-used with different
data. One logical solution would be to make it an argument of the component
factory, and allow it to be initialized with different dictionaries.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>However, passing in the dictionary directly is problematic, because it means
that if a component saves out its config and settings, the
<a class="link_root__1Me7D" href="/usage/training#config"><code class="code_inline-code__Bq7ot">config.cfg</code></a> will include a dump of the entire data,
since that’s the config the component was created with. It will also fail if the
data is not JSON-serializable.</p><h3 id="component-data-function" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#component-data-function" class="heading-text typography_permalink__UiIRy">Option 1: Using a registered function <!-- --> </a></h3><aside class="infobox_root__yNIMg"><ul class="list_ul__fe_HF">
<li class="list_li__sfx_z list_li-icon__F2KvW"><strong>Pros:</strong> can load anything in Python, easy to add to and configure via
config</li>
<li class="list_li__sfx_z list_li-icon__F2KvW"><strong>Cons:</strong> requires the function and its dependencies to be available at
runtime</li>
</ul></aside><p>If what you’re passing in isn’t JSON-serializable – e.g. a custom object like a
<a class="link_root__1Me7D" href="/usage/processing-pipelines#trainable-components">model</a> – saving out the component config becomes
impossible because there’s no way for spaCy to know <em>how</em> that object was
created, and what to do to create it again. This makes it much harder to save,
load and train custom pipelines with custom components. A simple solution is to
<strong>register a function</strong> that returns your resources. The
<a class="link_root__1Me7D link_with-icon__NAVDA" href="/api/top-level#registry"><span class="link_source-text__VDP74">registry</span></a> lets you <strong>map string names to functions</strong>
that create objects, so given a name and optional arguments, spaCy will know how
to recreate the object. To register a function that returns your custom
dictionary, you can use the <code class="code_inline-code__Bq7ot">@spacy.registry.misc</code> decorator with a single
argument, the name:</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">What’s the misc registry?<!-- --> </span></h4>
<p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#registry"><code class="code_inline-code__Bq7ot">registry</code></a> provides different categories for
different types of functions – for example, model architectures, tokenizers or
batchers. <code class="code_inline-code__Bq7ot">misc</code> is intended for miscellaneous functions that don’t fit
anywhere else.</p>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Registered function for assets</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>In your <code class="code_inline-code__Bq7ot">default_config</code> (and later in your
<a class="link_root__1Me7D" href="/usage/training#config">training config</a>), you can now refer to the function
registered under the name <code class="code_inline-code__Bq7ot">&quot;acronyms.slang_dict.v1&quot;</code> using the <code class="code_inline-code__Bq7ot">@misc</code> key. This
tells spaCy how to create the value, and when your component is created, the
result of the registered function is passed in as the key <code class="code_inline-code__Bq7ot">&quot;dictionary&quot;</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre><p>Using a registered function also means that you can easily include your custom
components in pipelines that you <a class="link_root__1Me7D" href="/usage/training">train</a>. To make sure spaCy
knows where to find your custom <code class="code_inline-code__Bq7ot">@misc</code> function, you can pass in a Python file
via the argument <code class="code_inline-code__Bq7ot">--code</code>. If someone else is using your component, all they
have to do to customize the data is to register their own function and swap out
the name. Registered functions can also take <strong>arguments</strong>, by the way, that can
be defined in the config as well – you can read more about this in the docs on
<a class="link_root__1Me7D" href="/usage/training#custom-code">training with custom code</a>.</p><h3 id="component-data-initialization" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#component-data-initialization" class="heading-text typography_permalink__UiIRy">Option 2: Save data with the pipeline and load it in once on initialization <!-- --> </a></h3><aside class="infobox_root__yNIMg"><ul class="list_ul__fe_HF">
<li class="list_li__sfx_z list_li-icon__F2KvW"><strong>Pros:</strong> lets components save and load their own data and reflect user
changes, load in data assets before training without depending on them at
runtime</li>
<li class="list_li__sfx_z list_li-icon__F2KvW"><strong>Cons:</strong> requires more component methods, more complex config and data
flow</li>
</ul></aside><p>Just like models save out their binary weights when you call
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#to_disk"><code class="code_inline-code__Bq7ot">nlp.to_disk</code></a>, components can also <strong>serialize</strong> any
other data assets – for instance, an acronym dictionary. If a pipeline component
implements its own <code class="code_inline-code__Bq7ot">to_disk</code> and <code class="code_inline-code__Bq7ot">from_disk</code> methods, those will be called
automatically by <code class="code_inline-code__Bq7ot">nlp.to_disk</code> and will receive the path to the directory to
save to or load from. The component can then perform any custom saving or
loading. If a user makes changes to the component data, they will be reflected
when the <code class="code_inline-code__Bq7ot">nlp</code> object is saved. For more examples of this, see the usage guide
on <a class="link_root__1Me7D" href="/usage/saving-loading#serialization-methods">serialization methods</a>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">About the data path<!-- --> </span></h4>
<p>The <code class="code_inline-code__Bq7ot">path</code> argument spaCy passes to the serialization methods consists of the
path provided by the user, plus a directory of the component name. This means
that when you call <code class="code_inline-code__Bq7ot">nlp.to_disk(&quot;/path&quot;)</code>, the <code class="code_inline-code__Bq7ot">acronyms</code> component will
receive the directory path <code class="code_inline-code__Bq7ot">/path/acronyms</code> and can then create files in this
directory.</p>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Custom serialization methods</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>Now the component can save to and load from a directory. The only remaining
question: How do you <strong>load in the initial data</strong>? In Python, you could just
call the pipe’s <code class="code_inline-code__Bq7ot">from_disk</code> method yourself. But if you’re adding the component
to your <a class="link_root__1Me7D" href="/usage/training#config">training config</a>, spaCy will need to know how
to set it up, from start to finish, including the data to initialize it with.</p><p>While you could use a registered function or a file loader like
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#file_readers"><code class="code_inline-code__Bq7ot">srsly.read_json.v1</code></a> as an argument of the
component factory, this approach is problematic: the component factory runs
<strong>every time the component is created</strong>. This means it will run when creating
the <code class="code_inline-code__Bq7ot">nlp</code> object before training, but also every time a user loads your
pipeline. So your runtime pipeline would either depend on a local path on your
file system, or it’s loaded twice: once when the component is created, and then
again when the data is by <code class="code_inline-code__Bq7ot">from_disk</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg</h4><code class="code_code__CILJL language-ini language-ini"></code></pre>
<pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg</h4><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre><p>To solve this, your component can implement a separate method, <code class="code_inline-code__Bq7ot">initialize</code>,
which will be called by <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#initialize"><code class="code_inline-code__Bq7ot">nlp.initialize</code></a> if
available. This typically happens before training, but not at runtime when the
pipeline is loaded. For more background on this, see the usage guides on the
<a class="link_root__1Me7D" href="/usage/training#config-lifecycle">config lifecycle</a> and
<a class="link_root__1Me7D" href="/usage/training#initialization">custom initialization</a>.</p><figure class="gatsby-resp-image-figure"><img class="embed_image__mSQUH" src="/images/lifecycle.svg" alt="Illustration of pipeline lifecycle" width="650" height="auto"/></figure><p>A component’s <code class="code_inline-code__Bq7ot">initialize</code> method needs to take at least <strong>two named
arguments</strong>: a <code class="code_inline-code__Bq7ot">get_examples</code> callback that gives it access to the training
examples, and the current <code class="code_inline-code__Bq7ot">nlp</code> object. This is mostly used by trainable
components so they can initialize their models and label schemes from the data,
so we can ignore those arguments here. All <strong>other arguments</strong> on the method can
be defined via the config – in this case a dictionary <code class="code_inline-code__Bq7ot">data</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">config.cfg<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-ini language-ini"></code></pre>
</div></div></aside><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Custom initialize method</h4><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>When <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#initialize"><code class="code_inline-code__Bq7ot">nlp.initialize</code></a> runs before training (or when
you call it in your own code), the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/data-formats#config-initialize"><code class="code_inline-code__Bq7ot">[initialize]</code></a> block of the config is
loaded and used to construct the <code class="code_inline-code__Bq7ot">nlp</code> object. The custom acronym component will
then be passed the data loaded from the JSON file. After training, the <code class="code_inline-code__Bq7ot">nlp</code>
object is saved to disk, which will run the component’s <code class="code_inline-code__Bq7ot">to_disk</code> method. When
the pipeline is loaded back into spaCy later to use it, the <code class="code_inline-code__Bq7ot">from_disk</code> method
will load the data back in.</p></section>
<section id="section-type-hints" class="section_root__k1hUl"><h2 id="type-hints" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#type-hints" class="heading-text typography_permalink__UiIRy">Python type hints and validation <!-- --> </a><span class="tag_root__NTSnK tag_spaced__Q9amH" data-tooltip="This feature is new and was introduced in spaCy v3.0">v<!-- -->3.0</span></h2><p>spaCy’s configs are powered by our machine learning library Thinc’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-config">configuration system</a>, which supports
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://docs.python.org/3/library/typing.html">type hints</a> and even
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/usage-config#advanced-types">advanced type annotations</a>
using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/samuelcolvin/pydantic"><code class="code_inline-code__Bq7ot">pydantic</code></a>. If your component
factory provides type hints, the values that are passed in will be <strong>checked
against the expected types</strong>. If the value can’t be cast to an integer, spaCy
will raise an error. <code class="code_inline-code__Bq7ot">pydantic</code> also provides strict types like <code class="code_inline-code__Bq7ot">StrictFloat</code>,
which will force the value to be an integer and raise an error if it’s not – for
instance, if your config defines a float.</p><aside class="infobox_root__yNIMg infobox_warning__SKl67"><p>If you’re not using
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://pydantic-docs.helpmanual.io/usage/types/#strict-types">strict types</a>,
values that can be <strong>cast to</strong> the given type will still be accepted. For
example, <code class="code_inline-code__Bq7ot">1</code> can be cast to a <code class="code_inline-code__Bq7ot">float</code> or a <code class="code_inline-code__Bq7ot">bool</code> type, but not to a
<code class="code_inline-code__Bq7ot">List[str]</code>. However, if the type is
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://pydantic-docs.helpmanual.io/usage/types/#strict-types"><code class="code_inline-code__Bq7ot">StrictFloat</code></a>,
only a float will be accepted.</p></aside><p>The following example shows a custom pipeline component for debugging. It can be
added anywhere in the pipeline and logs information about the <code class="code_inline-code__Bq7ot">nlp</code> object and
the <code class="code_inline-code__Bq7ot">Doc</code> that passes through. The <code class="code_inline-code__Bq7ot">log_level</code> config setting lets the user
customize what log statements are shown – for instance, <code class="code_inline-code__Bq7ot">&quot;INFO&quot;</code> will show info
logs and more critical logging statements, whereas <code class="code_inline-code__Bq7ot">&quot;DEBUG&quot;</code> will show
everything. The value is annotated as a <code class="code_inline-code__Bq7ot">StrictStr</code>, so it will only accept a
string value.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">✏️ Things to try<!-- --> </span></h4>
<ol class="list_ol__aclSa">
<li class="list_li__sfx_z">Change the <code class="code_inline-code__Bq7ot">config</code> passed to <code class="code_inline-code__Bq7ot">nlp.add_pipe</code> to use the log level <code class="code_inline-code__Bq7ot">&quot;INFO&quot;</code>.
You should see that only the statement logged with <code class="code_inline-code__Bq7ot">logger.info</code> is shown.</li>
<li class="list_li__sfx_z">Change the <code class="code_inline-code__Bq7ot">config</code> passed to <code class="code_inline-code__Bq7ot">nlp.add_pipe</code> so that it contains unexpected
values – for example, a boolean instead of a string: <code class="code_inline-code__Bq7ot">&quot;log_level&quot;: False</code>.
You should see a validation error.</li>
<li class="list_li__sfx_z">Check out the docs on <code class="code_inline-code__Bq7ot">pydantic</code>’s
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://pydantic-docs.helpmanual.io/usage/types/#constrained-types">constrained types</a>
and write a type hint for <code class="code_inline-code__Bq7ot">log_level</code> that only accepts the exact string
values <code class="code_inline-code__Bq7ot">&quot;DEBUG&quot;</code>, <code class="code_inline-code__Bq7ot">&quot;INFO&quot;</code> or <code class="code_inline-code__Bq7ot">&quot;CRITICAL&quot;</code>.</li>
</ol>
</div></div></aside><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre></section>
<section id="section-trainable-components" class="section_root__k1hUl"><h2 id="trainable-components" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#trainable-components" class="heading-text typography_permalink__UiIRy">Trainable components <!-- --> </a><span class="tag_root__NTSnK tag_spaced__Q9amH" data-tooltip="This feature is new and was introduced in spaCy v3.0">v<!-- -->3.0</span></h2><p>spaCy’s <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe"><code class="code_inline-code__Bq7ot">TrainablePipe</code></a> class helps you implement your own
trainable components that have their own model instance, make predictions over
<code class="code_inline-code__Bq7ot">Doc</code> objects and can be updated using <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/cli#train"><code class="code_inline-code__Bq7ot">spacy train</code></a>. This
lets you plug fully custom machine learning components into your pipeline.</p><figure class="gatsby-resp-image-figure"><img class="embed_image__mSQUH" src="/images/trainable_component.svg" alt="Illustration of Pipe methods" width="650" height="auto"/></figure><p>You’ll need the following:</p><ol class="list_ol__aclSa">
<li class="list_li__sfx_z"><strong>Model:</strong> A Thinc <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model"><code class="code_inline-code__Bq7ot">Model</code></a> instance. This
can be a model implemented in <a class="link_root__1Me7D" href="/usage/layers-architectures#thinc">Thinc</a>, or
a <a class="link_root__1Me7D" href="/usage/layers-architectures#frameworks">wrapped model</a> implemented in
PyTorch, TensorFlow, MXNet or a fully custom solution. The model must take a
list of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects as input and can have any type of output.</li>
<li class="list_li__sfx_z"><strong>TrainablePipe subclass:</strong> A subclass of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe"><code class="code_inline-code__Bq7ot">TrainablePipe</code></a> that
implements at least two methods: <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#predict"><code class="code_inline-code__Bq7ot">TrainablePipe.predict</code></a>
and <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#set_annotations"><code class="code_inline-code__Bq7ot">TrainablePipe.set_annotations</code></a>.</li>
<li class="list_li__sfx_z"><strong>Component factory:</strong> A component factory registered with
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> that takes the <code class="code_inline-code__Bq7ot">nlp</code> object and
component <code class="code_inline-code__Bq7ot">name</code> and optional settings provided by the config and returns an
instance of your trainable component.</li>
</ol><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Name</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#predict"><code class="code_inline-code__Bq7ot">predict</code></a></td><td class="table_td__rmpJx">Apply the component’s model to a batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects (without modifying them) and return the scores.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#set_annotations"><code class="code_inline-code__Bq7ot">set_annotations</code></a></td><td class="table_td__rmpJx">Modify a batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc"><code class="code_inline-code__Bq7ot">Doc</code></a> objects, using pre-computed scores generated by <code class="code_inline-code__Bq7ot">predict</code>.</td></tr></tbody></table><p>By default, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#init"><code class="code_inline-code__Bq7ot">TrainablePipe.__init__</code></a> takes the shared vocab,
the <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model"><code class="code_inline-code__Bq7ot">Model</code></a> and the name of the component
instance in the pipeline, which you can use as a key in the losses. All other
keyword arguments will become available as <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#cfg"><code class="code_inline-code__Bq7ot">TrainablePipe.cfg</code></a>
and will also be serialized with the component.</p><section class="accordion"><div class="accordion_root__pPltq accordion_spaced__Ebyjn"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Why components should be passed a Model instance, not create it</span></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>spaCy’s <a class="link_root__1Me7D" href="/usage/training#config">config system</a> resolves the config describing
the pipeline components and models <strong>bottom-up</strong>. This means that it will
<em>first</em> create a <code class="code_inline-code__Bq7ot">Model</code> from a <a class="link_root__1Me7D link_with-icon__NAVDA" href="/api/architectures"><span class="link_source-text__VDP74">registered architecture</span></a>,
validate its arguments and <em>then</em> pass the object forward to the component. This
means that the config can express very complex, nested trees of objects – but
the objects don’t have to pass the model settings all the way down to the
components. It also makes the components more <strong>modular</strong> and lets you
<a class="link_root__1Me7D" href="/usage/layers-architectures#swap-architectures">swap</a> different architectures
in your config, and re-use model definitions.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">config.cfg (excerpt)</h4><code class="code_code__CILJL language-ini language-ini"></code></pre><p>Your trainable pipeline component factories should therefore always take a
<code class="code_inline-code__Bq7ot">model</code> argument instead of instantiating the
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model"><code class="code_inline-code__Bq7ot">Model</code></a> inside the component. To register
custom architectures, you can use the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#registry"><code class="code_inline-code__Bq7ot">@spacy.registry.architectures</code></a> decorator. Also see
the <a class="link_root__1Me7D" href="/usage/training#config">training guide</a> for details.</p></div></div></section><p>For some use cases, it makes sense to also overwrite additional methods to
customize how the model is updated from examples, how it’s initialized, how the
loss is calculated and to add evaluation scores to the training output.</p><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Name</th><th class="table_th__QJ9F8">Description</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#update"><code class="code_inline-code__Bq7ot">update</code></a></td><td class="table_td__rmpJx">Learn from a batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/example"><code class="code_inline-code__Bq7ot">Example</code></a> objects containing the predictions and gold-standard annotations, and update the component’s model.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#initialize"><code class="code_inline-code__Bq7ot">initialize</code></a></td><td class="table_td__rmpJx">Initialize the model. Typically calls into <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://thinc.ai/docs/api-model#initialize"><code class="code_inline-code__Bq7ot">Model.initialize</code></a> and can be passed custom arguments via the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/data-formats#config-initialize"><code class="code_inline-code__Bq7ot">[initialize]</code></a> config block that are only loaded during training or when you call <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#initialize"><code class="code_inline-code__Bq7ot">nlp.initialize</code></a>, not at runtime.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#get_loss"><code class="code_inline-code__Bq7ot">get_loss</code></a></td><td class="table_td__rmpJx">Return a tuple of the loss and the gradient for a batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/example"><code class="code_inline-code__Bq7ot">Example</code></a> objects.</td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/pipe#score"><code class="code_inline-code__Bq7ot">score</code></a></td><td class="table_td__rmpJx">Score a batch of <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/example"><code class="code_inline-code__Bq7ot">Example</code></a> objects and return a dictionary of scores. The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator can define the <code class="code_inline-code__Bq7ot">default_score_weights</code> of the component to decide which keys of the scores to display during training and how they count towards the final score.</td></tr></tbody></table><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">📖</span>Custom trainable components and models</span></h4><p>For more details on how to implement your own trainable components and model
architectures, and plug existing models implemented in PyTorch or TensorFlow
into your spaCy pipeline, see the usage guide on
<a class="link_root__1Me7D" href="/usage/layers-architectures#components">layers and model architectures</a>.</p></aside></section>
<section id="section-custom-components-attributes" class="section_root__k1hUl"><h2 id="custom-components-attributes" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#custom-components-attributes" class="heading-text typography_permalink__UiIRy">Extension attributes <!-- --> </a></h2><p>spaCy allows you to set any custom attributes and methods on the <code class="code_inline-code__Bq7ot">Doc</code>, <code class="code_inline-code__Bq7ot">Span</code>
and <code class="code_inline-code__Bq7ot">Token</code>, which become available as <code class="code_inline-code__Bq7ot">Doc._</code>, <code class="code_inline-code__Bq7ot">Span._</code> and <code class="code_inline-code__Bq7ot">Token._</code> – for
example, <code class="code_inline-code__Bq7ot">Token._.my_attr</code>. This lets you store additional information relevant
to your application, add new features and functionality to spaCy, and implement
your own models trained with other machine learning libraries. It also lets you
take advantage of spaCy’s data structures and the <code class="code_inline-code__Bq7ot">Doc</code> object as the “single
source of truth”.</p><section class="accordion" id="why-dot-underscore"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">Why ._ and not just a top-level attribute?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#why-dot-underscore">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>Writing to a <code class="code_inline-code__Bq7ot">._</code> attribute instead of to the <code class="code_inline-code__Bq7ot">Doc</code> directly keeps a clearer
separation and makes it easier to ensure backwards compatibility. For example,
if you’ve implemented your own <code class="code_inline-code__Bq7ot">.coref</code> property and spaCy claims it one day,
it’ll break your code. Similarly, just by looking at the code, you’ll
immediately know what’s built-in and what’s custom – for example,
<code class="code_inline-code__Bq7ot">doc.sentiment</code> is spaCy, while <code class="code_inline-code__Bq7ot">doc._.sent_score</code> isn’t.</p></div></div></section><section class="accordion" id="dot-underscore-implementation"><div class="accordion_root__pPltq"><h4><button class="accordion_button__IPO0E" aria-expanded="true"><span><span class="heading-text">How is the ._ implemented?</span><a class="link_root__1Me7D accordion_anchor__kidBh link_no-link-layout__RPvod" href="/usage/processing-pipelines#dot-underscore-implementation">¶</a></span><svg class="accordion_icon__fpBl7" width="20" height="20" viewBox="0 0 10 10" aria-hidden="true" focusable="false"><rect class="accordion_hidden__tgILw" height="8" width="2" x="4" y="1"></rect><rect height="2" width="8" x="1" y="4"></rect></svg></button></h4><div class="accordion_content__divKS"><p>Extension definitions – the defaults, methods, getters and setters you pass in
to <code class="code_inline-code__Bq7ot">set_extension</code> – are stored in class attributes on the <code class="code_inline-code__Bq7ot">Underscore</code> class.
If you write to an extension attribute, e.g. <code class="code_inline-code__Bq7ot">doc._.hello = True</code>, the data is
stored within the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#attributes"><code class="code_inline-code__Bq7ot">Doc.user_data</code></a> dictionary. To keep the
underscore data separate from your other dictionary entries, the string <code class="code_inline-code__Bq7ot">&quot;._.&quot;</code>
is placed before the name, in a tuple.</p></div></div></section><hr class="section_hr__07Hes"/><p>There are three main types of extensions, which can be defined using the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#set_extension"><code class="code_inline-code__Bq7ot">Doc.set_extension</code></a>,
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#set_extension"><code class="code_inline-code__Bq7ot">Span.set_extension</code></a> and
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#set_extension"><code class="code_inline-code__Bq7ot">Token.set_extension</code></a> methods.</p></section>
<section class="section_root__k1hUl"><h2 class="typography_heading__D82WZ typography_h2__hzV3h"><span class="heading-text">Description<!-- --> </span></h2><ol class="list_ol__aclSa">
<li class="list_li__sfx_z">
<p><strong>Attribute extensions.</strong> Set a default value for an attribute, which can be
overwritten manually at any time. Attribute extensions work like “normal”
variables and are the quickest way to store arbitrary information on a <code class="code_inline-code__Bq7ot">Doc</code>,
<code class="code_inline-code__Bq7ot">Span</code> or <code class="code_inline-code__Bq7ot">Token</code>.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</li>
<li class="list_li__sfx_z">
<p><strong>Property extensions.</strong> Define a getter and an optional setter function. If
no setter is provided, the extension is immutable. Since the getter and
setter functions are only called when you <em>retrieve</em> the attribute, you can
also access values of previously added attribute extensions. For example, a
<code class="code_inline-code__Bq7ot">Doc</code> getter can average over <code class="code_inline-code__Bq7ot">Token</code> attributes. For <code class="code_inline-code__Bq7ot">Span</code> extensions,
you’ll almost always want to use a property – otherwise, you’d have to write
to <em>every possible</em> <code class="code_inline-code__Bq7ot">Span</code> in the <code class="code_inline-code__Bq7ot">Doc</code> to set up the values correctly.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</li>
<li class="list_li__sfx_z">
<p><strong>Method extensions.</strong> Assign a function that becomes available as an object
method. Method extensions are always immutable. For more details and
implementation ideas, see
<a class="link_root__1Me7D" href="/usage/examples#custom-components-attr-methods">these examples</a>.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</li>
</ol><p>Before you can access a custom extension, you need to register it using the
<code class="code_inline-code__Bq7ot">set_extension</code> method on the object you want to add it to, e.g. the <code class="code_inline-code__Bq7ot">Doc</code>. Keep
in mind that extensions are always <strong>added globally</strong> and not just on a
particular instance. If an attribute of the same name already exists, or if
you’re trying to access an attribute that hasn’t been registered, spaCy will
raise an <code class="code_inline-code__Bq7ot">AttributeError</code>.</p><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Example</h4><code class="code_code__CILJL language-python language-python"></code></pre><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Usage example<!-- --> </span></h4>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre>
</div></div></aside><p>Once you’ve registered your custom attribute, you can also use the built-in
<code class="code_inline-code__Bq7ot">set</code>, <code class="code_inline-code__Bq7ot">get</code> and <code class="code_inline-code__Bq7ot">has</code> methods to modify and retrieve the attributes. This is
especially useful it you want to pass in a string instead of calling
<code class="code_inline-code__Bq7ot">doc._.my_attr</code>.</p><h3 id="component-example3" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#component-example3" class="heading-text typography_permalink__UiIRy">Example: Pipeline component for GPE entities and country meta data via a REST API <!-- --> </a></h3><p>This example shows the implementation of a pipeline component that fetches
country meta data via the <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://restcountries.com">REST Countries API</a>, sets
entity annotations for countries and sets custom attributes on the <code class="code_inline-code__Bq7ot">Doc</code> and
<code class="code_inline-code__Bq7ot">Span</code> – for example, the capital, latitude/longitude coordinates and even the
country flag.</p><pre class="code_pre__kzg60"><div class="code_juniper-wrapper__Vfpma"><h4 class="code_juniper-title__ePkNN">Editable Code<span class="code_juniper-meta__aRELD">spaCy v<!-- -->3.5<!-- --> · Python 3 · via<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://mybinder.org/">Binder</a></span></h4><div class="code_juniper-cell__XJBck"><div class="cm-theme code_juniper-input__HKv_l"></div><button class="code_juniper-button__k_2FS">run</button></div></div></pre><p>In this case, all data can be fetched on initialization in one request. However,
if you’re working with text that contains incomplete country names, spelling
mistakes or foreign-language versions, you could also implement a
<code class="code_inline-code__Bq7ot">like_country</code>-style getter function that makes a request to the search API
endpoint and returns the best-matching result.</p><h3 id="custom-components-user-hooks" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#custom-components-user-hooks" class="heading-text typography_permalink__UiIRy">User hooks <!-- --> </a></h3><p>While it’s generally recommended to use the <code class="code_inline-code__Bq7ot">Doc._</code>, <code class="code_inline-code__Bq7ot">Span._</code> and <code class="code_inline-code__Bq7ot">Token._</code>
proxies to add your own custom attributes, spaCy offers a few exceptions to
allow <strong>customizing the built-in methods</strong> like
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#similarity"><code class="code_inline-code__Bq7ot">Doc.similarity</code></a> or <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#vector"><code class="code_inline-code__Bq7ot">Doc.vector</code></a> with
your own hooks, which can rely on components you train yourself. For instance,
you can provide your own on-the-fly sentence segmentation algorithm or document
similarity method.</p><p>Hooks let you customize some of the behaviors of the <code class="code_inline-code__Bq7ot">Doc</code>, <code class="code_inline-code__Bq7ot">Span</code> or <code class="code_inline-code__Bq7ot">Token</code>
objects by adding a component to the pipeline. For instance, to customize the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#similarity"><code class="code_inline-code__Bq7ot">Doc.similarity</code></a> method, you can add a component that
sets a custom function to <code class="code_inline-code__Bq7ot">doc.user_hooks[&quot;similarity&quot;]</code>. The built-in
<code class="code_inline-code__Bq7ot">Doc.similarity</code> method will check the <code class="code_inline-code__Bq7ot">user_hooks</code> dict, and delegate to your
function if you’ve set one. Similar results can be achieved by setting functions
to <code class="code_inline-code__Bq7ot">Doc.user_span_hooks</code> and <code class="code_inline-code__Bq7ot">Doc.user_token_hooks</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Implementation note<!-- --> </span></h4>
<p>The hooks live on the <code class="code_inline-code__Bq7ot">Doc</code> object because the <code class="code_inline-code__Bq7ot">Span</code> and <code class="code_inline-code__Bq7ot">Token</code> objects are
created lazily, and don’t own any data. They just proxy to their parent <code class="code_inline-code__Bq7ot">Doc</code>.
This turns out to be convenient here – we only have to worry about installing
hooks in one place.</p>
</div></div></aside><table class="table_root__ZlA_w"><thead><tr class="table_tr__K_tkF"><th class="table_th__QJ9F8">Name</th><th class="table_th__QJ9F8">Customizes</th></tr></thead><tbody><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">user_hooks</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#similarity"><code class="code_inline-code__Bq7ot">Doc.similarity</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#vector"><code class="code_inline-code__Bq7ot">Doc.vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#has_vector"><code class="code_inline-code__Bq7ot">Doc.has_vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#vector_norm"><code class="code_inline-code__Bq7ot">Doc.vector_norm</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#sents"><code class="code_inline-code__Bq7ot">Doc.sents</code></a></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">user_token_hooks</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#similarity"><code class="code_inline-code__Bq7ot">Token.similarity</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#vector"><code class="code_inline-code__Bq7ot">Token.vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#has_vector"><code class="code_inline-code__Bq7ot">Token.has_vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#vector_norm"><code class="code_inline-code__Bq7ot">Token.vector_norm</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/token#conjuncts"><code class="code_inline-code__Bq7ot">Token.conjuncts</code></a></td></tr><tr class="table_tr__K_tkF"><td class="table_td__rmpJx"><code class="code_inline-code__Bq7ot">user_span_hooks</code></td><td class="table_td__rmpJx"><a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#similarity"><code class="code_inline-code__Bq7ot">Span.similarity</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#vector"><code class="code_inline-code__Bq7ot">Span.vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#has_vector"><code class="code_inline-code__Bq7ot">Span.has_vector</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#vector_norm"><code class="code_inline-code__Bq7ot">Span.vector_norm</code></a>, <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/span#root"><code class="code_inline-code__Bq7ot">Span.root</code></a></td></tr></tbody></table><pre class="code_pre__kzg60"><h4 class="code_title__Zz9rs">Add custom similarity hooks</h4><code class="code_code__CILJL language-python language-python"></code></pre></section>
<section id="section-plugins" class="section_root__k1hUl"><h2 id="plugins" class="typography_heading__D82WZ typography_h2__hzV3h"><a href="#plugins" class="heading-text typography_permalink__UiIRy">Developing plugins and wrappers <!-- --> </a></h2><p>We’re very excited about all the new possibilities for community extensions and
plugins in spaCy, and we can’t wait to see what you build with it! To get you
started, here are a few tips, tricks and best
practices. <a class="link_root__1Me7D" href="/universe?category=pipeline">See here</a> for examples of other spaCy
extensions.</p><h3 id="custom-components-usage-ideas" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#custom-components-usage-ideas" class="heading-text typography_permalink__UiIRy">Usage ideas <!-- --> </a></h3><ul class="list_ul__fe_HF">
<li class="list_li__sfx_z"><strong>Adding new features and hooking in models.</strong> For example, a sentiment
analysis model, or your preferred solution for lemmatization or sentiment
analysis. spaCy’s built-in tagger, parser and entity recognizer respect
annotations that were already set on the <code class="code_inline-code__Bq7ot">Doc</code> in a previous step of the
pipeline.</li>
<li class="list_li__sfx_z"><strong>Integrating other libraries and APIs.</strong> For example, your pipeline component
can write additional information and data directly to the <code class="code_inline-code__Bq7ot">Doc</code> or <code class="code_inline-code__Bq7ot">Token</code> as
custom attributes, while making sure no information is lost in the process.
This can be output generated by other libraries and models, or an external
service with a REST API.</li>
<li class="list_li__sfx_z"><strong>Debugging and logging.</strong> For example, a component which stores and/or
exports relevant information about the current state of the processed
document, and insert it at any point of your pipeline.</li>
</ul><h3 id="custom-components-best-practices" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#custom-components-best-practices" class="heading-text typography_permalink__UiIRy">Best practices <!-- --> </a></h3><p>Extensions can claim their own <code class="code_inline-code__Bq7ot">._</code> namespace and exist as standalone packages.
If you’re developing a tool or library and want to make it easy for others to
use it with spaCy and add it to their pipeline, all you have to do is expose a
function that takes a <code class="code_inline-code__Bq7ot">Doc</code>, modifies it and returns it.</p><ul class="list_ul__fe_HF">
<li class="list_li__sfx_z">
<p>Make sure to choose a <strong>descriptive and specific name</strong> for your pipeline
component class, and set it as its <code class="code_inline-code__Bq7ot">name</code> attribute. Avoid names that are too
common or likely to clash with built-in or a user’s other custom components.
While it’s fine to call your package <code class="code_inline-code__Bq7ot">&quot;spacy_my_extension&quot;</code>, avoid component
names including <code class="code_inline-code__Bq7ot">&quot;spacy&quot;</code>, since this can easily lead to confusion.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre>
</li>
<li class="list_li__sfx_z">
<p>When writing to <code class="code_inline-code__Bq7ot">Doc</code>, <code class="code_inline-code__Bq7ot">Token</code> or <code class="code_inline-code__Bq7ot">Span</code> objects, <strong>use getter functions</strong>
wherever possible, and avoid setting values explicitly. Tokens and spans don’t
own any data themselves, and they’re implemented as C extension classes – so
you can’t usually add new attributes to them like you could with most pure
Python objects.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre>
</li>
<li class="list_li__sfx_z">
<p>Always add your custom attributes to the <strong>global</strong> <code class="code_inline-code__Bq7ot">Doc</code>, <code class="code_inline-code__Bq7ot">Token</code> or <code class="code_inline-code__Bq7ot">Span</code>
objects, not a particular instance of them. Add the attributes <strong>as early as
possible</strong>, e.g. in your extension’s <code class="code_inline-code__Bq7ot">__init__</code> method or in the global scope
of your module. This means that in the case of namespace collisions, the user
will see an error immediately, not just when they run their pipeline.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre>
</li>
<li class="list_li__sfx_z">
<p>If your extension is setting properties on the <code class="code_inline-code__Bq7ot">Doc</code>, <code class="code_inline-code__Bq7ot">Token</code> or <code class="code_inline-code__Bq7ot">Span</code>,
include an option to <strong>let the user to change those attribute names</strong>. This
makes it easier to avoid namespace collisions and accommodate users with
different naming preferences. We recommend adding an <code class="code_inline-code__Bq7ot">attrs</code> argument to the
<code class="code_inline-code__Bq7ot">__init__</code> method of your class so you can write the names to class attributes
and reuse them across your component.</p>
<pre class="code_pre__kzg60"><code class="code_code__CILJL language-diff language-diff"></code></pre>
</li>
<li class="list_li__sfx_z">
<p>Ideally, extensions should be <strong>standalone packages</strong> with spaCy and
optionally, other packages specified as a dependency. They can freely assign
to their own <code class="code_inline-code__Bq7ot">._</code> namespace, but should stick to that. If your extension’s
only job is to provide a better <code class="code_inline-code__Bq7ot">.similarity</code> implementation, and your docs
state this explicitly, there’s no problem with writing to the
<a class="link_root__1Me7D" href="/usage/processing-pipelines#custom-components-user-hooks"><code class="code_inline-code__Bq7ot">user_hooks</code></a> and overwriting spaCy’s built-in
method. However, a third-party extension should <strong>never silently overwrite
built-ins</strong>, or attributes set by other extensions.</p>
</li>
<li class="list_li__sfx_z">
<p>If you’re looking to publish a pipeline package that depends on a custom
pipeline component, you can either <strong>require it</strong> in the package’s
dependencies, or – if the component is specific and lightweight – choose to
<strong>ship it with your pipeline package</strong>. Just make sure the
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#component"><code class="code_inline-code__Bq7ot">@Language.component</code></a> or
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#factory"><code class="code_inline-code__Bq7ot">@Language.factory</code></a> decorator that registers the
custom component runs in your package’s <code class="code_inline-code__Bq7ot">__init__.py</code> or is exposed via an
<a class="link_root__1Me7D" href="/usage/saving-loading#entry-points">entry point</a>.</p>
</li>
<li class="list_li__sfx_z">
<p>Once you’re ready to share your extension with others, make sure to <strong>add docs
and installation instructions</strong> (you can always link to this page for more
info). Make it easy for others to install and use your extension, for example
by uploading it to <a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://pypi.python.org">PyPi</a>. If you’re sharing your
code on GitHub, don’t forget to tag it with
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/topics/spacy?o=desc&amp;s=stars"><code class="code_inline-code__Bq7ot">spacy</code></a> and
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/topics/spacy-extension?o=desc&amp;s=stars"><code class="code_inline-code__Bq7ot">spacy-extension</code></a>
to help people find it. If you post it on Twitter, feel free to tag
<a class="link_root__1Me7D" rel="noopener nofollow noreferrer" target="_blank" href="https://twitter.com/spacy_io">@spacy_io</a> so we can check it out.</p>
</li>
</ul><h3 id="wrapping-models-libraries" class="typography_heading__D82WZ typography_h3__mPKmB"><a href="#wrapping-models-libraries" class="heading-text typography_permalink__UiIRy">Wrapping other models and libraries <!-- --> </a></h3><p>Let’s say you have a custom entity recognizer that takes a list of strings and
returns their <a class="link_root__1Me7D" href="/usage/linguistic-features#accessing-ner">BILUO tags</a>. Given an
input like <code class="code_inline-code__Bq7ot code_wrap__b41os">[&quot;A&quot;, &quot;text&quot;, &quot;about&quot;, &quot;Facebook&quot;]</code>, it will predict and return
<code class="code_inline-code__Bq7ot">[&quot;O&quot;, &quot;O&quot;, &quot;O&quot;, &quot;U-ORG&quot;]</code>. To integrate it into your spaCy pipeline and make it
add those entities to the <code class="code_inline-code__Bq7ot">doc.ents</code>, you can wrap it in a custom pipeline
component function and pass it the token texts from the <code class="code_inline-code__Bq7ot">Doc</code> object received by
the component.</p><p>The <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/top-level#biluo_tags_to_spans"><code class="code_inline-code__Bq7ot">training.biluo_tags_to_spans</code></a> is very
helpful here, because it takes a <code class="code_inline-code__Bq7ot">Doc</code> object and token-based BILUO tags and
returns a sequence of <code class="code_inline-code__Bq7ot">Span</code> objects in the <code class="code_inline-code__Bq7ot">Doc</code> with added labels. So all your
wrapper has to do is compute the entity spans and overwrite the <code class="code_inline-code__Bq7ot">doc.ents</code>.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">How the doc.ents work<!-- --> </span></h4>
<p>When you add spans to the <code class="code_inline-code__Bq7ot">doc.ents</code>, spaCy will automatically resolve them
back to the underlying tokens and set the <code class="code_inline-code__Bq7ot">Token.ent_type</code> and <code class="code_inline-code__Bq7ot">Token.ent_iob</code>
attributes. By definition, each token can only be part of one entity, so
overlapping entity spans are not allowed.</p>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><p>The <code class="code_inline-code__Bq7ot">custom_ner_wrapper</code> can then be added to a blank pipeline using
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#add_pipe"><code class="code_inline-code__Bq7ot">nlp.add_pipe</code></a>. You can also replace the existing
entity recognizer of a trained pipeline with
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/language#replace_pipe"><code class="code_inline-code__Bq7ot">nlp.replace_pipe</code></a>.</p><p>Here’s another example of a custom model, <code class="code_inline-code__Bq7ot">your_custom_model</code>, that takes a list
of tokens and returns lists of fine-grained part-of-speech tags, coarse-grained
part-of-speech tags, dependency labels and head token indices. Here, we can use
the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/doc#from_array"><code class="code_inline-code__Bq7ot">Doc.from_array</code></a> to create a new <code class="code_inline-code__Bq7ot">Doc</code> object using
those values. To create a numpy array we need integers, so we can look up the
string labels in the <a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/stringstore"><code class="code_inline-code__Bq7ot">StringStore</code></a>. The
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" href="/api/stringstore#add"><code class="code_inline-code__Bq7ot">doc.vocab.strings.add</code></a> method comes in handy here,
because it returns the integer ID of the string <em>and</em> makes sure it’s added to
the vocab. This is especially important if the custom model uses a different
label scheme than spaCy’s default models.</p><aside class="aside_root__667WA"><div class="aside_content__ZN6qm" role="complementary"><div class="aside_text__LFH_Q">
<h4 class="typography_heading__D82WZ typography_h4__CDRaM"><span class="heading-text">Example: spacy-stanza<!-- --> </span></h4>
<p>For an example of an end-to-end wrapper for statistical tokenization, tagging
and parsing, check out
<a class="link_root__1Me7D link_nowrap__H7Oxl link_with-icon__NAVDA" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spacy-stanza"><code class="code_inline-code__Bq7ot">spacy-stanza</code></a>. It uses a very
similar approach to the example in this section – the only difference is that
it fully replaces the <code class="code_inline-code__Bq7ot">nlp</code> object instead of providing a pipeline component,
since it also needs to handle tokenization.</p>
</div></div></aside><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python code_wrap__b41os"></code></pre><aside class="infobox_root__yNIMg infobox_warning__SKl67"><h4 class="infobox_title__uDT7C"><span>Sentence boundaries and heads</span></h4><p>If you create a <code class="code_inline-code__Bq7ot">Doc</code> object with dependencies and heads, spaCy is able to
resolve the sentence boundaries automatically. However, note that the <code class="code_inline-code__Bq7ot">HEAD</code>
value used to construct a <code class="code_inline-code__Bq7ot">Doc</code> is the token index <strong>relative</strong> to the current
token – e.g. <code class="code_inline-code__Bq7ot">-1</code> for the previous token. The CoNLL format typically annotates
heads as <code class="code_inline-code__Bq7ot">1</code>-indexed absolute indices with <code class="code_inline-code__Bq7ot">0</code> indicating the root. If that’s
the case in your annotations, you need to convert them first:</p><pre class="code_pre__kzg60"><code class="code_code__CILJL language-python language-python"></code></pre></aside><aside class="infobox_root__yNIMg"><h4 class="infobox_title__uDT7C"><span><span class="infobox_emoji__6_YUY" aria-hidden="true">📖</span>Advanced usage, serialization and entry points</span></h4><p>For more details on how to write and package custom components, make them
available to spaCy via entry points and implement your own serialization
methods, check out the usage guide on
<a class="link_root__1Me7D" href="/usage/saving-loading">saving and loading</a>.</p></aside></section><div class="grid_root__EfDZl grid_spacing__fhBCv grid_half__xoJZs"><div style="margin-top:var(--spacing-lg)"><a class="link_root__1Me7D button_root__jwipc button_secondary__ukZAk" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/tree/master/website/docs/usage/processing-pipelines.mdx">Suggest edits</a></div><a class="link_root__1Me7D readnext_root__JNzwZ link_no-link-layout__RPvod" href="/usage/embeddings-transformers"><span><span class="typography_label__l_oVJ">Read next</span>Embeddings &amp; Transformers</span><span class="readnext_icon__jfRnJ"></span></a></div></article><div class="main_asides__RITE5" style="background-image:url(/_next/static/media/pattern_blue.d167bed5.png"></div><footer class="footer_root__zlkjP"><div class="grid_root__EfDZl footer_content__LaE1F grid_narrow__x_6xS grid_spacing__fhBCv grid_third__edHuB"><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">spaCy</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/usage">Usage</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/models">Models</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/api">API Reference</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://course.spacy.io">Online Course</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/custom-solutions">Custom Solutions</a></li></ul></section><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Community</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="/universe">Universe</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/discussions">GitHub Discussions</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy/issues">Issue Tracker</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="http://stackoverflow.com/questions/tagged/spacy">Stack Overflow</a></li></ul></section><section><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Connect</li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://twitter.com/spacy_io">Twitter</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/explosion/spaCy">GitHub</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" rel="noopener nofollow noreferrer" target="_blank" href="https://youtube.com/c/ExplosionAI">YouTube</a></li><li><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/blog">Blog</a></li></ul></section><section class="footer_full___icln"><ul class="footer_column__DPe22"><li class="footer_label__xK7_s">Stay in the loop!</li><li>Receive updates about new releases, tutorials and more.</li><li><form id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" action="//spacy.us12.list-manage.com/subscribe/post?u=83b0498b1e7fa3c91ce68c3f1&amp;amp;id=ecc82e0493" method="post" target="_blank" novalidate=""><div style="position:absolute;left:-5000px" aria-hidden="true"><input type="text" name="b_83b0498b1e7fa3c91ce68c3f1_ecc82e0493" tabindex="-1" value=""/></div><div class="newsletter_root__uh6MU"><input class="newsletter_input___SMSB" id="mce-EMAIL" type="email" name="EMAIL" placeholder="Your email" aria-label="Your email"/><button class="newsletter_button__gKW8E" id="mc-embedded-subscribe" type="submit" name="subscribe">Sign up</button></div></form></li></ul></section></div><div class="footer_content__LaE1F footer_copy__rbjvc"><span>© 2016-<!-- -->2023<!-- --> <a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai">Explosion</a></span><a class="link_root__1Me7D footer_logo__BthsJ link_no-link-layout__RPvod" aria-label="Explosion" href="https://explosion.ai"></a><a class="link_root__1Me7D link_no-link-layout__RPvod" href="https://explosion.ai/legal">Legal / Imprint</a></div></footer></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Language Processing Pipelines","next":{"slug":"/usage/embeddings-transformers","title":"Embeddings \u0026 Transformers"},"menu":[["Processing Text","processing"],["Pipelines \u0026 Components","pipelines"],["Custom Components","custom-components"],["Component Data","component-data"],["Type Hints \u0026 Validation","type-hints"],["Trainable Components","trainable-components"],["Extension Attributes","custom-components-attributes"],["Plugins \u0026 Wrappers","plugins"]],"slug":"/usage/processing-pipelines","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    section: \"section\",\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    blockquote: \"blockquote\",\n    h4: \"h4\",\n    ol: \"ol\",\n    h3: \"h3\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    em: \"em\",\n    del: \"del\",\n    img: \"img\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components), {Pipelines101, InlineCode, Infobox, Accordion} = _components;\n  if (!Accordion) _missingMdxReference(\"Accordion\", true);\n  if (!Infobox) _missingMdxReference(\"Infobox\", true);\n  if (!InlineCode) _missingMdxReference(\"InlineCode\", true);\n  if (!Pipelines101) _missingMdxReference(\"Pipelines101\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.section, {\n      children: _jsx(Pipelines101, {})\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-processing\",\n      children: [_jsx(_components.h2, {\n        id: \"processing\",\n        children: \"Processing text \"\n      }), _jsxs(_components.p, {\n        children: [\"When you call \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" on a text, spaCy will \", _jsx(_components.strong, {\n          children: \"tokenize\"\n        }), \" it and then \", _jsx(_components.strong, {\n          children: \"call each\\ncomponent\"\n        }), \" on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", in order. It then returns the processed \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" that you\\ncan work with.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"doc = nlp(\\\"This is a text\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When processing large volumes of text, the statistical models are usually more\\nefficient if you let them work on batches of texts. spaCy’s\\n\", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" method takes an iterable of texts and yields\\nprocessed \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects. The batching is done internally.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"texts = [\\\"This is a text\\\", \\\"These are lots of texts\\\", \\\"...\\\"]\\n- docs = [nlp(text) for text in texts]\\n+ docs = list(nlp.pipe(texts))\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Tips for efficient processing\",\n        emoji: \"💡\",\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Process the texts \", _jsx(_components.strong, {\n              children: \"as a stream\"\n            }), \" using \", _jsx(_components.a, {\n              href: \"/api/language#pipe\",\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipe\"\n              })\n            }), \" and\\nbuffer them in batches, instead of one-by-one. This is usually much more\\nefficient.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Only apply the \", _jsx(_components.strong, {\n              children: \"pipeline components you need\"\n            }), \". Getting predictions from the\\nmodel that you don’t actually need adds up and becomes very inefficient at\\nscale. To prevent this, use the \", _jsx(InlineCode, {\n              children: \"disable\"\n            }), \" keyword argument to disable\\ncomponents you don’t need – either when loading a pipeline, or during\\nprocessing with \", _jsx(InlineCode, {\n              children: \"nlp.pipe\"\n            }), \". See the section on\\n\", _jsx(_components.a, {\n              href: \"#disabling\",\n              children: \"disabling pipeline components\"\n            }), \" for more details and examples.\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In this example, we’re using \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" to process a\\n(potentially very large) iterable of texts as a stream. Because we’re only\\naccessing the named entities in \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \" (set by the \", _jsx(InlineCode, {\n          children: \"ner\"\n        }), \" component), we’ll\\ndisable all other components during processing. \", _jsx(InlineCode, {\n          children: \"nlp.pipe\"\n        }), \" yields \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects,\\nso we can iterate over them and access the named entity predictions:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Also disable the \", _jsx(InlineCode, {\n              children: \"\\\"ner\\\"\"\n            }), \" component. You’ll see that the \", _jsx(InlineCode, {\n              children: \"doc.ents\"\n            }), \" are now\\nempty, because the entity recognizer didn’t run.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\ntexts = [\\n    \\\"Net income was $9.4 million compared to the prior year of $2.7 million.\\\",\\n    \\\"Revenue exceeded twelve billion dollars, with a loss of $1b.\\\",\\n]\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nfor doc in nlp.pipe(texts, disable=[\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]):\\n    # Do something with the doc here\\n    print([(ent.text, ent.label_) for ent in doc.ents])\\n\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Important note\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"When using \", _jsx(_components.a, {\n            href: \"/api/language#pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.pipe\"\n            })\n          }), \", keep in mind that it returns a\\n\", _jsx(_components.a, {\n            href: \"https://realpython.com/introduction-to-python-generators/\",\n            children: \"generator\"\n          }), \" that\\nyields \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" objects – not a list. So if you want to use it like a list, you’ll\\nhave to call \", _jsx(InlineCode, {\n            children: \"list()\"\n          }), \" on it first:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"- docs = nlp.pipe(texts)[0]         # will raise an error\\n+ docs = list(nlp.pipe(texts))[0]   # works as expected\\n\"\n          })\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"You can use the \", _jsx(InlineCode, {\n          children: \"as_tuples\"\n        }), \" option to pass additional context along with each\\ndoc when using \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \". If \", _jsx(InlineCode, {\n          children: \"as_tuples\"\n        }), \" is \", _jsx(InlineCode, {\n          children: \"True\"\n        }), \", then\\nthe input should be a sequence of \", _jsx(InlineCode, {\n          children: \"(text, context)\"\n        }), \" tuples and the output will\\nbe a sequence of \", _jsx(InlineCode, {\n          children: \"(doc, context)\"\n        }), \" tuples. For example, you can pass metadata in\\nthe context and save it in a \", _jsx(_components.a, {\n          href: \"#custom-components-attributes\",\n          children: \"custom attribute\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.tokens import Doc\\n\\nif not Doc.has_extension(\\\"text_id\\\"):\\n    Doc.set_extension(\\\"text_id\\\", default=None)\\n\\ntext_tuples = [\\n    (\\\"This is the first text.\\\", {\\\"text_id\\\": \\\"text1\\\"}),\\n    (\\\"This is the second text.\\\", {\\\"text_id\\\": \\\"text2\\\"})\\n]\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\ndoc_tuples = nlp.pipe(text_tuples, as_tuples=True)\\n\\ndocs = []\\nfor doc, context in doc_tuples:\\n    doc._.text_id = context[\\\"text_id\\\"]\\n    docs.append(doc)\\n\\nfor doc in docs:\\n    print(f\\\"{doc._.text_id}: {doc.text}\\\")\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"multiprocessing\",\n        children: \"Multiprocessing \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy includes built-in support for multiprocessing with\\n\", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" using the \", _jsx(InlineCode, {\n          children: \"n_process\"\n        }), \" option:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Multiprocessing with 4 processes\\ndocs = nlp.pipe(texts, n_process=4)\\n\\n# With as many processes as CPUs (use with caution!)\\ndocs = nlp.pipe(texts, n_process=-1)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Depending on your platform, starting many processes with multiprocessing can add\\na lot of overhead. In particular, the default start method \", _jsx(InlineCode, {\n          children: \"spawn\"\n        }), \" used in\\nmacOS/OS X (as of Python 3.8) and in Windows can be slow for larger models\\nbecause the model data is copied in memory for each new process. See the\\n\", _jsx(_components.a, {\n          href: \"https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\",\n          children: \"Python docs on multiprocessing\"\n        }), \"\\nfor further details.\"]\n      }), _jsxs(_components.p, {\n        children: [\"For shorter tasks and in particular with \", _jsx(InlineCode, {\n          children: \"spawn\"\n        }), \", it can be faster to use a\\nsmaller number of processes with a larger batch size. The optimal \", _jsx(InlineCode, {\n          children: \"batch_size\"\n        }), \"\\nsetting will depend on the pipeline components, the length of your documents,\\nthe number of processes and how much memory is available.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Default batch size is `nlp.batch_size` (typically 1000)\\ndocs = nlp.pipe(texts, n_process=2, batch_size=2000)\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Multiprocessing on GPU\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"Multiprocessing is not generally recommended on GPU because RAM is too limited.\\nIf you want to try it out, be aware that it is only possible using \", _jsx(InlineCode, {\n            children: \"spawn\"\n          }), \" due\\nto limitations in CUDA.\"]\n        })\n      }), _jsx(Infobox, {\n        title: \"Multiprocessing with transformer models\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"In Linux, transformer models may hang or deadlock with multiprocessing due to an\\n\", _jsx(_components.a, {\n            href: \"https://github.com/pytorch/pytorch/issues/17199\",\n            children: \"issue in PyTorch\"\n          }), \". One\\nsuggested workaround is to use \", _jsx(InlineCode, {\n            children: \"spawn\"\n          }), \" instead of \", _jsx(InlineCode, {\n            children: \"fork\"\n          }), \" and another is to limit\\nthe number of threads before loading any models using\\n\", _jsx(InlineCode, {\n            children: \"torch.set_num_threads(1)\"\n          }), \".\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-pipelines\",\n      children: [_jsx(_components.h2, {\n        id: \"pipelines\",\n        children: \"Pipelines and built-in components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy makes it very easy to create your own pipelines consisting of reusable\\ncomponents – this includes spaCy’s default tagger, parser and entity recognizer,\\nbut also your own custom processing functions. A pipeline component can be added\\nto an already existing \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object, specified when initializing a\\n\", _jsx(_components.a, {\n          href: \"/api/language\",\n          children: _jsx(InlineCode, {\n            children: \"Language\"\n          })\n        }), \" class, or defined within a\\n\", _jsx(_components.a, {\n          href: \"/usage/saving-loading#models\",\n          children: \"pipeline package\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg (excerpt)\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \" [nlp]\\n lang = \\\"en\\\"\\n pipeline = [\\\"tok2vec\\\", \\\"parser\\\"]\\n\\n[components]\\n\\n[components.tok2vec]\\nfactory = \\\"tok2vec\\\"\\n# Settings for the tok2vec component\\n\\n[components.parser]\\nfactory = \\\"parser\\\"\\n# Settings for the parser component\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"When you load a pipeline, spaCy first consults the\\n\", _jsx(_components.a, {\n          href: \"/usage/saving-loading#models\",\n          children: _jsx(InlineCode, {\n            children: \"meta.json\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \". The config tells spaCy what language\\nclass to use, which components are in the pipeline, and how those components\\nshould be created. spaCy will then do the following:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Load the \", _jsx(_components.strong, {\n            children: \"language class and data\"\n          }), \" for the given ID via\\n\", _jsx(_components.a, {\n            href: \"/api/top-level#util.get_lang_class\",\n            children: _jsx(InlineCode, {\n              children: \"get_lang_class\"\n            })\n          }), \" and initialize it. The\\n\", _jsx(InlineCode, {\n            children: \"Language\"\n          }), \" class contains the shared vocabulary, tokenization rules and the\\nlanguage-specific settings.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Iterate over the \", _jsx(_components.strong, {\n            children: \"pipeline names\"\n          }), \" and look up each component name in the\\n\", _jsx(InlineCode, {\n            children: \"[components]\"\n          }), \" block. The \", _jsx(InlineCode, {\n            children: \"factory\"\n          }), \" tells spaCy which\\n\", _jsx(_components.a, {\n            href: \"#custom-components-factories\",\n            children: \"component factory\"\n          }), \" to use for adding the\\ncomponent with \", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"add_pipe\"\n            })\n          }), \". The settings are passed\\ninto the factory.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Make the \", _jsx(_components.strong, {\n            children: \"model data\"\n          }), \" available to the \", _jsx(InlineCode, {\n            children: \"Language\"\n          }), \" class by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#from_disk\",\n            children: _jsx(InlineCode, {\n              children: \"from_disk\"\n            })\n          }), \" with the path to the data directory.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"So when you call this…\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp = spacy.load(\\\"en_core_web_sm\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"… the pipeline’s \", _jsx(InlineCode, {\n          children: \"config.cfg\"\n        }), \" tells spaCy to use the language \", _jsx(InlineCode, {\n          children: \"\\\"en\\\"\"\n        }), \" and the\\npipeline\\n\", _jsx(InlineCode, {\n          children: \"[\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"ner\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]\"\n        }), \". spaCy\\nwill then initialize \", _jsx(InlineCode, {\n          children: \"spacy.lang.en.English\"\n        }), \", and create each pipeline component\\nand add it to the processing pipeline. It’ll then load in the model data from\\nthe data directory and return the modified \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class for you to use as\\nthe \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object.\"]\n      }), _jsx(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"spaCy v3.0 introduces a \", _jsx(InlineCode, {\n            children: \"config.cfg\"\n          }), \", which includes more detailed settings for\\nthe pipeline, its components and the \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"training process\"\n          }), \".\\nYou can export the config of your current \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#config\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.config.to_disk\"\n            })\n          }), \".\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Fundamentally, a \", _jsx(_components.a, {\n          href: \"/models\",\n          children: \"spaCy pipeline package\"\n        }), \" consists of three components:\\n\", _jsx(_components.strong, {\n          children: \"the weights\"\n        }), \", i.e. binary data loaded in from a directory, a \", _jsx(_components.strong, {\n          children: \"pipeline\"\n        }), \" of\\nfunctions called in order, and \", _jsx(_components.strong, {\n          children: \"language data\"\n        }), \" like the tokenization rules and\\nlanguage-specific settings. For example, a Spanish NER pipeline requires\\ndifferent weights, language data and components than an English parsing and\\ntagging pipeline. This is also why the pipeline state is always held by the\\n\", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" class. \", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \" puts this all\\ntogether and returns an instance of \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" with a pipeline set and access to\\nthe binary data:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"spacy.load under the hood\",\n          children: \"lang = \\\"en\\\"\\npipeline = [\\\"tok2vec\\\", \\\"tagger\\\", \\\"parser\\\", \\\"ner\\\", \\\"attribute_ruler\\\", \\\"lemmatizer\\\"]\\ndata_path = \\\"path/to/en_core_web_sm/en_core_web_sm-3.0.0\\\"\\n\\ncls = spacy.util.get_lang_class(lang)  # 1. Get Language class, e.g. English\\nnlp = cls()                            # 2. Initialize it\\nfor name in pipeline:\\n    nlp.add_pipe(name)                 # 3. Add the component to the pipeline\\nnlp.from_disk(data_path)               # 4. Load in the binary data\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When you call \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" on a text, spaCy will \", _jsx(_components.strong, {\n          children: \"tokenize\"\n        }), \" it and then \", _jsx(_components.strong, {\n          children: \"call each\\ncomponent\"\n        }), \" on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", in order. Since the model data is loaded, the\\ncomponents can access it to assign annotations to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object, and\\nsubsequently to the \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" which are only views of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", and\\ndon’t own any data themselves. All components return the modified document,\\nwhich is then processed by the next component in the pipeline.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"The pipeline under the hood\",\n          children: \"doc = nlp.make_doc(\\\"This is a sentence\\\")  # Create a Doc from raw text\\nfor name, proc in nlp.pipeline:           # Iterate over components in order\\n    doc = proc(doc)                       # Apply each component\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The current processing pipeline is available as \", _jsx(InlineCode, {\n          children: \"nlp.pipeline\"\n        }), \", which returns a\\nlist of \", _jsx(InlineCode, {\n          children: \"(name, component)\"\n        }), \" tuples, or \", _jsx(InlineCode, {\n          children: \"nlp.pipe_names\"\n        }), \", which only returns a\\nlist of human-readable component names.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"print(nlp.pipeline)\\n# [('tok2vec', \u003cspacy.pipeline.Tok2Vec\u003e), ('tagger', \u003cspacy.pipeline.Tagger\u003e), ('parser', \u003cspacy.pipeline.DependencyParser\u003e), ('ner', \u003cspacy.pipeline.EntityRecognizer\u003e), ('attribute_ruler', \u003cspacy.pipeline.AttributeRuler\u003e), ('lemmatizer', \u003cspacy.lang.en.lemmatizer.EnglishLemmatizer\u003e)]\\nprint(nlp.pipe_names)\\n# ['tok2vec', 'tagger', 'parser', 'ner', 'attribute_ruler', 'lemmatizer']\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"built-in\",\n        children: \"Built-in pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy ships with several built-in pipeline components that are registered with\\nstring names. This means that you can initialize them by calling\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \" with their names and spaCy will know\\nhow to create them. See the \", _jsx(_components.a, {\n          href: \"/api\",\n          children: \"API documentation\"\n        }), \" for a full list of\\navailable pipeline components and component functions.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Usage\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"sentencizer\\\")\\n# add_pipe returns the added component\\nruler = nlp.add_pipe(\\\"entity_ruler\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"String name\"\n            }), _jsx(_components.th, {\n              children: \"Component\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tagger\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/tagger\",\n                children: _jsx(InlineCode, {\n                  children: \"Tagger\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign part-of-speech-tags.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"parser\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/dependencyparser\",\n                children: _jsx(InlineCode, {\n                  children: \"DependencyParser\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign dependency labels.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"ner\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entityrecognizer\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityRecognizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign named entities.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entity_linker\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entitylinker\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityLinker\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign knowledge base IDs to named entities. Should be added after the entity recognizer.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"entity_ruler\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/entityruler\",\n                children: _jsx(InlineCode, {\n                  children: \"EntityRuler\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign named entities based on pattern rules and dictionaries.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"textcat\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"TextCategorizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign text categories: exactly one category is predicted per document.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"textcat_multilabel\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/textcategorizer\",\n                children: _jsx(InlineCode, {\n                  children: \"MultiLabel_TextCategorizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign text categories in a multi-label setting: zero, one or more labels per document.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"lemmatizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/lemmatizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Lemmatizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign base forms to words using rules and lookups.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"trainable_lemmatizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/edittreelemmatizer\",\n                children: _jsx(InlineCode, {\n                  children: \"EditTreeLemmatizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign base forms to words.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"morphologizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/morphologizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Morphologizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign morphological features and coarse-grained POS tags.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"attribute_ruler\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/attributeruler\",\n                children: _jsx(InlineCode, {\n                  children: \"AttributeRuler\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign token attribute mappings and rule-based exceptions.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"senter\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/sentencerecognizer\",\n                children: _jsx(InlineCode, {\n                  children: \"SentenceRecognizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign sentence boundaries.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"sentencizer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/sentencizer\",\n                children: _jsx(InlineCode, {\n                  children: \"Sentencizer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Add rule-based sentence segmentation without the dependency parse.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"tok2vec\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/tok2vec\",\n                children: _jsx(InlineCode, {\n                  children: \"Tok2Vec\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign token-to-vector embeddings.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"transformer\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/transformer\",\n                children: _jsx(InlineCode, {\n                  children: \"Transformer\"\n                })\n              })\n            }), _jsx(_components.td, {\n              children: \"Assign the tokens and outputs of a transformer model.\"\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"disabling\",\n        children: \"Disabling, excluding and modifying components \"\n      }), _jsxs(_components.p, {\n        children: [\"If you don’t need a particular component of the pipeline – for example, the\\ntagger or the parser, you can \", _jsx(_components.strong, {\n          children: \"disable or exclude\"\n        }), \" it. This can sometimes make\\na big difference and improve loading and inference speed. There are two\\ndifferent mechanisms you can use:\"]\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Disable:\"\n          }), \" The component and its data will be loaded with the pipeline, but\\nit will be disabled by default and not run as part of the processing\\npipeline. To run it, you can explicitly enable it by calling\\n\", _jsx(_components.a, {\n            href: \"/api/language#enable_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.enable_pipe\"\n            })\n          }), \". When you save out the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \"\\nobject, the disabled component will be included but disabled by default.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Exclude:\"\n          }), \" Don’t load the component and its data with the pipeline. Once\\nthe pipeline is loaded, there will be no reference to the excluded component.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Disabled and excluded component names can be provided to\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#spacy.load\",\n          children: _jsx(InlineCode, {\n            children: \"spacy.load\"\n          })\n        }), \" as a list.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"💡 Optional pipeline components\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"disable\"\n          }), \" mechanism makes it easy to distribute pipeline packages with\\noptional components that you can enable or disable at runtime. For instance,\\nyour pipeline may include a statistical \", _jsx(_components.em, {\n            children: \"and\"\n          }), \" a rule-based component for\\nsentence segmentation, and you can choose which one to run depending on your\\nuse case.\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"For example, spaCy’s \", _jsx(_components.a, {\n            href: \"/models\",\n            children: \"trained pipelines\"\n          }), \" like\\n\", _jsx(_components.a, {\n            href: \"/models/en#en_core_web_sm\",\n            children: _jsx(InlineCode, {\n              children: \"en_core_web_sm\"\n            })\n          }), \" contain both a \", _jsx(InlineCode, {\n            children: \"parser\"\n          }), \" and\\n\", _jsx(InlineCode, {\n            children: \"senter\"\n          }), \" that perform sentence segmentation, but the \", _jsx(InlineCode, {\n            children: \"senter\"\n          }), \" is disabled by\\ndefault.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Load the pipeline without the entity recognizer\\nnlp = spacy.load(\\\"en_core_web_sm\\\", exclude=[\\\"ner\\\"])\\n\\n# Load the tagger and parser but don't enable them\\nnlp = spacy.load(\\\"en_core_web_sm\\\", disable=[\\\"tagger\\\", \\\"parser\\\"])\\n# Explicitly enable the tagger later on\\nnlp.enable_pipe(\\\"tagger\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In addition to \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"spacy.load()\"\n        }), \" also accepts \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \". If \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" is\\nset, all components except for those in \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" are disabled. If \", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" conflict (i.e. the same component is included in both), an error is\\nraised.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Load the complete pipeline, but disable all components except for tok2vec and tagger\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"tok2vec\\\", \\\"tagger\\\"])\\n# Has the same effect, as NER is already not part of enabled set of components\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"tok2vec\\\", \\\"tagger\\\"], disable=[\\\"ner\\\"])\\n# Will raise an error, as the sets of enabled and disabled components are conflicting\\nnlp = spacy.load(\\\"en_core_web_sm\\\", enable=[\\\"ner\\\"], disable=[\\\"ner\\\"])\\n\"\n        })\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Changed in v3.0\",\n        children: _jsxs(_components.p, {\n          children: [\"As of v3.0, the \", _jsx(InlineCode, {\n            children: \"disable\"\n          }), \" keyword argument specifies components to load but\\ndisable, instead of components to not load at all. Those components can now be\\nspecified separately using the new \", _jsx(InlineCode, {\n            children: \"exclude\"\n          }), \" keyword argument.\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"As a shortcut, you can use the \", _jsx(_components.a, {\n          href: \"/api/language#select_pipes\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.select_pipes\"\n          })\n        }), \"\\ncontext manager to temporarily disable certain components for a given block. At\\nthe end of the \", _jsx(InlineCode, {\n          children: \"with\"\n        }), \" block, the disabled pipeline components will be restored\\nautomatically. Alternatively, \", _jsx(InlineCode, {\n          children: \"select_pipes\"\n        }), \" returns an object that lets you\\ncall its \", _jsx(InlineCode, {\n          children: \"restore()\"\n        }), \" method to restore the disabled components when needed. This\\ncan be useful if you want to prevent unnecessary code indentation of large\\nblocks.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Disable for block\",\n          children: \"# 1. Use as a context manager\\nwith nlp.select_pipes(disable=[\\\"tagger\\\", \\\"parser\\\", \\\"lemmatizer\\\"]):\\n    doc = nlp(\\\"I won't be tagged and parsed\\\")\\ndoc = nlp(\\\"I will be tagged and parsed\\\")\\n\\n# 2. Restore manually\\ndisabled = nlp.select_pipes(disable=\\\"ner\\\")\\ndoc = nlp(\\\"I won't have named entities\\\")\\ndisabled.restore()\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If you want to disable all pipes except for one or a few, you can use the\\n\", _jsx(InlineCode, {\n          children: \"enable\"\n        }), \" keyword. Just like the \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" keyword, it takes a list of pipe\\nnames, or a string defining just one pipe.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"# Enable only the parser\\nwith nlp.select_pipes(enable=\\\"parser\\\"):\\n    doc = nlp(\\\"I will only be parsed\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.pipe\"\n          })\n        }), \" method also supports a \", _jsx(InlineCode, {\n          children: \"disable\"\n        }), \" keyword\\nargument if you only want to disable components during processing:\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"for doc in nlp.pipe(texts, disable=[\\\"tagger\\\", \\\"parser\\\", \\\"lemmatizer\\\"]):\\n    # Do something with the doc here\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Finally, you can also use the \", _jsx(_components.a, {\n          href: \"/api/language#remove_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"remove_pipe\"\n          })\n        }), \" method\\nto remove pipeline components from an existing pipeline, the\\n\", _jsx(_components.a, {\n          href: \"/api/language#rename_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"rename_pipe\"\n          })\n        }), \" method to rename them, or the\\n\", _jsx(_components.a, {\n          href: \"/api/language#replace_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"replace_pipe\"\n          })\n        }), \" method to replace them with a\\ncustom component entirely (more details on this in the section on\\n\", _jsx(_components.a, {\n          href: \"#custom-components\",\n          children: \"custom components\"\n        }), \").\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"nlp.remove_pipe(\\\"parser\\\")\\nnlp.rename_pipe(\\\"ner\\\", \\\"entityrecognizer\\\")\\nnlp.replace_pipe(\\\"tagger\\\", \\\"my_custom_tagger\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" object exposes different \", _jsx(_components.a, {\n          href: \"/api/language#attributes\",\n          children: \"attributes\"\n        }), \"\\nthat let you inspect all available components and the components that currently\\nrun as part of the pipeline.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"ner\\\")\\nnlp.add_pipe(\\\"textcat\\\")\\nassert nlp.pipe_names == [\\\"ner\\\", \\\"textcat\\\"]\\nnlp.disable_pipe(\\\"ner\\\")\\nassert nlp.pipe_names == [\\\"textcat\\\"]\\nassert nlp.component_names == [\\\"ner\\\", \\\"textcat\\\"]\\nassert nlp.disabled == [\\\"ner\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipeline\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(InlineCode, {\n                children: \"(name, component)\"\n              }), \" tuples of the processing pipeline, in order.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.pipe_names\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Pipeline component names, in order.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.components\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"All \", _jsx(InlineCode, {\n                children: \"(name, component)\"\n              }), \" tuples, including disabled components.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.component_names\"\n              })\n            }), _jsx(_components.td, {\n              children: \"All component names, including disabled components.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp.disabled\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Names of components that are currently disabled.\"\n            })]\n          })]\n        })]\n      }), _jsx(_components.h3, {\n        id: \"sourced-components\",\n        version: \"3\",\n        children: \"Sourcing components from existing pipelines \"\n      }), _jsxs(_components.p, {\n        children: [\"Pipeline components that are independent can also be reused across pipelines.\\nInstead of adding a new blank component, you can also copy an existing component\\nfrom a trained pipeline by setting the \", _jsx(InlineCode, {\n          children: \"source\"\n        }), \" argument on\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". The first argument will then be\\ninterpreted as the name of the component in the source pipeline – for instance,\\n\", _jsx(InlineCode, {\n          children: \"\\\"ner\\\"\"\n        }), \". This is especially useful for\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config-components\",\n          children: \"training a pipeline\"\n        }), \" because it lets you mix\\nand match components and create fully custom pipeline packages with updated\\ntrained components and new components trained on your data.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note for trained components\",\n        children: _jsxs(_components.p, {\n          children: [\"When reusing components across pipelines, keep in mind that the \", _jsx(_components.strong, {\n            children: \"vocabulary\"\n          }), \",\\n\", _jsx(_components.strong, {\n            children: \"vectors\"\n          }), \" and model settings \", _jsx(_components.strong, {\n            children: \"must match\"\n          }), \". If a trained pipeline includes\\n\", _jsx(_components.a, {\n            href: \"/usage/linguistic-features#vectors-similarity\",\n            children: \"word vectors\"\n          }), \" and the component\\nuses them as features, the pipeline you copy it to needs to have the \", _jsx(_components.em, {\n            children: \"same\"\n          }), \"\\nvectors available – otherwise, it won’t be able to make the same predictions.\"]\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"In training config\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"Instead of providing a \", _jsx(InlineCode, {\n            children: \"factory\"\n          }), \", component blocks in the training\\n\", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"config\"\n          }), \" can also define a \", _jsx(InlineCode, {\n            children: \"source\"\n          }), \". The string needs\\nto be a loadable spaCy pipeline package or path.\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.ner]\\nsource = \\\"en_core_web_sm\\\"\\ncomponent = \\\"ner\\\"\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"By default, sourced components will be updated with your data during training.\\nIf you want to preserve the component as-is, you can “freeze” it if the\\npipeline is not using a shared \", _jsx(InlineCode, {\n            children: \"Tok2Vec\"\n          }), \" layer:\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[training]\\nfrozen_components = [\\\"ner\\\"]\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\n# The source pipeline with different components\\nsource_nlp = spacy.load(\\\"en_core_web_sm\\\")\\nprint(source_nlp.pipe_names)\\n\\n# Add only the entity recognizer to the new blank pipeline\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"ner\\\", source=source_nlp)\\nprint(nlp.pipe_names)\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"analysis\",\n        version: \"3\",\n        children: \"Analyzing pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#analyze_pipes\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.analyze_pipes\"\n          })\n        }), \" method analyzes the\\ncomponents in the current pipeline and outputs information about them like the\\nattributes they set on the \", _jsx(_components.a, {\n          href: \"/api/doc\",\n          children: _jsx(InlineCode, {\n            children: \"Doc\"\n          })\n        }), \" and \", _jsx(_components.a, {\n          href: \"/api/token\",\n          children: _jsx(InlineCode, {\n            children: \"Token\"\n          })\n        }), \", whether\\nthey retokenize the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and which scores they produce during training. It will\\nalso show warnings if components require values that aren’t set by previous\\ncomponent – for instance, if the entity linker is used but no component that\\nruns before it sets named entities. Setting \", _jsx(InlineCode, {\n          children: \"pretty=True\"\n        }), \" will pretty-print a\\ntable instead of only returning the structured data.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Add the components \", _jsx(InlineCode, {\n              children: \"\\\"ner\\\"\"\n            }), \" and \", _jsx(InlineCode, {\n              children: \"\\\"sentencizer\\\"\"\n            }), \" \", _jsx(_components.em, {\n              children: \"before\"\n            }), \" the\\n\", _jsx(InlineCode, {\n              children: \"\\\"entity_linker\\\"\"\n            }), \". The analysis should now show no problems, because\\nrequirements are met.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\n\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"tagger\\\")\\n# This is a problem because it needs entities and sentence boundaries\\nnlp.add_pipe(\\\"entity_linker\\\")\\nanalysis = nlp.analyze_pipes(pretty=True)\\n\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"Example output\",\n        children: [_jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-json\",\n            lang: \"json\",\n            title: \"Structured\",\n            children: \"{\\n  \\\"summary\\\": {\\n    \\\"tagger\\\": {\\n      \\\"assigns\\\": [\\\"token.tag\\\"],\\n      \\\"requires\\\": [],\\n      \\\"scores\\\": [\\\"tag_acc\\\", \\\"pos_acc\\\", \\\"lemma_acc\\\"],\\n      \\\"retokenizes\\\": false\\n    },\\n    \\\"entity_linker\\\": {\\n      \\\"assigns\\\": [\\\"token.ent_kb_id\\\"],\\n      \\\"requires\\\": [\\\"doc.ents\\\", \\\"doc.sents\\\", \\\"token.ent_iob\\\", \\\"token.ent_type\\\"],\\n      \\\"scores\\\": [],\\n      \\\"retokenizes\\\": false\\n    }\\n  },\\n  \\\"problems\\\": {\\n    \\\"tagger\\\": [],\\n    \\\"entity_linker\\\": [\\n      \\\"doc.ents\\\",\\n      \\\"doc.sents\\\",\\n      \\\"token.ent_iob\\\",\\n      \\\"token.ent_type\\\"\\n    ]\\n  },\\n  \\\"attrs\\\": {\\n    \\\"token.ent_iob\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"doc.ents\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"token.ent_kb_id\\\": { \\\"assigns\\\": [\\\"entity_linker\\\"], \\\"requires\\\": [] },\\n    \\\"doc.sents\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] },\\n    \\\"token.tag\\\": { \\\"assigns\\\": [\\\"tagger\\\"], \\\"requires\\\": [] },\\n    \\\"token.ent_type\\\": { \\\"assigns\\\": [], \\\"requires\\\": [\\\"entity_linker\\\"] }\\n  }\\n}\\n\"\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            lang: \"none\",\n            title: \"Pretty\",\n            children: \"============================= Pipeline Overview =============================\\n\\n#   Component       Assigns           Requires         Scores        Retokenizes\\n-   -------------   ---------------   --------------   -----------   -----------\\n0   tagger          token.tag                          tag_acc       False\\n\\n1   entity_linker   token.ent_kb_id   doc.ents         nel_micro_f   False\\n                                      doc.sents        nel_micro_r\\n                                      token.ent_iob    nel_micro_p\\n                                      token.ent_type\\n\\n\\n================================ Problems (4) ================================\\n⚠ 'entity_linker' requirements not met: doc.ents, doc.sents,\\ntoken.ent_iob, token.ent_type\\n\"\n          })\n        })]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        title: \"Important note\",\n        children: _jsxs(_components.p, {\n          children: [\"The pipeline analysis is static and does \", _jsx(_components.strong, {\n            children: \"not actually run the components\"\n          }), \".\\nThis means that it relies on the information provided by the components\\nthemselves. If a custom component declares that it assigns an attribute but it\\ndoesn’t, the pipeline analysis won’t catch that.\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-custom-components\",\n      children: [_jsx(_components.h2, {\n        id: \"custom-components\",\n        children: \"Creating custom pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"A pipeline component is a function that receives a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object, modifies it and\\nreturns it – for example, by using the current weights to make a prediction and\\nset some annotation on the document. By adding a component to the pipeline,\\nyou’ll get access to the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" at any point \", _jsx(_components.strong, {\n          children: \"during processing\"\n        }), \" – instead of\\nonly being able to modify it afterwards.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.language import Language\\n\\n@Language.component(\\\"my_component\\\")\\ndef my_component(doc):\\n   # Do something to the doc here\\n   return doc\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Type\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"doc\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object processed by the previous component.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.strong, {\n                children: \"RETURNS\"\n              })\n            }), _jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(InlineCode, {\n                children: \"Doc\"\n              }), \" object processed by this pipeline component.\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/language#component\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.component\"\n          })\n        }), \" decorator lets you turn a\\nsimple function into a pipeline component. It takes at least one argument, the\\n\", _jsx(_components.strong, {\n          children: \"name\"\n        }), \" of the component factory. You can use this name to add an instance of\\nyour component to the pipeline. It can also be listed in your pipeline config,\\nso you can save, load and train pipelines using your component.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Custom components can be added to the pipeline using the\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"add_pipe\"\n          })\n        }), \" method. Optionally, you can either specify\\na component to add it \", _jsx(_components.strong, {\n          children: \"before or after\"\n        }), \", tell spaCy to add it \", _jsx(_components.strong, {\n          children: \"first or\\nlast\"\n        }), \" in the pipeline, or define a \", _jsx(_components.strong, {\n          children: \"custom name\"\n        }), \". If no name is set and no\\n\", _jsx(InlineCode, {\n          children: \"name\"\n        }), \" attribute is present on your component, the function name is used.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"nlp.add_pipe(\\\"my_component\\\")\\nnlp.add_pipe(\\\"my_component\\\", first=True)\\nnlp.add_pipe(\\\"my_component\\\", before=\\\"parser\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"last\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", component is added \", _jsx(_components.strong, {\n                children: \"last\"\n              }), \" in the pipeline (default). \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"first\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"If set to \", _jsx(InlineCode, {\n                children: \"True\"\n              }), \", component is added \", _jsx(_components.strong, {\n                children: \"first\"\n              }), \" in the pipeline. \", _jsx(_components.del, {\n                children: \"bool\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"before\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name or index to add the new component \", _jsx(_components.strong, {\n                children: \"before\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[str, int]\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"after\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"String name or index to add the new component \", _jsx(_components.strong, {\n                children: \"after\"\n              }), \". \", _jsx(_components.del, {\n                children: \"Union[str, int]\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(Infobox, {\n        title: \"Changed in v3.0\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"As of v3.0, components need to be registered using the\\n\", _jsx(_components.a, {\n            href: \"/api/language#component\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.component\"\n            })\n          }), \" or\\n\", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" decorator so spaCy knows that a\\nfunction is a component. \", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            })\n          }), \" now takes the\\n\", _jsx(_components.strong, {\n            children: \"string name\"\n          }), \" of the component factory instead of the component function. This\\ndoesn’t only save you lines of code, it also allows spaCy to validate and track\\nyour custom components, and make sure they can be saved and loaded.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-diff\",\n            lang: \"diff\",\n            children: \"- ruler = nlp.create_pipe(\\\"entity_ruler\\\")\\n- nlp.add_pipe(ruler)\\n+ ruler = nlp.add_pipe(\\\"entity_ruler\\\")\\n\"\n          })\n        })]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-simple\",\n        children: \"Examples: Simple stateless pipeline components \"\n      }), _jsxs(_components.p, {\n        children: [\"The following component receives the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" in the pipeline and prints some\\ninformation about it: the number of tokens, the part-of-speech tags of the\\ntokens and a conditional message based on the document length. The\\n\", _jsx(_components.a, {\n          href: \"/api/language#component\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.component\"\n          })\n        }), \" decorator lets you register the\\ncomponent under the name \", _jsx(InlineCode, {\n          children: \"\\\"info_component\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Add the component first in the pipeline by setting \", _jsx(InlineCode, {\n              children: \"first=True\"\n            }), \". You’ll see\\nthat the part-of-speech tags are empty, because the component now runs\\nbefore the tagger and the tags aren’t available yet.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the component \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" or remove the \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" argument. You should see\\nthis change reflected in \", _jsx(InlineCode, {\n              children: \"nlp.pipe_names\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Print \", _jsx(InlineCode, {\n              children: \"nlp.pipeline\"\n            }), \". You’ll see a list of tuples describing the component\\nname and the function that’s called on the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" object in the pipeline.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the first argument to \", _jsx(InlineCode, {\n              children: \"@Language.component\"\n            }), \", the name, to something\\nelse. spaCy should now complain that it doesn’t know a component of the\\nname \", _jsx(InlineCode, {\n              children: \"\\\"info_component\\\"\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"info_component\\\")\\ndef my_component(doc):\\n    print(f\\\"After tokenization, this doc has {len(doc)} tokens.\\\")\\n    print(\\\"The part-of-speech tags are:\\\", [token.pos_ for token in doc])\\n    if len(doc) \u003c 10:\\n        print(\\\"This is a pretty short document.\\\")\\n    return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"info_component\\\", name=\\\"print_info\\\", last=True)\\nprint(nlp.pipe_names)  # ['tagger', 'parser', 'ner', 'print_info']\\ndoc = nlp(\\\"This is a sentence.\\\")\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Here’s another example of a pipeline component that implements custom logic to\\nimprove the sentence boundaries set by the dependency parser. The custom logic\\nshould therefore be applied \", _jsx(_components.strong, {\n          children: \"after\"\n        }), \" tokenization, but \", _jsx(_components.em, {\n          children: \"before\"\n        }), \" the dependency\\nparsing – this way, the parser can also take advantage of the sentence\\nboundaries.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Print \", _jsx(InlineCode, {\n              children: \"[token.dep_ for token in doc]\"\n            }), \" with and without the custom pipeline\\ncomponent. You’ll see that the predicted dependency parse changes to match\\nthe sentence boundaries.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Remove the \", _jsx(InlineCode, {\n              children: \"else\"\n            }), \" block. All other tokens will now have \", _jsx(InlineCode, {\n              children: \"is_sent_start\"\n            }), \" set\\nto \", _jsx(InlineCode, {\n              children: \"None\"\n            }), \" (missing value), the parser will assign sentence boundaries in\\nbetween.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"custom_sentencizer\\\")\\ndef custom_sentencizer(doc):\\n    for i, token in enumerate(doc[:-2]):\\n        # Define sentence start if pipe + titlecase token\\n        if token.text == \\\"|\\\" and doc[i + 1].is_title:\\n            doc[i + 1].is_sent_start = True\\n        else:\\n            # Explicitly set sentence start to False otherwise, to tell\\n            # the parser to leave those tokens alone\\n            doc[i + 1].is_sent_start = False\\n    return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"custom_sentencizer\\\", before=\\\"parser\\\")  # Insert before the parser\\ndoc = nlp(\\\"This is. A sentence. | This is. Another sentence.\\\")\\nfor sent in doc.sents:\\n    print(sent.text)\\n\"\n        })\n      }), _jsx(_components.h3, {\n        id: \"custom-components-factories\",\n        children: \"Component factories and stateful components \"\n      }), _jsxs(_components.p, {\n        children: [\"Component factories are callables that take settings and return a \", _jsx(_components.strong, {\n          children: \"pipeline\\ncomponent function\"\n        }), \". This is useful if your component is stateful and if you\\nneed to customize their creation, or if you need access to the current \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\nobject or the shared vocab. Component factories can be registered using the\\n\", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \" decorator and they need at least\\n\", _jsx(_components.strong, {\n          children: \"two named arguments\"\n        }), \" that are filled in automatically when the component is\\nadded to the pipeline:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.language import Language\\n\\n@Language.factory(\\\"my_component\\\")\\ndef my_component(nlp, name):\\n    return MyComponent()\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Argument\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"nlp\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The current \", _jsx(InlineCode, {\n                children: \"nlp\"\n              }), \" object. Can be used to access the shared vocab. \", _jsx(_components.del, {\n                children: \"Language\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"name\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"The \", _jsx(_components.strong, {\n                children: \"instance name\"\n              }), \" of the component in the pipeline. This lets you identify different instances of the same component. \", _jsx(_components.del, {\n                children: \"str\"\n              })]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"All other settings can be passed in by the user via the \", _jsx(InlineCode, {\n          children: \"config\"\n        }), \" argument on\\n\", _jsx(_components.a, {\n          href: \"/api/language\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". The\\n\", _jsx(_components.a, {\n          href: \"/api/language#factory\",\n          children: _jsx(InlineCode, {\n            children: \"@Language.factory\"\n          })\n        }), \" decorator also lets you define a\\n\", _jsx(InlineCode, {\n          children: \"default_config\"\n        }), \" that’s used as a fallback.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"With config\",\n          highlight: \"4,9\",\n          children: \"import spacy\\nfrom spacy.language import Language\\n\\n@Language.factory(\\\"my_component\\\", default_config={\\\"some_setting\\\": True})\\ndef my_component(nlp, name, some_setting: bool):\\n    return MyComponent(some_setting=some_setting)\\n\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"my_component\\\", config={\\\"some_setting\\\": False})\\n\"\n        })\n      }), _jsxs(Accordion, {\n        title: \"How is @Language.factory different from @Language.component?\",\n        id: \"factories-decorator-component\",\n        children: [_jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/language#component\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.component\"\n            })\n          }), \" decorator is essentially a\\n\", _jsx(_components.strong, {\n            children: \"shortcut\"\n          }), \" for stateless pipeline components that don’t need any settings.\\nThis means you don’t have to always write a function that returns your function\\nif there’s no state to be passed through – spaCy can just take care of this for\\nyou. The following two code examples are equivalent:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"# Stateless component with @Language.factory\\n@Language.factory(\\\"my_component\\\")\\ndef create_my_component():\\n    def my_component(doc):\\n        # Do something to the doc\\n        return doc\\n\\n    return my_component\\n\\n# Stateless component with @Language.component\\n@Language.component(\\\"my_component\\\")\\ndef my_component(doc):\\n    # Do something to the doc\\n    return doc\\n\"\n          })\n        })]\n      }), _jsx(Accordion, {\n        title: \"Can I add the @Language.factory decorator to a class?\",\n        id: \"factories-class-decorator\",\n        spaced: true,\n        children: _jsxs(_components.p, {\n          children: [\"Yes, the \", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" decorator can be added to\\na function or a class. If it’s added to a class, it expects the \", _jsx(InlineCode, {\n            children: \"__init__\"\n          }), \"\\nmethod to take the arguments \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"name\"\n          }), \", and will populate all other\\narguments from the config. That said, it’s often cleaner and more intuitive to\\nmake your factory a separate function. That’s also how spaCy does it internally.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"factories-language\",\n        version: \"3\",\n        children: \"Language-specific factories \"\n      }), _jsxs(_components.p, {\n        children: [\"There are many use cases where you might want your pipeline components to be\\nlanguage-specific. Sometimes this requires entirely different implementation per\\nlanguage, sometimes the only difference is in the settings or data. spaCy allows\\nyou to register factories of the \", _jsx(_components.strong, {\n          children: \"same name\"\n        }), \" on both the \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" base\\nclass, as well as its \", _jsx(_components.strong, {\n          children: \"subclasses\"\n        }), \" like \", _jsx(InlineCode, {\n          children: \"English\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"German\"\n        }), \". Factories are\\nresolved starting with the specific subclass. If the subclass doesn’t define a\\ncomponent of that name, spaCy will check the \", _jsx(InlineCode, {\n          children: \"Language\"\n        }), \" base class.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Here’s an example of a pipeline component that overwrites the normalized form of\\na token, the \", _jsx(InlineCode, {\n          children: \"Token.norm_\"\n        }), \" with an entry from a language-specific lookup table.\\nIt’s registered twice under the name \", _jsx(InlineCode, {\n          children: \"\\\"token_normalizer\\\"\"\n        }), \" – once using\\n\", _jsx(InlineCode, {\n          children: \"@English.factory\"\n        }), \" and once using \", _jsx(InlineCode, {\n          children: \"@German.factory\"\n        }), \":\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"from spacy.lang.en import English\\nfrom spacy.lang.de import German\\n\\nclass TokenNormalizer:\\n    def __init__(self, norm_table):\\n        self.norm_table = norm_table\\n\\n    def __call__(self, doc):\\n        for token in doc:\\n            # Overwrite the token.norm_ if there's an entry in the data\\n            token.norm_ = self.norm_table.get(token.text, token.norm_)\\n        return doc\\n\\n@English.factory(\\\"token_normalizer\\\")\\ndef create_en_normalizer(nlp, name):\\n    return TokenNormalizer({\\\"realise\\\": \\\"realize\\\", \\\"colour\\\": \\\"color\\\"})\\n\\n@German.factory(\\\"token_normalizer\\\")\\ndef create_de_normalizer(nlp, name):\\n    return TokenNormalizer({\\\"daß\\\": \\\"dass\\\", \\\"wußte\\\": \\\"wusste\\\"})\\n\\nnlp_en = English()\\nnlp_en.add_pipe(\\\"token_normalizer\\\")  # uses the English factory\\nprint([token.norm_ for token in nlp_en(\\\"realise colour daß wußte\\\")])\\n\\nnlp_de = German()\\nnlp_de.add_pipe(\\\"token_normalizer\\\")  # uses the German factory\\nprint([token.norm_ for token in nlp_de(\\\"realise colour daß wußte\\\")])\\n\"\n        })\n      }), _jsx(Infobox, {\n        title: \"Implementation details\",\n        children: _jsxs(_components.p, {\n          children: [\"Under the hood, language-specific factories are added to the\\n\", _jsxs(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: [_jsx(InlineCode, {\n              children: \"factories\"\n            }), \" registry\"]\n          }), \" prefixed with the language code,\\ne.g. \", _jsx(InlineCode, {\n            children: \"\\\"en.token_normalizer\\\"\"\n          }), \". When resolving the factory in\\n\", _jsx(_components.a, {\n            href: \"/api/language#add_pipe\",\n            children: _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            })\n          }), \", spaCy first checks for a\\nlanguage-specific version of the factory using \", _jsx(InlineCode, {\n            children: \"nlp.lang\"\n          }), \" and if none is\\navailable, falls back to looking up the regular factory name.\"]\n        })\n      }), _jsx(_components.h3, {\n        id: \"example-stateful-components\",\n        children: \"Example: Stateful component with settings \"\n      }), _jsxs(_components.p, {\n        children: [\"This example shows a \", _jsx(_components.strong, {\n          children: \"stateful\"\n        }), \" pipeline component for handling acronyms:\\nbased on a dictionary, it will detect acronyms and their expanded forms in both\\ndirections and add them to a list as the custom \", _jsx(InlineCode, {\n          children: \"doc._.acronyms\"\n        }), \"\\n\", _jsx(_components.a, {\n          href: \"#custom-components-attributes\",\n          children: \"extension attribute\"\n        }), \". Under the hood, it uses\\nthe \", _jsx(_components.a, {\n          href: \"/api/phrasematcher\",\n          children: _jsx(InlineCode, {\n            children: \"PhraseMatcher\"\n          })\n        }), \" to find instances of the phrases.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The factory function takes three arguments: the shared \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object and\\ncomponent instance \", _jsx(InlineCode, {\n          children: \"name\"\n        }), \", which are passed in automatically by spaCy, and a\\n\", _jsx(InlineCode, {\n          children: \"case_sensitive\"\n        }), \" config setting that makes the matching and acronym detection\\ncase-sensitive.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" and set \", _jsx(InlineCode, {\n              children: \"\\\"case_sensitive\\\"\"\n            }), \" to\\n\", _jsx(InlineCode, {\n              children: \"True\"\n            }), \". You should see that the expanded acronym for “LOL” isn’t detected\\nanymore.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Add some more terms to the \", _jsx(InlineCode, {\n              children: \"DICTIONARY\"\n            }), \" and update the processed text so\\nthey’re detected.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Add a \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" argument to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" to change the component name. Print\\n\", _jsx(InlineCode, {\n              children: \"nlp.pipe_names\"\n            }), \" to see the change reflected in the pipeline.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Print the config of the current \", _jsx(InlineCode, {\n              children: \"nlp\"\n            }), \" object with\\n\", _jsx(InlineCode, {\n              children: \"print(nlp.config.to_str())\"\n            }), \" and inspect the \", _jsx(InlineCode, {\n              children: \"[components]\"\n            }), \" block. You\\nshould see an entry for the acronyms component, referencing the factory\\n\", _jsx(InlineCode, {\n              children: \"acronyms\"\n            }), \" and the config settings.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"from spacy.language import Language\\nfrom spacy.tokens import Doc\\nfrom spacy.matcher import PhraseMatcher\\nimport spacy\\n\\nDICTIONARY = {\\\"lol\\\": \\\"laughing out loud\\\", \\\"brb\\\": \\\"be right back\\\"}\\nDICTIONARY.update({value: key for key, value in DICTIONARY.items()})\\n\\n@Language.factory(\\\"acronyms\\\", default_config={\\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, case_sensitive: bool):\\n    return AcronymComponent(nlp, case_sensitive)\\n\\nclass AcronymComponent:\\n    def __init__(self, nlp: Language, case_sensitive: bool):\\n        # Create the matcher and match on Token.lower if case-insensitive\\n        matcher_attr = \\\"TEXT\\\" if case_sensitive else \\\"LOWER\\\"\\n        self.matcher = PhraseMatcher(nlp.vocab, attr=matcher_attr)\\n        self.matcher.add(\\\"ACRONYMS\\\", [nlp.make_doc(term) for term in DICTIONARY])\\n        self.case_sensitive = case_sensitive\\n        # Register custom extension on the Doc\\n        if not Doc.has_extension(\\\"acronyms\\\"):\\n            Doc.set_extension(\\\"acronyms\\\", default=[])\\n\\n    def __call__(self, doc: Doc) -\u003e Doc:\\n        # Add the matched spans when doc is processed\\n        for _, start, end in self.matcher(doc):\\n            span = doc[start:end]\\n            acronym = DICTIONARY.get(span.text if self.case_sensitive else span.text.lower())\\n            doc._.acronyms.append((span, acronym))\\n        return doc\\n\\n# Add the component to the pipeline and configure it\\nnlp = spacy.blank(\\\"en\\\")\\nnlp.add_pipe(\\\"acronyms\\\", config={\\\"case_sensitive\\\": False})\\n\\n# Process a doc and see the results\\ndoc = nlp(\\\"LOL, be right back\\\")\\nprint(doc._.acronyms)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-component-data\",\n      children: [_jsx(_components.h2, {\n        id: \"component-data\",\n        children: \"Initializing and serializing component data \"\n      }), _jsxs(_components.p, {\n        children: [\"Many stateful components depend on \", _jsx(_components.strong, {\n          children: \"data resources\"\n        }), \" like dictionaries and\\nlookup tables that should ideally be \", _jsx(_components.strong, {\n          children: \"configurable\"\n        }), \". For example, it makes\\nsense to make the \", _jsx(InlineCode, {\n          children: \"DICTIONARY\"\n        }), \" in the above example an argument of the\\nregistered function, so the \", _jsx(InlineCode, {\n          children: \"AcronymComponent\"\n        }), \" can be re-used with different\\ndata. One logical solution would be to make it an argument of the component\\nfactory, and allow it to be initialized with different dictionaries.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.acronyms.data]\\n# 🚨 Problem: you don't want the data in the config\\nlol = \\\"laugh out loud\\\"\\nbrb = \\\"be right back\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"@Language.factory(\\\"acronyms\\\", default_config={\\\"data\\\": {}, \\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, data: Dict[str, str], case_sensitive: bool):\\n    # 🚨 Problem: data ends up in the config file\\n    return AcronymComponent(nlp, data, case_sensitive)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"However, passing in the dictionary directly is problematic, because it means\\nthat if a component saves out its config and settings, the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: _jsx(InlineCode, {\n            children: \"config.cfg\"\n          })\n        }), \" will include a dump of the entire data,\\nsince that’s the config the component was created with. It will also fail if the\\ndata is not JSON-serializable.\"]\n      }), _jsx(_components.h3, {\n        id: \"component-data-function\",\n        children: \"Option 1: Using a registered function \"\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"✅ \", _jsx(_components.strong, {\n              children: \"Pros:\"\n            }), \" can load anything in Python, easy to add to and configure via\\nconfig\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"❌ \", _jsx(_components.strong, {\n              children: \"Cons:\"\n            }), \" requires the function and its dependencies to be available at\\nruntime\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"If what you’re passing in isn’t JSON-serializable – e.g. a custom object like a\\n\", _jsx(_components.a, {\n          href: \"#trainable-components\",\n          children: \"model\"\n        }), \" – saving out the component config becomes\\nimpossible because there’s no way for spaCy to know \", _jsx(_components.em, {\n          children: \"how\"\n        }), \" that object was\\ncreated, and what to do to create it again. This makes it much harder to save,\\nload and train custom pipelines with custom components. A simple solution is to\\n\", _jsx(_components.strong, {\n          children: \"register a function\"\n        }), \" that returns your resources. The\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#registry\",\n          children: \"registry\"\n        }), \" lets you \", _jsx(_components.strong, {\n          children: \"map string names to functions\"\n        }), \"\\nthat create objects, so given a name and optional arguments, spaCy will know how\\nto recreate the object. To register a function that returns your custom\\ndictionary, you can use the \", _jsx(InlineCode, {\n          children: \"@spacy.registry.misc\"\n        }), \" decorator with a single\\nargument, the name:\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"What’s the misc registry?\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: _jsx(InlineCode, {\n              children: \"registry\"\n            })\n          }), \" provides different categories for\\ndifferent types of functions – for example, model architectures, tokenizers or\\nbatchers. \", _jsx(InlineCode, {\n            children: \"misc\"\n          }), \" is intended for miscellaneous functions that don’t fit\\nanywhere else.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Registered function for assets\",\n          highlight: \"1\",\n          children: \"@spacy.registry.misc(\\\"acronyms.slang_dict.v1\\\")\\ndef create_acronyms_slang_dict():\\n    dictionary = {\\\"lol\\\": \\\"laughing out loud\\\", \\\"brb\\\": \\\"be right back\\\"}\\n    dictionary.update({value: key for key, value in dictionary.items()})\\n    return dictionary\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In your \", _jsx(InlineCode, {\n          children: \"default_config\"\n        }), \" (and later in your\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"training config\"\n        }), \"), you can now refer to the function\\nregistered under the name \", _jsx(InlineCode, {\n          children: \"\\\"acronyms.slang_dict.v1\\\"\"\n        }), \" using the \", _jsx(InlineCode, {\n          children: \"@misc\"\n        }), \" key. This\\ntells spaCy how to create the value, and when your component is created, the\\nresult of the registered function is passed in as the key \", _jsx(InlineCode, {\n          children: \"\\\"dictionary\\\"\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[components.acronyms]\\nfactory = \\\"acronyms\\\"\\n\\n[components.acronyms.data]\\n@misc = \\\"acronyms.slang_dict.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-diff\",\n          lang: \"diff\",\n          children: \"- default_config = {\\\"dictionary:\\\" DICTIONARY}\\n+ default_config = {\\\"dictionary\\\": {\\\"@misc\\\": \\\"acronyms.slang_dict.v1\\\"}}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Using a registered function also means that you can easily include your custom\\ncomponents in pipelines that you \", _jsx(_components.a, {\n          href: \"/usage/training\",\n          children: \"train\"\n        }), \". To make sure spaCy\\nknows where to find your custom \", _jsx(InlineCode, {\n          children: \"@misc\"\n        }), \" function, you can pass in a Python file\\nvia the argument \", _jsx(InlineCode, {\n          children: \"--code\"\n        }), \". If someone else is using your component, all they\\nhave to do to customize the data is to register their own function and swap out\\nthe name. Registered functions can also take \", _jsx(_components.strong, {\n          children: \"arguments\"\n        }), \", by the way, that can\\nbe defined in the config as well – you can read more about this in the docs on\\n\", _jsx(_components.a, {\n          href: \"/usage/training#custom-code\",\n          children: \"training with custom code\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"component-data-initialization\",\n        children: \"Option 2: Save data with the pipeline and load it in once on initialization \"\n      }), _jsx(Infobox, {\n        children: _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"✅ \", _jsx(_components.strong, {\n              children: \"Pros:\"\n            }), \" lets components save and load their own data and reflect user\\nchanges, load in data assets before training without depending on them at\\nruntime\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"❌ \", _jsx(_components.strong, {\n              children: \"Cons:\"\n            }), \" requires more component methods, more complex config and data\\nflow\"]\n          }), \"\\n\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Just like models save out their binary weights when you call\\n\", _jsx(_components.a, {\n          href: \"/api/language#to_disk\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.to_disk\"\n          })\n        }), \", components can also \", _jsx(_components.strong, {\n          children: \"serialize\"\n        }), \" any\\nother data assets – for instance, an acronym dictionary. If a pipeline component\\nimplements its own \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" methods, those will be called\\nautomatically by \", _jsx(InlineCode, {\n          children: \"nlp.to_disk\"\n        }), \" and will receive the path to the directory to\\nsave to or load from. The component can then perform any custom saving or\\nloading. If a user makes changes to the component data, they will be reflected\\nwhen the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object is saved. For more examples of this, see the usage guide\\non \", _jsx(_components.a, {\n          href: \"/usage/saving-loading/#serialization-methods\",\n          children: \"serialization methods\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"About the data path\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(InlineCode, {\n            children: \"path\"\n          }), \" argument spaCy passes to the serialization methods consists of the\\npath provided by the user, plus a directory of the component name. This means\\nthat when you call \", _jsx(InlineCode, {\n            children: \"nlp.to_disk(\\\"/path\\\")\"\n          }), \", the \", _jsx(InlineCode, {\n            children: \"acronyms\"\n          }), \" component will\\nreceive the directory path \", _jsx(InlineCode, {\n            children: \"/path/acronyms\"\n          }), \" and can then create files in this\\ndirectory.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Custom serialization methods\",\n          highlight: \"7-11,13-15\",\n          children: \"import srsly\\nfrom spacy.util import ensure_path\\n\\nclass AcronymComponent:\\n    # other methods here...\\n\\n    def to_disk(self, path, exclude=tuple()):\\n        path = ensure_path(path)\\n        if not path.exists():\\n            path.mkdir()\\n        srsly.write_json(path / \\\"data.json\\\", self.data)\\n\\n    def from_disk(self, path, exclude=tuple()):\\n        self.data = srsly.read_json(path / \\\"data.json\\\")\\n        return self\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Now the component can save to and load from a directory. The only remaining\\nquestion: How do you \", _jsx(_components.strong, {\n          children: \"load in the initial data\"\n        }), \"? In Python, you could just\\ncall the pipe’s \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method yourself. But if you’re adding the component\\nto your \", _jsx(_components.a, {\n          href: \"/usage/training#config\",\n          children: \"training config\"\n        }), \", spaCy will need to know how\\nto set it up, from start to finish, including the data to initialize it with.\"]\n      }), _jsxs(_components.p, {\n        children: [\"While you could use a registered function or a file loader like\\n\", _jsx(_components.a, {\n          href: \"/api/top-level#file_readers\",\n          children: _jsx(InlineCode, {\n            children: \"srsly.read_json.v1\"\n          })\n        }), \" as an argument of the\\ncomponent factory, this approach is problematic: the component factory runs\\n\", _jsx(_components.strong, {\n          children: \"every time the component is created\"\n        }), \". This means it will run when creating\\nthe \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object before training, but also every time a user loads your\\npipeline. So your runtime pipeline would either depend on a local path on your\\nfile system, or it’s loaded twice: once when the component is created, and then\\nagain when the data is by \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[components.acronyms.data]\\n# 🚨 Problem: Runtime pipeline depends on local path\\n@readers = \\\"srsly.read_json.v1\\\"\\npath = \\\"/path/to/slang_dict.json\\\"\\n\"\n          })\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg\",\n            children: \"[components.acronyms.data]\\n# 🚨 Problem: this always runs\\n@misc = \\\"acronyms.slang_dict.v1\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          children: \"@Language.factory(\\\"acronyms\\\", default_config={\\\"data\\\": {}, \\\"case_sensitive\\\": False})\\ndef create_acronym_component(nlp: Language, name: str, data: Dict[str, str], case_sensitive: bool):\\n    # 🚨 Problem: data will be loaded every time component is created\\n    return AcronymComponent(nlp, data, case_sensitive)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"To solve this, your component can implement a separate method, \", _jsx(InlineCode, {\n          children: \"initialize\"\n        }), \",\\nwhich will be called by \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" if\\navailable. This typically happens before training, but not at runtime when the\\npipeline is loaded. For more background on this, see the usage guides on the\\n\", _jsx(_components.a, {\n          href: \"/usage/training#config-lifecycle\",\n          children: \"config lifecycle\"\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/usage/training#initialization\",\n          children: \"custom initialization\"\n        }), \".\"]\n      }), _jsx(_components.img, {\n        src: \"/images/lifecycle.svg\",\n        alt: \"Illustration of pipeline lifecycle\"\n      }), _jsxs(_components.p, {\n        children: [\"A component’s \", _jsx(InlineCode, {\n          children: \"initialize\"\n        }), \" method needs to take at least \", _jsx(_components.strong, {\n          children: \"two named\\narguments\"\n        }), \": a \", _jsx(InlineCode, {\n          children: \"get_examples\"\n        }), \" callback that gives it access to the training\\nexamples, and the current \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object. This is mostly used by trainable\\ncomponents so they can initialize their models and label schemes from the data,\\nso we can ignore those arguments here. All \", _jsx(_components.strong, {\n          children: \"other arguments\"\n        }), \" on the method can\\nbe defined via the config – in this case a dictionary \", _jsx(InlineCode, {\n          children: \"data\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"config.cfg\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            children: \"[initialize.components.my_component]\\n\\n[initialize.components.my_component.data]\\n# ✅ This only runs on initialization\\n@readers = \\\"srsly.read_json.v1\\\"\\npath = \\\"/path/to/slang_dict.json\\\"\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Custom initialize method\",\n          highlight: \"5-6\",\n          children: \"class AcronymComponent:\\n    def __init__(self):\\n        self.data = {}\\n\\n    def initialize(self, get_examples=None, nlp=None, data={}):\\n        self.data = data\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"When \", _jsx(_components.a, {\n          href: \"/api/language#initialize\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.initialize\"\n          })\n        }), \" runs before training (or when\\nyou call it in your own code), the\\n\", _jsx(_components.a, {\n          href: \"/api/data-formats#config-initialize\",\n          children: _jsx(InlineCode, {\n            children: \"[initialize]\"\n          })\n        }), \" block of the config is\\nloaded and used to construct the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object. The custom acronym component will\\nthen be passed the data loaded from the JSON file. After training, the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \"\\nobject is saved to disk, which will run the component’s \", _jsx(InlineCode, {\n          children: \"to_disk\"\n        }), \" method. When\\nthe pipeline is loaded back into spaCy later to use it, the \", _jsx(InlineCode, {\n          children: \"from_disk\"\n        }), \" method\\nwill load the data back in.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-type-hints\",\n      children: [_jsx(_components.h2, {\n        id: \"type-hints\",\n        version: \"3\",\n        children: \"Python type hints and validation \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy’s configs are powered by our machine learning library Thinc’s\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-config\",\n          children: \"configuration system\"\n        }), \", which supports\\n\", _jsx(_components.a, {\n          href: \"https://docs.python.org/3/library/typing.html\",\n          children: \"type hints\"\n        }), \" and even\\n\", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/usage-config#advanced-types\",\n          children: \"advanced type annotations\"\n        }), \"\\nusing \", _jsx(_components.a, {\n          href: \"https://github.com/samuelcolvin/pydantic\",\n          children: _jsx(InlineCode, {\n            children: \"pydantic\"\n          })\n        }), \". If your component\\nfactory provides type hints, the values that are passed in will be \", _jsx(_components.strong, {\n          children: \"checked\\nagainst the expected types\"\n        }), \". If the value can’t be cast to an integer, spaCy\\nwill raise an error. \", _jsx(InlineCode, {\n          children: \"pydantic\"\n        }), \" also provides strict types like \", _jsx(InlineCode, {\n          children: \"StrictFloat\"\n        }), \",\\nwhich will force the value to be an integer and raise an error if it’s not – for\\ninstance, if your config defines a float.\"]\n      }), _jsx(Infobox, {\n        variant: \"warning\",\n        children: _jsxs(_components.p, {\n          children: [\"If you’re not using\\n\", _jsx(_components.a, {\n            href: \"https://pydantic-docs.helpmanual.io/usage/types/#strict-types\",\n            children: \"strict types\"\n          }), \",\\nvalues that can be \", _jsx(_components.strong, {\n            children: \"cast to\"\n          }), \" the given type will still be accepted. For\\nexample, \", _jsx(InlineCode, {\n            children: \"1\"\n          }), \" can be cast to a \", _jsx(InlineCode, {\n            children: \"float\"\n          }), \" or a \", _jsx(InlineCode, {\n            children: \"bool\"\n          }), \" type, but not to a\\n\", _jsx(InlineCode, {\n            children: \"List[str]\"\n          }), \". However, if the type is\\n\", _jsx(_components.a, {\n            href: \"https://pydantic-docs.helpmanual.io/usage/types/#strict-types\",\n            children: _jsx(InlineCode, {\n              children: \"StrictFloat\"\n            })\n          }), \",\\nonly a float will be accepted.\"]\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The following example shows a custom pipeline component for debugging. It can be\\nadded anywhere in the pipeline and logs information about the \", _jsx(InlineCode, {\n          children: \"nlp\"\n        }), \" object and\\nthe \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" that passes through. The \", _jsx(InlineCode, {\n          children: \"log_level\"\n        }), \" config setting lets the user\\ncustomize what log statements are shown – for instance, \", _jsx(InlineCode, {\n          children: \"\\\"INFO\\\"\"\n        }), \" will show info\\nlogs and more critical logging statements, whereas \", _jsx(InlineCode, {\n          children: \"\\\"DEBUG\\\"\"\n        }), \" will show\\neverything. The value is annotated as a \", _jsx(InlineCode, {\n          children: \"StrictStr\"\n        }), \", so it will only accept a\\nstring value.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"✏️ Things to try\"\n        }), \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" to use the log level \", _jsx(InlineCode, {\n              children: \"\\\"INFO\\\"\"\n            }), \".\\nYou should see that only the statement logged with \", _jsx(InlineCode, {\n              children: \"logger.info\"\n            }), \" is shown.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Change the \", _jsx(InlineCode, {\n              children: \"config\"\n            }), \" passed to \", _jsx(InlineCode, {\n              children: \"nlp.add_pipe\"\n            }), \" so that it contains unexpected\\nvalues – for example, a boolean instead of a string: \", _jsx(InlineCode, {\n              children: \"\\\"log_level\\\": False\"\n            }), \".\\nYou should see a validation error.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Check out the docs on \", _jsx(InlineCode, {\n              children: \"pydantic\"\n            }), \"’s\\n\", _jsx(_components.a, {\n              href: \"https://pydantic-docs.helpmanual.io/usage/types/#constrained-types\",\n              children: \"constrained types\"\n            }), \"\\nand write a type hint for \", _jsx(InlineCode, {\n              children: \"log_level\"\n            }), \" that only accepts the exact string\\nvalues \", _jsx(InlineCode, {\n              children: \"\\\"DEBUG\\\"\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"\\\"INFO\\\"\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"\\\"CRITICAL\\\"\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import spacy\\nfrom spacy.language import Language\\nfrom spacy.tokens import Doc\\nfrom pydantic import StrictStr\\nimport logging\\n\\n@Language.factory(\\\"debug\\\", default_config={\\\"log_level\\\": \\\"DEBUG\\\"})\\nclass DebugComponent:\\n    def __init__(self, nlp: Language, name: str, log_level: StrictStr):\\n        self.logger = logging.getLogger(f\\\"spacy.{name}\\\")\\n        self.logger.setLevel(log_level)\\n        self.logger.info(f\\\"Pipeline: {nlp.pipe_names}\\\")\\n\\n    def __call__(self, doc: Doc) -\u003e Doc:\\n        is_tagged = doc.has_annotation(\\\"TAG\\\")\\n        self.logger.debug(f\\\"Doc: {len(doc)} tokens, is tagged: {is_tagged}\\\")\\n        return doc\\n\\nnlp = spacy.load(\\\"en_core_web_sm\\\")\\nnlp.add_pipe(\\\"debug\\\", config={\\\"log_level\\\": \\\"DEBUG\\\"})\\ndoc = nlp(\\\"This is a text...\\\")\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-trainable-components\",\n      children: [_jsx(_components.h2, {\n        id: \"trainable-components\",\n        version: \"3\",\n        children: \"Trainable components \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy’s \", _jsx(_components.a, {\n          href: \"/api/pipe\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe\"\n          })\n        }), \" class helps you implement your own\\ntrainable components that have their own model instance, make predictions over\\n\", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" objects and can be updated using \", _jsx(_components.a, {\n          href: \"/api/cli#train\",\n          children: _jsx(InlineCode, {\n            children: \"spacy train\"\n          })\n        }), \". This\\nlets you plug fully custom machine learning components into your pipeline.\"]\n      }), _jsx(_components.img, {\n        src: \"/images/trainable_component.svg\",\n        alt: \"Illustration of Pipe methods\"\n      }), _jsx(_components.p, {\n        children: \"You’ll need the following:\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Model:\"\n          }), \" A Thinc \", _jsx(_components.a, {\n            href: \"https://thinc.ai/docs/api-model\",\n            children: _jsx(InlineCode, {\n              children: \"Model\"\n            })\n          }), \" instance. This\\ncan be a model implemented in \", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#thinc\",\n            children: \"Thinc\"\n          }), \", or\\na \", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#frameworks\",\n            children: \"wrapped model\"\n          }), \" implemented in\\nPyTorch, TensorFlow, MXNet or a fully custom solution. The model must take a\\nlist of \", _jsx(_components.a, {\n            href: \"/api/doc\",\n            children: _jsx(InlineCode, {\n              children: \"Doc\"\n            })\n          }), \" objects as input and can have any type of output.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"TrainablePipe subclass:\"\n          }), \" A subclass of \", _jsx(_components.a, {\n            href: \"/api/pipe\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe\"\n            })\n          }), \" that\\nimplements at least two methods: \", _jsx(_components.a, {\n            href: \"/api/pipe#predict\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe.predict\"\n            })\n          }), \"\\nand \", _jsx(_components.a, {\n            href: \"/api/pipe#set_annotations\",\n            children: _jsx(InlineCode, {\n              children: \"TrainablePipe.set_annotations\"\n            })\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Component factory:\"\n          }), \" A component factory registered with\\n\", _jsx(_components.a, {\n            href: \"/api/language#factory\",\n            children: _jsx(InlineCode, {\n              children: \"@Language.factory\"\n            })\n          }), \" that takes the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object and\\ncomponent \", _jsx(InlineCode, {\n            children: \"name\"\n          }), \" and optional settings provided by the config and returns an\\ninstance of your trainable component.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"from spacy.pipeline import TrainablePipe\\nfrom spacy.language import Language\\n\\nclass TrainableComponent(TrainablePipe):\\n    def predict(self, docs):\\n        ...\\n\\n    def set_annotations(self, docs, scores):\\n        ...\\n\\n@Language.factory(\\\"my_trainable_component\\\")\\ndef make_component(nlp, name, model):\\n    return TrainableComponent(nlp.vocab, model, name=name)\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#predict\",\n                children: _jsx(InlineCode, {\n                  children: \"predict\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Apply the component’s model to a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects (without modifying them) and return the scores.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#set_annotations\",\n                children: _jsx(InlineCode, {\n                  children: \"set_annotations\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Modify a batch of \", _jsx(_components.a, {\n                href: \"/api/doc\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc\"\n                })\n              }), \" objects, using pre-computed scores generated by \", _jsx(InlineCode, {\n                children: \"predict\"\n              }), \".\"]\n            })]\n          })]\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"By default, \", _jsx(_components.a, {\n          href: \"/api/pipe#init\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe.__init__\"\n          })\n        }), \" takes the shared vocab,\\nthe \", _jsx(_components.a, {\n          href: \"https://thinc.ai/docs/api-model\",\n          children: _jsx(InlineCode, {\n            children: \"Model\"\n          })\n        }), \" and the name of the component\\ninstance in the pipeline, which you can use as a key in the losses. All other\\nkeyword arguments will become available as \", _jsx(_components.a, {\n          href: \"/api/pipe#cfg\",\n          children: _jsx(InlineCode, {\n            children: \"TrainablePipe.cfg\"\n          })\n        }), \"\\nand will also be serialized with the component.\"]\n      }), _jsxs(Accordion, {\n        title: \"Why components should be passed a Model instance, not create it\",\n        spaced: true,\n        children: [_jsxs(_components.p, {\n          children: [\"spaCy’s \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"config system\"\n          }), \" resolves the config describing\\nthe pipeline components and models \", _jsx(_components.strong, {\n            children: \"bottom-up\"\n          }), \". This means that it will\\n\", _jsx(_components.em, {\n            children: \"first\"\n          }), \" create a \", _jsx(InlineCode, {\n            children: \"Model\"\n          }), \" from a \", _jsx(_components.a, {\n            href: \"/api/architectures\",\n            children: \"registered architecture\"\n          }), \",\\nvalidate its arguments and \", _jsx(_components.em, {\n            children: \"then\"\n          }), \" pass the object forward to the component. This\\nmeans that the config can express very complex, nested trees of objects – but\\nthe objects don’t have to pass the model settings all the way down to the\\ncomponents. It also makes the components more \", _jsx(_components.strong, {\n            children: \"modular\"\n          }), \" and lets you\\n\", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#swap-architectures\",\n            children: \"swap\"\n          }), \" different architectures\\nin your config, and re-use model definitions.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-ini\",\n            lang: \"ini\",\n            title: \"config.cfg (excerpt)\",\n            children: \"[components]\\n\\n[components.textcat]\\nfactory = \\\"textcat\\\"\\nlabels = []\\n\\n# This function is created and then passed to the \\\"textcat\\\" component as\\n# the argument \\\"model\\\"\\n[components.textcat.model]\\n@architectures = \\\"spacy.TextCatBOW.v2\\\"\\nexclusive_classes = true\\nngram_size = 1\\nno_output_layer = false\\n\\n[components.other_textcat]\\nfactory = \\\"textcat\\\"\\n# This references the [components.textcat.model] block above\\nmodel = ${components.textcat.model}\\nlabels = []\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"Your trainable pipeline component factories should therefore always take a\\n\", _jsx(InlineCode, {\n            children: \"model\"\n          }), \" argument instead of instantiating the\\n\", _jsx(_components.a, {\n            href: \"https://thinc.ai/docs/api-model\",\n            children: _jsx(InlineCode, {\n              children: \"Model\"\n            })\n          }), \" inside the component. To register\\ncustom architectures, you can use the\\n\", _jsx(_components.a, {\n            href: \"/api/top-level#registry\",\n            children: _jsx(InlineCode, {\n              children: \"@spacy.registry.architectures\"\n            })\n          }), \" decorator. Also see\\nthe \", _jsx(_components.a, {\n            href: \"/usage/training#config\",\n            children: \"training guide\"\n          }), \" for details.\"]\n        })]\n      }), _jsx(_components.p, {\n        children: \"For some use cases, it makes sense to also overwrite additional methods to\\ncustomize how the model is updated from examples, how it’s initialized, how the\\nloss is calculated and to add evaluation scores to the training output.\"\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Description\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#update\",\n                children: _jsx(InlineCode, {\n                  children: \"update\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Learn from a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects containing the predictions and gold-standard annotations, and update the component’s model.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"initialize\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Initialize the model. Typically calls into \", _jsx(_components.a, {\n                href: \"https://thinc.ai/docs/api-model#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"Model.initialize\"\n                })\n              }), \" and can be passed custom arguments via the \", _jsx(_components.a, {\n                href: \"/api/data-formats#config-initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"[initialize]\"\n                })\n              }), \" config block that are only loaded during training or when you call \", _jsx(_components.a, {\n                href: \"/api/language#initialize\",\n                children: _jsx(InlineCode, {\n                  children: \"nlp.initialize\"\n                })\n              }), \", not at runtime.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#get_loss\",\n                children: _jsx(InlineCode, {\n                  children: \"get_loss\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Return a tuple of the loss and the gradient for a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects.\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.a, {\n                href: \"/api/pipe#score\",\n                children: _jsx(InlineCode, {\n                  children: \"score\"\n                })\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Score a batch of \", _jsx(_components.a, {\n                href: \"/api/example\",\n                children: _jsx(InlineCode, {\n                  children: \"Example\"\n                })\n              }), \" objects and return a dictionary of scores. The \", _jsx(_components.a, {\n                href: \"/api/language#factory\",\n                children: _jsx(InlineCode, {\n                  children: \"@Language.factory\"\n                })\n              }), \" decorator can define the \", _jsx(InlineCode, {\n                children: \"default_score_weights\"\n              }), \" of the component to decide which keys of the scores to display during training and how they count towards the final score.\"]\n            })]\n          })]\n        })]\n      }), _jsx(Infobox, {\n        title: \"Custom trainable components and models\",\n        emoji: \"📖\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on how to implement your own trainable components and model\\narchitectures, and plug existing models implemented in PyTorch or TensorFlow\\ninto your spaCy pipeline, see the usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/layers-architectures#components\",\n            children: \"layers and model architectures\"\n          }), \".\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-custom-components-attributes\",\n      children: [_jsx(_components.h2, {\n        id: \"custom-components-attributes\",\n        version: \"2\",\n        children: \"Extension attributes \"\n      }), _jsxs(_components.p, {\n        children: [\"spaCy allows you to set any custom attributes and methods on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \"\\nand \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \", which become available as \", _jsx(InlineCode, {\n          children: \"Doc._\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span._\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token._\"\n        }), \" – for\\nexample, \", _jsx(InlineCode, {\n          children: \"Token._.my_attr\"\n        }), \". This lets you store additional information relevant\\nto your application, add new features and functionality to spaCy, and implement\\nyour own models trained with other machine learning libraries. It also lets you\\ntake advantage of spaCy’s data structures and the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object as the “single\\nsource of truth”.\"]\n      }), _jsx(Accordion, {\n        title: \"Why ._ and not just a top-level attribute?\",\n        id: \"why-dot-underscore\",\n        children: _jsxs(_components.p, {\n          children: [\"Writing to a \", _jsx(InlineCode, {\n            children: \"._\"\n          }), \" attribute instead of to the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" directly keeps a clearer\\nseparation and makes it easier to ensure backwards compatibility. For example,\\nif you’ve implemented your own \", _jsx(InlineCode, {\n            children: \".coref\"\n          }), \" property and spaCy claims it one day,\\nit’ll break your code. Similarly, just by looking at the code, you’ll\\nimmediately know what’s built-in and what’s custom – for example,\\n\", _jsx(InlineCode, {\n            children: \"doc.sentiment\"\n          }), \" is spaCy, while \", _jsx(InlineCode, {\n            children: \"doc._.sent_score\"\n          }), \" isn’t.\"]\n        })\n      }), _jsx(Accordion, {\n        title: \"How is the ._ implemented?\",\n        id: \"dot-underscore-implementation\",\n        children: _jsxs(_components.p, {\n          children: [\"Extension definitions – the defaults, methods, getters and setters you pass in\\nto \", _jsx(InlineCode, {\n            children: \"set_extension\"\n          }), \" – are stored in class attributes on the \", _jsx(InlineCode, {\n            children: \"Underscore\"\n          }), \" class.\\nIf you write to an extension attribute, e.g. \", _jsx(InlineCode, {\n            children: \"doc._.hello = True\"\n          }), \", the data is\\nstored within the \", _jsx(_components.a, {\n            href: \"/api/doc#attributes\",\n            children: _jsx(InlineCode, {\n              children: \"Doc.user_data\"\n            })\n          }), \" dictionary. To keep the\\nunderscore data separate from your other dictionary entries, the string \", _jsx(InlineCode, {\n            children: \"\\\"._.\\\"\"\n          }), \"\\nis placed before the name, in a tuple.\"]\n        })\n      }), _jsx(_components.hr, {}), _jsxs(_components.p, {\n        children: [\"There are three main types of extensions, which can be defined using the\\n\", _jsx(_components.a, {\n          href: \"/api/doc#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.set_extension\"\n          })\n        }), \",\\n\", _jsx(_components.a, {\n          href: \"/api/span#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Span.set_extension\"\n          })\n        }), \" and\\n\", _jsx(_components.a, {\n          href: \"/api/token#set_extension\",\n          children: _jsx(InlineCode, {\n            children: \"Token.set_extension\"\n          })\n        }), \" methods.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      children: [_jsx(_components.h2, {\n        children: \"Description\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Attribute extensions.\"\n            }), \" Set a default value for an attribute, which can be\\noverwritten manually at any time. Attribute extensions work like “normal”\\nvariables and are the quickest way to store arbitrary information on a \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \",\\n\", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \".\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \" Doc.set_extension(\\\"hello\\\", default=True)\\n assert doc._.hello\\n doc._.hello = False\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Property extensions.\"\n            }), \" Define a getter and an optional setter function. If\\nno setter is provided, the extension is immutable. Since the getter and\\nsetter functions are only called when you \", _jsx(_components.em, {\n              children: \"retrieve\"\n            }), \" the attribute, you can\\nalso access values of previously added attribute extensions. For example, a\\n\", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" getter can average over \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" attributes. For \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" extensions,\\nyou’ll almost always want to use a property – otherwise, you’d have to write\\nto \", _jsx(_components.em, {\n              children: \"every possible\"\n            }), \" \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" in the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \" to set up the values correctly.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \"Doc.set_extension(\\\"hello\\\", getter=get_hello_value, setter=set_hello_value)\\nassert doc._.hello\\ndoc._.hello = \\\"Hi!\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Method extensions.\"\n            }), \" Assign a function that becomes available as an object\\nmethod. Method extensions are always immutable. For more details and\\nimplementation ideas, see\\n\", _jsx(_components.a, {\n              href: \"/usage/examples#custom-components-attr-methods\",\n              children: \"these examples\"\n            }), \".\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-python\",\n              lang: \"python\",\n              children: \"Doc.set_extension(\\\"hello\\\", method=lambda doc, name: f\\\"Hi {name}!\\\")\\nassert doc._.hello(\\\"Bob\\\") == \\\"Hi Bob!\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Before you can access a custom extension, you need to register it using the\\n\", _jsx(InlineCode, {\n          children: \"set_extension\"\n        }), \" method on the object you want to add it to, e.g. the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \". Keep\\nin mind that extensions are always \", _jsx(_components.strong, {\n          children: \"added globally\"\n        }), \" and not just on a\\nparticular instance. If an attribute of the same name already exists, or if\\nyou’re trying to access an attribute that hasn’t been registered, spaCy will\\nraise an \", _jsx(InlineCode, {\n          children: \"AttributeError\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Example\",\n          children: \"from spacy.tokens import Doc, Span, Token\\n\\nfruits = [\\\"apple\\\", \\\"pear\\\", \\\"banana\\\", \\\"orange\\\", \\\"strawberry\\\"]\\nis_fruit_getter = lambda token: token.text in fruits\\nhas_fruit_getter = lambda obj: any([t.text in fruits for t in obj])\\n\\nToken.set_extension(\\\"is_fruit\\\", getter=is_fruit_getter)\\nDoc.set_extension(\\\"has_fruit\\\", getter=has_fruit_getter)\\nSpan.set_extension(\\\"has_fruit\\\", getter=has_fruit_getter)\\n\"\n        })\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Usage example\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"doc = nlp(\\\"I have an apple and a melon\\\")\\nassert doc[3]._.is_fruit      # get Token attributes\\nassert not doc[0]._.is_fruit\\nassert doc._.has_fruit        # get Doc attributes\\nassert doc[1:4]._.has_fruit   # get Span attributes\\n\"\n          })\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Once you’ve registered your custom attribute, you can also use the built-in\\n\", _jsx(InlineCode, {\n          children: \"set\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"get\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"has\"\n        }), \" methods to modify and retrieve the attributes. This is\\nespecially useful it you want to pass in a string instead of calling\\n\", _jsx(InlineCode, {\n          children: \"doc._.my_attr\"\n        }), \".\"]\n      }), _jsx(_components.h3, {\n        id: \"component-example3\",\n        children: \"Example: Pipeline component for GPE entities and country meta data via a REST API \"\n      }), _jsxs(_components.p, {\n        children: [\"This example shows the implementation of a pipeline component that fetches\\ncountry meta data via the \", _jsx(_components.a, {\n          href: \"https://restcountries.com\",\n          children: \"REST Countries API\"\n        }), \", sets\\nentity annotations for countries and sets custom attributes on the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" and\\n\", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" – for example, the capital, latitude/longitude coordinates and even the\\ncountry flag.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          executable: \"true\",\n          children: \"import requests\\nfrom spacy.lang.en import English\\nfrom spacy.language import Language\\nfrom spacy.matcher import PhraseMatcher\\nfrom spacy.tokens import Doc, Span, Token\\n\\n@Language.factory(\\\"rest_countries\\\")\\nclass RESTCountriesComponent:\\n    def __init__(self, nlp, name, label=\\\"GPE\\\"):\\n        r = requests.get(\\\"https://restcountries.com/v2/all\\\")\\n        r.raise_for_status()  # make sure requests raises an error if it fails\\n        countries = r.json()\\n        # Convert API response to dict keyed by country name for easy lookup\\n        self.countries = {c[\\\"name\\\"]: c for c in countries}\\n        self.label = label\\n        # Set up the PhraseMatcher with Doc patterns for each country name\\n        self.matcher = PhraseMatcher(nlp.vocab)\\n        self.matcher.add(\\\"COUNTRIES\\\", [nlp.make_doc(c) for c in self.countries.keys()])\\n        # Register attributes on the Span. We'll be overwriting this based on\\n        # the matches, so we're only setting a default value, not a getter.\\n        Span.set_extension(\\\"is_country\\\", default=None)\\n        Span.set_extension(\\\"country_capital\\\", default=None)\\n        Span.set_extension(\\\"country_latlng\\\", default=None)\\n        Span.set_extension(\\\"country_flag\\\", default=None)\\n        # Register attribute on Doc via a getter that checks if the Doc\\n        # contains a country entity\\n        Doc.set_extension(\\\"has_country\\\", getter=self.has_country)\\n\\n    def __call__(self, doc):\\n        spans = []  # keep the spans for later so we can merge them afterwards\\n        for _, start, end in self.matcher(doc):\\n            # Generate Span representing the entity \u0026 set label\\n            entity = Span(doc, start, end, label=self.label)\\n            # Set custom attributes on entity. Can be extended with other data\\n            # returned by the API, like currencies, country code, calling code etc.\\n            entity._.set(\\\"is_country\\\", True)\\n            entity._.set(\\\"country_capital\\\", self.countries[entity.text][\\\"capital\\\"])\\n            entity._.set(\\\"country_latlng\\\", self.countries[entity.text][\\\"latlng\\\"])\\n            entity._.set(\\\"country_flag\\\", self.countries[entity.text][\\\"flag\\\"])\\n            spans.append(entity)\\n        # Overwrite doc.ents and add entity – be careful not to replace!\\n        doc.ents = list(doc.ents) + spans\\n        return doc  # don't forget to return the Doc!\\n\\n    def has_country(self, doc):\\n        \\\"\\\"\\\"Getter for Doc attributes. Since the getter is only called\\n        when we access the attribute, we can refer to the Span's 'is_country'\\n        attribute here, which is already set in the processing step.\\\"\\\"\\\"\\n        return any([entity._.get(\\\"is_country\\\") for entity in doc.ents])\\n\\nnlp = English()\\nnlp.add_pipe(\\\"rest_countries\\\", config={\\\"label\\\": \\\"GPE\\\"})\\ndoc = nlp(\\\"Some text about Colombia and the Czech Republic\\\")\\nprint(\\\"Pipeline\\\", nlp.pipe_names)  # pipeline contains component name\\nprint(\\\"Doc has countries\\\", doc._.has_country)  # Doc contains countries\\nfor ent in doc.ents:\\n    if ent._.is_country:\\n        print(ent.text, ent.label_, ent._.country_capital, ent._.country_latlng, ent._.country_flag)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"In this case, all data can be fetched on initialization in one request. However,\\nif you’re working with text that contains incomplete country names, spelling\\nmistakes or foreign-language versions, you could also implement a\\n\", _jsx(InlineCode, {\n          children: \"like_country\"\n        }), \"-style getter function that makes a request to the search API\\nendpoint and returns the best-matching result.\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-user-hooks\",\n        children: \"User hooks \"\n      }), _jsxs(_components.p, {\n        children: [\"While it’s generally recommended to use the \", _jsx(InlineCode, {\n          children: \"Doc._\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span._\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Token._\"\n        }), \"\\nproxies to add your own custom attributes, spaCy offers a few exceptions to\\nallow \", _jsx(_components.strong, {\n          children: \"customizing the built-in methods\"\n        }), \" like\\n\", _jsx(_components.a, {\n          href: \"/api/doc#similarity\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.similarity\"\n          })\n        }), \" or \", _jsx(_components.a, {\n          href: \"/api/doc#vector\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.vector\"\n          })\n        }), \" with\\nyour own hooks, which can rely on components you train yourself. For instance,\\nyou can provide your own on-the-fly sentence segmentation algorithm or document\\nsimilarity method.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Hooks let you customize some of the behaviors of the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" or \", _jsx(InlineCode, {\n          children: \"Token\"\n        }), \"\\nobjects by adding a component to the pipeline. For instance, to customize the\\n\", _jsx(_components.a, {\n          href: \"/api/doc#similarity\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.similarity\"\n          })\n        }), \" method, you can add a component that\\nsets a custom function to \", _jsx(InlineCode, {\n          children: \"doc.user_hooks[\\\"similarity\\\"]\"\n        }), \". The built-in\\n\", _jsx(InlineCode, {\n          children: \"Doc.similarity\"\n        }), \" method will check the \", _jsx(InlineCode, {\n          children: \"user_hooks\"\n        }), \" dict, and delegate to your\\nfunction if you’ve set one. Similar results can be achieved by setting functions\\nto \", _jsx(InlineCode, {\n          children: \"Doc.user_span_hooks\"\n        }), \" and \", _jsx(InlineCode, {\n          children: \"Doc.user_token_hooks\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Implementation note\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"The hooks live on the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" object because the \", _jsx(InlineCode, {\n            children: \"Span\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"Token\"\n          }), \" objects are\\ncreated lazily, and don’t own any data. They just proxy to their parent \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \".\\nThis turns out to be convenient here – we only have to worry about installing\\nhooks in one place.\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Name\"\n            }), _jsx(_components.th, {\n              children: \"Customizes\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/doc#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/doc#sents\",\n                children: _jsx(InlineCode, {\n                  children: \"Doc.sents\"\n                })\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_token_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/token#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/token#conjuncts\",\n                children: _jsx(InlineCode, {\n                  children: \"Token.conjuncts\"\n                })\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(InlineCode, {\n                children: \"user_span_hooks\"\n              })\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.a, {\n                href: \"/api/span#similarity\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.similarity\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#has_vector\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.has_vector\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#vector_norm\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.vector_norm\"\n                })\n              }), \", \", _jsx(_components.a, {\n                href: \"/api/span#root\",\n                children: _jsx(InlineCode, {\n                  children: \"Span.root\"\n                })\n              })]\n            })]\n          })]\n        })]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          title: \"Add custom similarity hooks\",\n          children: \"from spacy.language import Language\\n\\n\\nclass SimilarityModel:\\n    def __init__(self, name: str, index: int):\\n        self.name = name\\n        self.index = index\\n\\n    def __call__(self, doc):\\n        doc.user_hooks[\\\"similarity\\\"] = self.similarity\\n        doc.user_span_hooks[\\\"similarity\\\"] = self.similarity\\n        doc.user_token_hooks[\\\"similarity\\\"] = self.similarity\\n        return doc\\n\\n    def similarity(self, obj1, obj2):\\n        return obj1.vector[self.index] + obj2.vector[self.index]\\n\\n\\n@Language.factory(\\\"similarity_component\\\", default_config={\\\"index\\\": 0})\\ndef create_similarity_component(nlp, name, index: int):\\n    return SimilarityModel(name, index)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.section, {\n      id: \"section-plugins\",\n      children: [_jsx(_components.h2, {\n        id: \"plugins\",\n        children: \"Developing plugins and wrappers \"\n      }), _jsxs(_components.p, {\n        children: [\"We’re very excited about all the new possibilities for community extensions and\\nplugins in spaCy, and we can’t wait to see what you build with it! To get you\\nstarted, here are a few tips, tricks and best\\npractices. \", _jsx(_components.a, {\n          href: \"/universe/?category=pipeline\",\n          children: \"See here\"\n        }), \" for examples of other spaCy\\nextensions.\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-usage-ideas\",\n        children: \"Usage ideas \"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Adding new features and hooking in models.\"\n          }), \" For example, a sentiment\\nanalysis model, or your preferred solution for lemmatization or sentiment\\nanalysis. spaCy’s built-in tagger, parser and entity recognizer respect\\nannotations that were already set on the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" in a previous step of the\\npipeline.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Integrating other libraries and APIs.\"\n          }), \" For example, your pipeline component\\ncan write additional information and data directly to the \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" or \", _jsx(InlineCode, {\n            children: \"Token\"\n          }), \" as\\ncustom attributes, while making sure no information is lost in the process.\\nThis can be output generated by other libraries and models, or an external\\nservice with a REST API.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Debugging and logging.\"\n          }), \" For example, a component which stores and/or\\nexports relevant information about the current state of the processed\\ndocument, and insert it at any point of your pipeline.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"custom-components-best-practices\",\n        children: \"Best practices \"\n      }), _jsxs(_components.p, {\n        children: [\"Extensions can claim their own \", _jsx(InlineCode, {\n          children: \"._\"\n        }), \" namespace and exist as standalone packages.\\nIf you’re developing a tool or library and want to make it easy for others to\\nuse it with spaCy and add it to their pipeline, all you have to do is expose a\\nfunction that takes a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \", modifies it and returns it.\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Make sure to choose a \", _jsx(_components.strong, {\n              children: \"descriptive and specific name\"\n            }), \" for your pipeline\\ncomponent class, and set it as its \", _jsx(InlineCode, {\n              children: \"name\"\n            }), \" attribute. Avoid names that are too\\ncommon or likely to clash with built-in or a user’s other custom components.\\nWhile it’s fine to call your package \", _jsx(InlineCode, {\n              children: \"\\\"spacy_my_extension\\\"\"\n            }), \", avoid component\\nnames including \", _jsx(InlineCode, {\n              children: \"\\\"spacy\\\"\"\n            }), \", since this can easily lead to confusion.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ name = \\\"myapp_lemmatizer\\\"\\n- name = \\\"lemmatizer\\\"\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"When writing to \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \" objects, \", _jsx(_components.strong, {\n              children: \"use getter functions\"\n            }), \"\\nwherever possible, and avoid setting values explicitly. Tokens and spans don’t\\nown any data themselves, and they’re implemented as C extension classes – so\\nyou can’t usually add new attributes to them like you could with most pure\\nPython objects.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ is_fruit = lambda token: token.text in (\\\"apple\\\", \\\"orange\\\")\\n+ Token.set_extension(\\\"is_fruit\\\", getter=is_fruit)\\n\\n- token._.set_extension(\\\"is_fruit\\\", default=False)\\n- if token.text in ('\\\"apple\\\", \\\"orange\\\"):\\n-     token._.set(\\\"is_fruit\\\", True)\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Always add your custom attributes to the \", _jsx(_components.strong, {\n              children: \"global\"\n            }), \" \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \"\\nobjects, not a particular instance of them. Add the attributes \", _jsx(_components.strong, {\n              children: \"as early as\\npossible\"\n            }), \", e.g. in your extension’s \", _jsx(InlineCode, {\n              children: \"__init__\"\n            }), \" method or in the global scope\\nof your module. This means that in the case of namespace collisions, the user\\nwill see an error immediately, not just when they run their pipeline.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ from spacy.tokens import Doc\\n+ def __init__(attr=\\\"my_attr\\\"):\\n+     Doc.set_extension(attr, getter=self.get_doc_attr)\\n\\n- def __call__(doc):\\n-     doc.set_extension(\\\"my_attr\\\", getter=self.get_doc_attr)\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"If your extension is setting properties on the \", _jsx(InlineCode, {\n              children: \"Doc\"\n            }), \", \", _jsx(InlineCode, {\n              children: \"Token\"\n            }), \" or \", _jsx(InlineCode, {\n              children: \"Span\"\n            }), \",\\ninclude an option to \", _jsx(_components.strong, {\n              children: \"let the user to change those attribute names\"\n            }), \". This\\nmakes it easier to avoid namespace collisions and accommodate users with\\ndifferent naming preferences. We recommend adding an \", _jsx(InlineCode, {\n              children: \"attrs\"\n            }), \" argument to the\\n\", _jsx(InlineCode, {\n              children: \"__init__\"\n            }), \" method of your class so you can write the names to class attributes\\nand reuse them across your component.\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-diff\",\n              lang: \"diff\",\n              children: \"+ Doc.set_extension(self.doc_attr, default=\\\"some value\\\")\\n- Doc.set_extension(\\\"my_doc_attr\\\", default=\\\"some value\\\")\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Ideally, extensions should be \", _jsx(_components.strong, {\n              children: \"standalone packages\"\n            }), \" with spaCy and\\noptionally, other packages specified as a dependency. They can freely assign\\nto their own \", _jsx(InlineCode, {\n              children: \"._\"\n            }), \" namespace, but should stick to that. If your extension’s\\nonly job is to provide a better \", _jsx(InlineCode, {\n              children: \".similarity\"\n            }), \" implementation, and your docs\\nstate this explicitly, there’s no problem with writing to the\\n\", _jsx(_components.a, {\n              href: \"#custom-components-user-hooks\",\n              children: _jsx(InlineCode, {\n                children: \"user_hooks\"\n              })\n            }), \" and overwriting spaCy’s built-in\\nmethod. However, a third-party extension should \", _jsx(_components.strong, {\n              children: \"never silently overwrite\\nbuilt-ins\"\n            }), \", or attributes set by other extensions.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"If you’re looking to publish a pipeline package that depends on a custom\\npipeline component, you can either \", _jsx(_components.strong, {\n              children: \"require it\"\n            }), \" in the package’s\\ndependencies, or – if the component is specific and lightweight – choose to\\n\", _jsx(_components.strong, {\n              children: \"ship it with your pipeline package\"\n            }), \". Just make sure the\\n\", _jsx(_components.a, {\n              href: \"/api/language#component\",\n              children: _jsx(InlineCode, {\n                children: \"@Language.component\"\n              })\n            }), \" or\\n\", _jsx(_components.a, {\n              href: \"/api/language#factory\",\n              children: _jsx(InlineCode, {\n                children: \"@Language.factory\"\n              })\n            }), \" decorator that registers the\\ncustom component runs in your package’s \", _jsx(InlineCode, {\n              children: \"__init__.py\"\n            }), \" or is exposed via an\\n\", _jsx(_components.a, {\n              href: \"/usage/saving-loading#entry-points\",\n              children: \"entry point\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Once you’re ready to share your extension with others, make sure to \", _jsx(_components.strong, {\n              children: \"add docs\\nand installation instructions\"\n            }), \" (you can always link to this page for more\\ninfo). Make it easy for others to install and use your extension, for example\\nby uploading it to \", _jsx(_components.a, {\n              href: \"https://pypi.python.org\",\n              children: \"PyPi\"\n            }), \". If you’re sharing your\\ncode on GitHub, don’t forget to tag it with\\n\", _jsx(_components.a, {\n              href: \"https://github.com/topics/spacy?o=desc\u0026s=stars\",\n              children: _jsx(InlineCode, {\n                children: \"spacy\"\n              })\n            }), \" and\\n\", _jsx(_components.a, {\n              href: \"https://github.com/topics/spacy-extension?o=desc\u0026s=stars\",\n              children: _jsx(InlineCode, {\n                children: \"spacy-extension\"\n              })\n            }), \"\\nto help people find it. If you post it on Twitter, feel free to tag\\n\", _jsx(_components.a, {\n              href: \"https://twitter.com/spacy_io\",\n              children: \"@spacy_io\"\n            }), \" so we can check it out.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), _jsx(_components.h3, {\n        id: \"wrapping-models-libraries\",\n        children: \"Wrapping other models and libraries \"\n      }), _jsxs(_components.p, {\n        children: [\"Let’s say you have a custom entity recognizer that takes a list of strings and\\nreturns their \", _jsx(_components.a, {\n          href: \"/usage/linguistic-features#accessing-ner\",\n          children: \"BILUO tags\"\n        }), \". Given an\\ninput like \", _jsx(InlineCode, {\n          children: \"[\\\"A\\\", \\\"text\\\", \\\"about\\\", \\\"Facebook\\\"]\"\n        }), \", it will predict and return\\n\", _jsx(InlineCode, {\n          children: \"[\\\"O\\\", \\\"O\\\", \\\"O\\\", \\\"U-ORG\\\"]\"\n        }), \". To integrate it into your spaCy pipeline and make it\\nadd those entities to the \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \", you can wrap it in a custom pipeline\\ncomponent function and pass it the token texts from the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object received by\\nthe component.\"]\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.a, {\n          href: \"/api/top-level#biluo_tags_to_spans\",\n          children: _jsx(InlineCode, {\n            children: \"training.biluo_tags_to_spans\"\n          })\n        }), \" is very\\nhelpful here, because it takes a \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object and token-based BILUO tags and\\nreturns a sequence of \", _jsx(InlineCode, {\n          children: \"Span\"\n        }), \" objects in the \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" with added labels. So all your\\nwrapper has to do is compute the entity spans and overwrite the \", _jsx(InlineCode, {\n          children: \"doc.ents\"\n        }), \".\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"How the doc.ents work\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"When you add spans to the \", _jsx(InlineCode, {\n            children: \"doc.ents\"\n          }), \", spaCy will automatically resolve them\\nback to the underlying tokens and set the \", _jsx(InlineCode, {\n            children: \"Token.ent_type\"\n          }), \" and \", _jsx(InlineCode, {\n            children: \"Token.ent_iob\"\n          }), \"\\nattributes. By definition, each token can only be part of one entity, so\\noverlapping entity spans are not allowed.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"1,8-9\",\n          children: \"import your_custom_entity_recognizer\\nfrom spacy.training import biluo_tags_to_spans\\nfrom spacy.language import Language\\n\\n@Language.component(\\\"custom_ner_wrapper\\\")\\ndef custom_ner_wrapper(doc):\\n    words = [token.text for token in doc]\\n    custom_entities = your_custom_entity_recognizer(words)\\n    doc.ents = biluo_tags_to_spans(doc, custom_entities)\\n    return doc\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"The \", _jsx(InlineCode, {\n          children: \"custom_ner_wrapper\"\n        }), \" can then be added to a blank pipeline using\\n\", _jsx(_components.a, {\n          href: \"/api/language#add_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.add_pipe\"\n          })\n        }), \". You can also replace the existing\\nentity recognizer of a trained pipeline with\\n\", _jsx(_components.a, {\n          href: \"/api/language#replace_pipe\",\n          children: _jsx(InlineCode, {\n            children: \"nlp.replace_pipe\"\n          })\n        }), \".\"]\n      }), _jsxs(_components.p, {\n        children: [\"Here’s another example of a custom model, \", _jsx(InlineCode, {\n          children: \"your_custom_model\"\n        }), \", that takes a list\\nof tokens and returns lists of fine-grained part-of-speech tags, coarse-grained\\npart-of-speech tags, dependency labels and head token indices. Here, we can use\\nthe \", _jsx(_components.a, {\n          href: \"/api/doc#from_array\",\n          children: _jsx(InlineCode, {\n            children: \"Doc.from_array\"\n          })\n        }), \" to create a new \", _jsx(InlineCode, {\n          children: \"Doc\"\n        }), \" object using\\nthose values. To create a numpy array we need integers, so we can look up the\\nstring labels in the \", _jsx(_components.a, {\n          href: \"/api/stringstore\",\n          children: _jsx(InlineCode, {\n            children: \"StringStore\"\n          })\n        }), \". The\\n\", _jsx(_components.a, {\n          href: \"/api/stringstore#add\",\n          children: _jsx(InlineCode, {\n            children: \"doc.vocab.strings.add\"\n          })\n        }), \" method comes in handy here,\\nbecause it returns the integer ID of the string \", _jsx(_components.em, {\n          children: \"and\"\n        }), \" makes sure it’s added to\\nthe vocab. This is especially important if the custom model uses a different\\nlabel scheme than spaCy’s default models.\"]\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"Example: spacy-stanza\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"For an example of an end-to-end wrapper for statistical tokenization, tagging\\nand parsing, check out\\n\", _jsx(_components.a, {\n            href: \"https://github.com/explosion/spacy-stanza\",\n            children: _jsx(InlineCode, {\n              children: \"spacy-stanza\"\n            })\n          }), \". It uses a very\\nsimilar approach to the example in this section – the only difference is that\\nit fully replaces the \", _jsx(InlineCode, {\n            children: \"nlp\"\n          }), \" object instead of providing a pipeline component,\\nsince it also needs to handle tokenization.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-python\",\n          lang: \"python\",\n          highlight: \"1,11,17-19\",\n          children: \"import your_custom_model\\nfrom spacy.language import Language\\nfrom spacy.symbols import POS, TAG, DEP, HEAD\\nfrom spacy.tokens import Doc\\nimport numpy\\n\\n@Language.component(\\\"custom_model_wrapper\\\")\\ndef custom_model_wrapper(doc):\\n    words = [token.text for token in doc]\\n    spaces = [token.whitespace for token in doc]\\n    pos, tags, deps, heads = your_custom_model(words)\\n    # Convert the strings to integers and add them to the string store\\n    pos = [doc.vocab.strings.add(label) for label in pos]\\n    tags = [doc.vocab.strings.add(label) for label in tags]\\n    deps = [doc.vocab.strings.add(label) for label in deps]\\n    # Create a new Doc from a numpy array\\n    attrs = [POS, TAG, DEP, HEAD]\\n    arr = numpy.array(list(zip(pos, tags, deps, heads)), dtype=\\\"uint64\\\")\\n    new_doc = Doc(doc.vocab, words=words, spaces=spaces).from_array(attrs, arr)\\n    return new_doc\\n\"\n        })\n      }), _jsxs(Infobox, {\n        title: \"Sentence boundaries and heads\",\n        variant: \"warning\",\n        children: [_jsxs(_components.p, {\n          children: [\"If you create a \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" object with dependencies and heads, spaCy is able to\\nresolve the sentence boundaries automatically. However, note that the \", _jsx(InlineCode, {\n            children: \"HEAD\"\n          }), \"\\nvalue used to construct a \", _jsx(InlineCode, {\n            children: \"Doc\"\n          }), \" is the token index \", _jsx(_components.strong, {\n            children: \"relative\"\n          }), \" to the current\\ntoken – e.g. \", _jsx(InlineCode, {\n            children: \"-1\"\n          }), \" for the previous token. The CoNLL format typically annotates\\nheads as \", _jsx(InlineCode, {\n            children: \"1\"\n          }), \"-indexed absolute indices with \", _jsx(InlineCode, {\n            children: \"0\"\n          }), \" indicating the root. If that’s\\nthe case in your annotations, you need to convert them first:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            lang: \"python\",\n            children: \"heads = [2, 0, 4, 2, 2]\\nnew_heads = [head - i - 1 if head != 0 else 0 for i, head in enumerate(heads)]\\n\"\n          })\n        })]\n      }), _jsx(Infobox, {\n        title: \"Advanced usage, serialization and entry points\",\n        emoji: \"📖\",\n        children: _jsxs(_components.p, {\n          children: [\"For more details on how to write and package custom components, make them\\navailable to spaCy via entry points and implement your own serialization\\nmethods, check out the usage guide on\\n\", _jsx(_components.a, {\n            href: \"/usage/saving-loading\",\n            children: \"saving and loading\"\n          }), \".\"]\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Language Processing Pipelines","next":"/usage/embeddings-transformers","menu":[["Processing Text","processing"],["Pipelines \u0026 Components","pipelines"],["Custom Components","custom-components"],["Component Data","component-data"],["Type Hints \u0026 Validation","type-hints"],["Trainable Components","trainable-components"],["Extension Attributes","custom-components-attributes"],["Plugins \u0026 Wrappers","plugins"]]},"scope":{}},"sectionTitle":"Usage Documentation","theme":"blue","section":"usage","apiDetails":{"stringName":null,"baseClass":null,"trainable":null},"isIndex":false},"__N_SSG":true},"page":"/[...listPathPage]","query":{"listPathPage":["usage","processing-pipelines"]},"buildId":"2lY2cUyEfZosk4VLgkHb2","isFallback":false,"dynamicIds":[728,5492],"gsp":true,"scriptLoader":[]}</script></body></html>